[
  {
    "type": "userMessage",
    "contents": [
      {
        "type": "text",
        "text": "Make shopping mall backend system"
      }
    ],
    "created_at": "2025-05-23T12:19:06.900Z"
  },
  {
    "type": "analyzeStart",
    "reason": "User requested to make shopping mall backend system",
    "step": 0,
    "created_at": "2025-05-23T12:19:06.900Z"
  },
  {
    "type": "analyzeComplete",
    "files": {
      "index.md": "I'll provide an English version of the detailed requirements analysis report for the Bulletin Board System.\r\n\r\n# Bulletin Board System Requirements Detailed Analysis Report\r\n\r\n## 1. System Overview\r\n\r\nThis system is a web-based Bulletin Board System that allows users to create posts and communicate through comments. The most distinctive feature of this system is its snapshot-based history management mechanism that preserves all content revision histories to maintain evidence and verify authenticity in case of disputes among users.\r\n\r\n## 2. Core Requirements\r\n\r\n### 2.1 Evidence Preservation Mechanism\r\n\r\nThe most critical requirement of the system is to thoroughly preserve the revision history of all content (posts and comments). This should be implemented as follows:\r\n\r\n1. **Snapshot-based History Management**:\r\n   - When a post or comment is first created, an initial snapshot is generated\r\n   - Each time content is modified, a new snapshot is additionally created\r\n   - Existing snapshots are never modified or deleted\r\n   - Each snapshot must include information such as content, creation time, IP address, etc.\r\n\r\n2. **Logical Deletion Method**:\r\n   - When posts or comments are deleted, they are not actually removed from the database\r\n   - Instead, a deletion time (deleted_at) is recorded for logical deletion\r\n   - Deleted items should not be visible to general users but should be accessible for administrative purposes\r\n\r\n3. **Modification Verification Elements**:\r\n   - All snapshots must record the author's IP address\r\n   - All actions must have precise timestamps\r\n   - Password verification is required for modification/deletion\r\n\r\n### 2.2 Post Functionality Requirements\r\n\r\n1. **Post Creation**:\r\n   - Users must be able to create posts including title and body\r\n   - Author name and password input are required when creating posts\r\n   - The body should be writable in various formats (HTML, Markdown, plain text, etc.)\r\n   - File attachment functionality must be supported\r\n\r\n2. **Post Viewing**:\r\n   - The post list should display the title of the latest version\r\n   - The detail page should primarily display the latest version of content\r\n   - It should be possible to view previous versions (snapshots) as needed\r\n   - Attached file list and download functionality should be provided\r\n\r\n3. **Post Modification**:\r\n   - Authors can modify posts after password verification\r\n   - Modification creates a new snapshot while preserving existing content\r\n   - Attachments should also be modifiable (add/delete/reorder)\r\n\r\n4. **Post Deletion**:\r\n   - Authors can delete posts after password verification\r\n   - Deletion must be implemented as logical deletion (soft delete)\r\n   - Deleted posts should be excluded from general viewing but accessible for administrative purposes\r\n\r\n### 2.3 Comment Functionality Requirements\r\n\r\n1. **Comment Creation**:\r\n   - Users must be able to create comments on posts\r\n   - Author name and password input are required when creating comments\r\n   - The body should be writable in various formats\r\n   - File attachment functionality must be supported\r\n\r\n2. **Hierarchical Comment Structure**:\r\n   - It should be possible to write replies to comments (nested comments)\r\n   - The hierarchical relationship between replies and original comments should be visually represented\r\n   - The hierarchical structure should support unlimited depth\r\n\r\n3. **Comment Modification**:\r\n   - Authors can modify comments after password verification\r\n   - Modification creates a new snapshot while preserving existing content\r\n   - Attachments should also be modifiable\r\n\r\n4. **Comment Deletion**:\r\n   - Authors can delete comments after password verification\r\n   - Deletion must be implemented as logical deletion\r\n   - Deleted comments should be excluded from general viewing but accessible for administrative purposes\r\n\r\n### 2.4 File Attachment Requirements\r\n\r\n1. **File Upload**:\r\n   - It should be possible to attach files when creating/modifying posts and comments\r\n   - Upload of various file formats should be supported\r\n   - Filenames and extensions should be managed separately (files without extensions should also be processable)\r\n\r\n2. **File Management**:\r\n   - Attached files should be displayed in a specific order (sequence)\r\n   - Users should be able to specify or change the file order\r\n   - Files should be accessible via unique URLs\r\n\r\n3. **File Download**:\r\n   - Users should be able to download attached files\r\n   - Files should be provided with the original filename when downloaded\r\n\r\n## 3. Non-functional Requirements\r\n\r\n### 3.1 Security Requirements\r\n\r\n1. **Password Security**:\r\n   - Passwords for posts and comments must be stored securely encrypted\r\n   - Password verification is required for modification/deletion\r\n\r\n2. **IP Address Recording**:\r\n   - IP addresses must be recorded for all creation and modification actions\r\n   - IP address information should have appropriate access restrictions for security reasons\r\n\r\n3. **Access Control**:\r\n   - General users should not be able to access deleted posts/comments\r\n   - Only administrators should have access to deleted items\r\n\r\n### 3.2 Performance Requirements\r\n\r\n1. **Viewing Performance Optimization**:\r\n   - Latest snapshot information should be efficiently retrievable when viewing post lists and details\r\n   - Posts with many comments should load quickly\r\n\r\n2. **Indexing Strategy**:\r\n   - Appropriate indexes should be configured for frequently queried fields\r\n   - Time-based sorting and filtering should operate quickly\r\n\r\n3. **File Processing Performance**:\r\n   - Large file uploads/downloads should be handled smoothly\r\n   - Performance degradation should be minimized even when attaching multiple files\r\n\r\n### 3.3 Scalability Requirements\r\n\r\n1. **Data Growth Management**:\r\n   - The system should continue to operate stably even as the number of posts and comments increases\r\n   - Data growth due to the snapshot approach should be efficiently managed\r\n\r\n2. **User Growth Management**:\r\n   - System performance should be maintained even as the number of simultaneous users increases\r\n\r\n## 4. User Interface Requirements\r\n\r\n### 4.1 Post-related UI\r\n\r\n1. **Post List Screen**:\r\n   - Display post title, author, creation date, comment count\r\n   - Provide pagination functionality\r\n   - Provide search functionality\r\n\r\n2. **Post Detail Screen**:\r\n   - Display title, body, author, creation date\r\n   - Provide attached file list and download links\r\n   - Include comment section\r\n   - Provide options to view previous versions (snapshots)\r\n\r\n3. **Post Creation/Modification Screen**:\r\n   - Title input field\r\n   - Body editor (supporting various formats)\r\n   - File attachment functionality\r\n   - Author name and password input fields\r\n\r\n### 4.2 Comment-related UI\r\n\r\n1. **Comment List**:\r\n   - Display in hierarchical structure (distinguished by indentation, etc.)\r\n   - Show author, creation date, content\r\n   - Provide reply creation option\r\n\r\n2. **Comment Creation/Modification Form**:\r\n   - Content input field\r\n   - File attachment functionality\r\n   - Author name and password input fields\r\n\r\n### 4.3 History Management UI\r\n\r\n1. **Snapshot History Screen**:\r\n   - Display list of all modification versions of posts/comments\r\n   - Provide information on creation time and IP address for each version\r\n   - Feature to visually display differences between versions\r\n\r\n## 5. Data Requirements\r\n\r\n### 5.1 Post-related Data\r\n\r\n1. **Post Basic Information**:\r\n   - Unique identifier (UUID)\r\n   - Author name\r\n   - Password (encrypted storage)\r\n   - Creation time\r\n   - Deletion time (if applicable)\r\n\r\n2. **Post Snapshot Information**:\r\n   - Unique identifier (UUID)\r\n   - Associated post ID\r\n   - Body format\r\n   - Title\r\n   - Body content\r\n   - Author's IP address\r\n   - Creation time\r\n\r\n### 5.2 Comment-related Data\r\n\r\n1. **Comment Basic Information**:\r\n   - Unique identifier (UUID)\r\n   - Associated post ID\r\n   - Parent comment ID (for replies)\r\n   - Author name\r\n   - Password (encrypted storage)\r\n   - Creation time\r\n   - Deletion time (if applicable)\r\n\r\n2. **Comment Snapshot Information**:\r\n   - Unique identifier (UUID)\r\n   - Associated comment ID\r\n   - Body format\r\n   - Body content\r\n   - Author's IP address\r\n   - Creation time\r\n\r\n### 5.3 Attachment-related Data\r\n\r\n1. **File Basic Information**:\r\n   - Unique identifier (UUID)\r\n   - Filename (excluding extension)\r\n   - Extension (can be null)\r\n   - File URL\r\n   - Creation time\r\n\r\n2. **Post-File Connection Information**:\r\n   - Associated post snapshot ID\r\n   - Associated file ID\r\n   - Sequence\r\n\r\n3. **Comment-File Connection Information**:\r\n   - Associated comment snapshot ID\r\n   - Associated file ID\r\n   - Sequence\r\n\r\n## 6. Conclusion and Implementation Considerations\r\n\r\nThe most prominent feature of this bulletin board system is its mechanism to thoroughly preserve the revision history of all content to maintain evidence and verify authenticity in case of disputes among users. This design considers the risks of disputes that can occur due to the nature of e-communities.\r\n\r\nThe following points should be particularly considered during implementation:\r\n\r\n1. **Data Growth Management**: As data continuously increases due to the snapshot approach, efficient storage and retrieval methods are necessary.\r\n\r\n2. **Performance Optimization**: Methods to quickly retrieve the latest snapshots are needed. Performance should be optimized using view tables and other techniques.\r\n\r\n3. **Security Enhancement**: Sensitive information such as passwords and IP addresses must be managed securely.\r\n\r\n4. **User Experience**: Despite having history management functionality, an intuitive and convenient interface should be provided to general users.\r\n\r\nBased on this requirements analysis report, the development team should be able to implement a highly reliable bulletin board system. The focus should be on building a user-friendly system while achieving the core objectives of evidence preservation and dispute prevention."
    },
    "step": 0,
    "created_at": "2025-05-23T12:19:06.900Z"
  },
  {
    "type": "prismaStart",
    "reason": "Start DB design after requirements analysis",
    "step": 0,
    "created_at": "2025-05-23T12:19:06.900Z"
  },
  {
    "type": "prismaComplete",
    "schemas": {
      "main.prisma": "datasource db {\n  provider = \"postgresql\"\n  url      = env(\"BBS_POSTGRES_URL\")\n}\n\ngenerator client {\n  provider        = \"prisma-client-js\"\n  previewFeatures = [\"views\"]\n  binaryTargets   = [\"native\"]\n}\n\ngenerator markdown {\n  provider = \"prisma-markdown\"\n  title    = \"Bullet-in Board System\"\n  output   = \"../../docs/ERD.md\"\n}\n\n//-----------------------------------------------------------\n// ARTICLES\n//-----------------------------------------------------------\n/// Attachment File.\n///\n/// Every attachment files that are managed in current system.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel attachment_files {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// File name, except extension.\n  name String @db.VarChar\n\n  /// Extension.\n  ///\n  /// Possible to omit like `README` case.\n  extension String? @db.VarChar\n\n  /// URL path of the real file.\n  url String @db.VarChar\n\n  /// Creation time of file.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  bbs_article_snapshot_files          bbs_article_snapshot_files[]\n  bbs_article_comment_snapshots_files bbs_article_comment_snapshot_files[]\n}\n\n/// Article entity.\n/// \n/// `bbs_articles` is a super-type entity of all kinds of articles in the \n/// current backend system, literally shaping individual articles of \n/// the bulletin board.\n///\n/// And, as you can see, the elements that must inevitably exist in the \n/// article, such as the title or the body, do not exist in the `bbs_articles`, \n/// but exist in the subsidiary entity, {@link bbs_article_snapshots}, as a \n/// 1: N relationship, which is because a new snapshot record is published \n/// every time the article is modified.\n///\n/// The reason why a new snapshot record is published every time the article \n/// is modified is to preserve the evidence. Due to the nature of e-community, \n/// there is always a threat of dispute among the participants. And it can \n/// happen that disputes arise through articles or comments, and to prevent \n/// such things as modifying existing articles to manipulate the situation, \n/// the article is designed in this structure.\n///\n/// In other words, to keep evidence, and prevent fraud.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel bbs_articles {\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Writer's name.\n  writer String @db.VarChar\n\n  /// Password for modification.\n  password String @db.VarChar\n\n  /// Creation time of article.\n  created_at DateTime @db.Timestamptz\n\n  /// Deletion time of article.\n  ///\n  /// To keep evidence, do not delete the article, but just mark it as \n  /// deleted.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  /// List of snapshots.\n  ///\n  /// It is created for the first time when an article is created, and is\n  /// accumulated every time the article is modified.\n  snapshots bbs_article_snapshots[]\n\n  /// List of comments.\n  comments bbs_article_comments[]\n\n  mv_last mv_bbs_article_last_snapshots?\n\n  @@index([created_at])\n}\n\n/// Snapshot of article.\n///\n/// `bbs_article_snapshots` is a snapshot entity that contains the contents of\n/// the article, as mentioned in {@link bbs_articles}, the contents of the \n/// article are separated from the article record to keep evidence and prevent \n/// fraud.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel bbs_article_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belong article's {@link bbs_articles.id}\n  bbs_article_id String @db.Uuid\n\n  /// Format of body.\n  ///\n  /// Same meaning with extension like `html`, `md`, `txt`.\n  format String @db.VarChar\n\n  /// Title of article.\n  title String @db.VarChar\n\n  /// Content body of article.\n  body String\n\n  /// IP address of the snapshot writer.\n  ip String @db.VarChar\n\n  /// Creation time of record.\n  ///\n  /// It means creation time or update time or article.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  /// Belong article info.\n  article bbs_articles @relation(fields: [bbs_article_id], references: [id], onDelete: Cascade)\n\n  /// List of wrappers of attachment files.\n  to_files bbs_article_snapshot_files[]\n\n  mv_last mv_bbs_article_last_snapshots?\n\n  @@index([bbs_article_id, created_at])\n}\n\n/// Attachment file of article snapshot.\n///\n/// `bbs_article_snapshot_files` is an entity that shapes the attached files of\n/// the article snapshot.\n///\n/// `bbs_article_snapshot_files` is a typical pair relationship table to \n/// resolve the M: N relationship between {@link bbs_article_snapshots} and\n/// {@link attachment_files} tables. Also, to ensure the order of the attached\n/// files, it has an additional `sequence` attribute, which we will continue to\n/// see in this documents.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel bbs_article_snapshot_files {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged snapshot's {@link bbs_article_snapshots.id}\n  bbs_article_snapshot_id String @db.Uuid\n\n  /// Belonged file's {@link attachment_files.id}\n  attachment_file_id String @db.Uuid\n\n  /// Sequence of attachment file in the snapshot.\n  sequence Int @db.Integer\n\n  //----\n  // RELATIONS\n  //----\n  /// Belonged article.\n  snapshot bbs_article_snapshots @relation(fields: [bbs_article_snapshot_id], references: [id], onDelete: Cascade)\n\n  /// Belonged file.\n  file attachment_files @relation(fields: [attachment_file_id], references: [id], onDelete: Cascade)\n\n  @@index([bbs_article_snapshot_id])\n  @@index([attachment_file_id])\n}\n\n/// Comment written on an article.\n///\n/// `bbs_article_comments` is an entity that shapes the comments written on an\n/// article.\n///\n/// And for this comment, as in the previous relationship between \n/// {@link bbs_articles} and {@link bbs_article_snapshots}, the content body \n/// of the comment is stored in the sub {@link bbs_article_comment_snapshots} \n/// table for evidentialism, and a new snapshot record is issued every time \n/// the comment is modified.\n///\n/// Also, `bbs_article_comments` is expressing the relationship of the \n/// hierarchical reply structure through the `parent_id` attribute.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel bbs_article_comments {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged article's {@link bbs_articles.id}\n  bbs_article_id String @db.Uuid\n\n  /// Parent comment's {@link bbs_article_comments.id}\n  ///\n  /// Used to express the hierarchical reply structure.\n  parent_id String? @db.Uuid\n\n  /// Writer's name.\n  writer String @db.VarChar\n\n  /// Password for modification.\n  password String @db.VarChar\n\n  /// Creation time of comment.\n  created_at DateTime @db.Timestamptz\n\n  /// Deletion time of comment.\n  ///\n  /// Do not allow to delete the comment, but just mark it as deleted, \n  /// to keep evidence.\n  deleted_at DateTime? @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  /// Belonged article.\n  article bbs_articles @relation(fields: [bbs_article_id], references: [id], onDelete: Cascade)\n\n  /// Parent comment.\n  ///\n  /// Only when reply case.\n  parent bbs_article_comments? @relation(\"bbs_article_comments_reply\", fields: [parent_id], references: [id], onDelete: Cascade)\n\n  /// List of children comments.\n  ///\n  /// Reply comments of current.\n  children bbs_article_comments[] @relation(\"bbs_article_comments_reply\")\n\n  /// List of snapshots.\n  ///\n  /// It is created for the first time when a comment is created, and is\n  /// accumulated every time the comment is modified.\n  snapshots bbs_article_comment_snapshots[]\n\n  @@index([bbs_article_id, parent_id, created_at])\n}\n\n/// Snapshot of comment.\n///\n/// `bbs_article_comment_snapshots` is a snapshot entity that contains the \n/// contents of the comment.\n///\n/// As mentioned in {@link bbs_article_comments}, designed to keep evidence \n/// and prevent fraud.\n///\n/// @namespace Articles\n/// @author Samchon\nmodel bbs_article_comment_snapshots {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged article's {@link bbs_article_comments.id}\n  bbs_article_comment_id String @db.Uuid\n\n  /// Format of content body.\n  ///\n  /// Same meaning with extension like `html`, `md`, `txt`.\n  format String @db.VarChar\n\n  /// Content body of comment.\n  body String\n\n  /// IP address of the snapshot writer.\n  ip String @db.VarChar\n\n  /// Creation time of record.\n  ///\n  /// It means creation time or update time or comment.\n  created_at DateTime @db.Timestamptz\n\n  //----\n  // RELATIONS\n  //----\n  /// Belong comment info.\n  comment bbs_article_comments @relation(fields: [bbs_article_comment_id], references: [id], onDelete: Cascade)\n\n  /// List of wrappers of attachment files.\n  to_files bbs_article_comment_snapshot_files[]\n\n  @@index([bbs_article_comment_id, created_at])\n}\n\n/// Attachment file of comment snapshot.\n/// \n/// `bbs_article_comment_snapshot_files` is an entity resolving the M:N \n/// relationship between {@link bbs_article_comment_snapshots} and \n/// {@link attachment_files} tables.\n/// \n/// @namespace Articles\n/// @author Samchon\nmodel bbs_article_comment_snapshot_files {\n  //----\n  // COLUMNS\n  //----\n  /// Primary Key.\n  id String @id @db.Uuid\n\n  /// Belonged snapshot's {@link bbs_article_comment_snapshots.id}\n  bbs_article_comment_snapshot_id String @db.Uuid\n\n  /// Belonged file's {@link attachment_files.id}\n  attachment_file_id String @db.Uuid\n\n  /// Sequence order.\n  ///\n  /// Sequence order of the attached file in the belonged snapshot.\n  sequence Int @db.Integer\n\n  //----\n  // RELATIONS\n  //----\n  /// Belonged article.\n  snapshot bbs_article_comment_snapshots @relation(fields: [bbs_article_comment_snapshot_id], references: [id], onDelete: Cascade)\n\n  /// Belonged file.\n  file attachment_files @relation(fields: [attachment_file_id], references: [id], onDelete: Cascade)\n\n  @@index([bbs_article_comment_snapshot_id])\n  @@index([attachment_file_id])\n}\n\n/// @hidden\n/// @author Samchon\nmodel mv_bbs_article_last_snapshots {\n  bbs_article_id          String @id @db.Uuid\n  bbs_article_snapshot_id String @db.Uuid\n\n  article  bbs_articles          @relation(fields: [bbs_article_id], references: [id], onDelete: Cascade)\n  snapshot bbs_article_snapshots @relation(fields: [bbs_article_snapshot_id], references: [id], onDelete: Cascade)\n\n  @@unique([bbs_article_snapshot_id])\n}\n"
    },
    "document": "# Prisma Markdown\n\n> Generated by [`prisma-markdown`](https://github.com/samchon/prisma-markdown)\n\n- [Articles](#articles)\n\n## Articles\n\n```mermaid\nerDiagram\n\"attachment_files\" {\n  String id PK\n  String name\n  String extension \"nullable\"\n  String url\n  DateTime created_at\n}\n\"bbs_articles\" {\n  String id PK\n  String writer\n  String password\n  DateTime created_at\n  DateTime deleted_at \"nullable\"\n}\n\"bbs_article_snapshots\" {\n  String id PK\n  String bbs_article_id FK\n  String format\n  String title\n  String body\n  String ip\n  DateTime created_at\n}\n\"bbs_article_snapshot_files\" {\n  String id PK\n  String bbs_article_snapshot_id FK\n  String attachment_file_id FK\n  Int sequence\n}\n\"bbs_article_comments\" {\n  String id PK\n  String bbs_article_id FK\n  String parent_id FK \"nullable\"\n  String writer\n  String password\n  DateTime created_at\n  DateTime deleted_at \"nullable\"\n}\n\"bbs_article_comment_snapshots\" {\n  String id PK\n  String bbs_article_comment_id FK\n  String format\n  String body\n  String ip\n  DateTime created_at\n}\n\"bbs_article_comment_snapshot_files\" {\n  String id PK\n  String bbs_article_comment_snapshot_id FK\n  String attachment_file_id FK\n  Int sequence\n}\n\"bbs_article_snapshots\" }o--|| \"bbs_articles\" : article\n\"bbs_article_snapshot_files\" }o--|| \"bbs_article_snapshots\" : snapshot\n\"bbs_article_snapshot_files\" }o--|| \"attachment_files\" : file\n\"bbs_article_comments\" }o--|| \"bbs_articles\" : article\n\"bbs_article_comments\" }o--o| \"bbs_article_comments\" : parent\n\"bbs_article_comment_snapshots\" }o--|| \"bbs_article_comments\" : comment\n\"bbs_article_comment_snapshot_files\" }o--|| \"bbs_article_comment_snapshots\" : snapshot\n\"bbs_article_comment_snapshot_files\" }o--|| \"attachment_files\" : file\n```\n\n### `attachment_files`\n\nAttachment File.\n\nEvery attachment files that are managed in current system.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `name`: File name, except extension.\n- `extension`\n  > Extension.\n  >\n  > Possible to omit like `README` case.\n- `url`: URL path of the real file.\n- `created_at`: Creation time of file.\n\n### `bbs_articles`\n\nArticle entity.\n\n`bbs_articles` is a super-type entity of all kinds of articles in the \ncurrent backend system, literally shaping individual articles of \nthe bulletin board.\n\nAnd, as you can see, the elements that must inevitably exist in the \narticle, such as the title or the body, do not exist in the `bbs_articles`, \nbut exist in the subsidiary entity, [bbs_article_snapshots](#bbs_article_snapshots), as a \n1: N relationship, which is because a new snapshot record is published \nevery time the article is modified.\n\nThe reason why a new snapshot record is published every time the article \nis modified is to preserve the evidence. Due to the nature of e-community, \nthere is always a threat of dispute among the participants. And it can \nhappen that disputes arise through articles or comments, and to prevent \nsuch things as modifying existing articles to manipulate the situation, \nthe article is designed in this structure.\n\nIn other words, to keep evidence, and prevent fraud.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `writer`: Writer's name.\n- `password`: Password for modification.\n- `created_at`: Creation time of article.\n- `deleted_at`\n  > Deletion time of article.\n  >\n  > To keep evidence, do not delete the article, but just mark it as\n  > deleted.\n\n### `bbs_article_snapshots`\n\nSnapshot of article.\n\n`bbs_article_snapshots` is a snapshot entity that contains the contents of\nthe article, as mentioned in [bbs_articles](#bbs_articles), the contents of the \narticle are separated from the article record to keep evidence and prevent \nfraud.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `bbs_article_id`: Belong article's [bbs_articles.id](#bbs_articles)\n- `format`\n  > Format of body.\n  >\n  > Same meaning with extension like `html`, `md`, `txt`.\n- `title`: Title of article.\n- `body`: Content body of article.\n- `ip`: IP address of the snapshot writer.\n- `created_at`\n  > Creation time of record.\n  >\n  > It means creation time or update time or article.\n\n### `bbs_article_snapshot_files`\n\nAttachment file of article snapshot.\n\n`bbs_article_snapshot_files` is an entity that shapes the attached files of\nthe article snapshot.\n\n`bbs_article_snapshot_files` is a typical pair relationship table to \nresolve the M: N relationship between [bbs_article_snapshots](#bbs_article_snapshots) and\n[attachment_files](#attachment_files) tables. Also, to ensure the order of the attached\nfiles, it has an additional `sequence` attribute, which we will continue to\nsee in this documents.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `bbs_article_snapshot_id`: Belonged snapshot's [bbs_article_snapshots.id](#bbs_article_snapshots)\n- `attachment_file_id`: Belonged file's [attachment_files.id](#attachment_files)\n- `sequence`: Sequence of attachment file in the snapshot.\n\n### `bbs_article_comments`\n\nComment written on an article.\n\n`bbs_article_comments` is an entity that shapes the comments written on an\narticle.\n\nAnd for this comment, as in the previous relationship between \n[bbs_articles](#bbs_articles) and [bbs_article_snapshots](#bbs_article_snapshots), the content body \nof the comment is stored in the sub [bbs_article_comment_snapshots](#bbs_article_comment_snapshots) \ntable for evidentialism, and a new snapshot record is issued every time \nthe comment is modified.\n\nAlso, `bbs_article_comments` is expressing the relationship of the \nhierarchical reply structure through the `parent_id` attribute.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `bbs_article_id`: Belonged article's [bbs_articles.id](#bbs_articles)\n- `parent_id`\n  > Parent comment's [bbs_article_comments.id](#bbs_article_comments)\n  >\n  > Used to express the hierarchical reply structure.\n- `writer`: Writer's name.\n- `password`: Password for modification.\n- `created_at`: Creation time of comment.\n- `deleted_at`\n  > Deletion time of comment.\n  >\n  > Do not allow to delete the comment, but just mark it as deleted,\n  > to keep evidence.\n\n### `bbs_article_comment_snapshots`\n\nSnapshot of comment.\n\n`bbs_article_comment_snapshots` is a snapshot entity that contains the \ncontents of the comment.\n\nAs mentioned in [bbs_article_comments](#bbs_article_comments), designed to keep evidence \nand prevent fraud.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `bbs_article_comment_id`: Belonged article's [bbs_article_comments.id](#bbs_article_comments)\n- `format`\n  > Format of content body.\n  >\n  > Same meaning with extension like `html`, `md`, `txt`.\n- `body`: Content body of comment.\n- `ip`: IP address of the snapshot writer.\n- `created_at`\n  > Creation time of record.\n  >\n  > It means creation time or update time or comment.\n\n### `bbs_article_comment_snapshot_files`\n\nAttachment file of comment snapshot.\n\n`bbs_article_comment_snapshot_files` is an entity resolving the M:N \nrelationship between [bbs_article_comment_snapshots](#bbs_article_comment_snapshots) and \n[attachment_files](#attachment_files) tables.\n\nProperties as follows:\n\n- `id`: Primary Key.\n- `bbs_article_comment_snapshot_id`: Belonged snapshot's [bbs_article_comment_snapshots.id](#bbs_article_comment_snapshots)\n- `attachment_file_id`: Belonged file's [attachment_files.id](#attachment_files)\n- `sequence`\n  > Sequence order.\n  >\n  > Sequence order of the attached file in the belonged snapshot.\n",
    "diagrams": {
      "Articles": "```mermaid\nerDiagram\n\"attachment_files\" {\n  String id PK\n  String name\n  String extension \"nullable\"\n  String url\n  DateTime created_at\n}\n\"bbs_articles\" {\n  String id PK\n  String writer\n  String password\n  DateTime created_at\n  DateTime deleted_at \"nullable\"\n}\n\"bbs_article_snapshots\" {\n  String id PK\n  String bbs_article_id FK\n  String format\n  String title\n  String body\n  String ip\n  DateTime created_at\n}\n\"bbs_article_snapshot_files\" {\n  String id PK\n  String bbs_article_snapshot_id FK\n  String attachment_file_id FK\n  Int sequence\n}\n\"bbs_article_comments\" {\n  String id PK\n  String bbs_article_id FK\n  String parent_id FK \"nullable\"\n  String writer\n  String password\n  DateTime created_at\n  DateTime deleted_at \"nullable\"\n}\n\"bbs_article_comment_snapshots\" {\n  String id PK\n  String bbs_article_comment_id FK\n  String format\n  String body\n  String ip\n  DateTime created_at\n}\n\"bbs_article_comment_snapshot_files\" {\n  String id PK\n  String bbs_article_comment_snapshot_id FK\n  String attachment_file_id FK\n  Int sequence\n}\n\"bbs_article_snapshots\" }o--|| \"bbs_articles\" : article\n\"bbs_article_snapshot_files\" }o--|| \"bbs_article_snapshots\" : snapshot\n\"bbs_article_snapshot_files\" }o--|| \"attachment_files\" : file\n\"bbs_article_comments\" }o--|| \"bbs_articles\" : article\n\"bbs_article_comments\" }o--o| \"bbs_article_comments\" : parent\n\"bbs_article_comment_snapshots\" }o--|| \"bbs_article_comments\" : comment\n\"bbs_article_comment_snapshot_files\" }o--|| \"bbs_article_comment_snapshots\" : snapshot\n\"bbs_article_comment_snapshot_files\" }o--|| \"attachment_files\" : file\n```"
    },
    "step": 0,
    "created_at": "2025-05-23T12:19:06.900Z"
  },
  {
    "type": "interfaceEndpoints",
    "endpoints": [
      {
        "path": "/bbs/articles",
        "method": "patch"
      },
      {
        "path": "/bbs/articles",
        "method": "post"
      },
      {
        "path": "/bbs/articles/{id}",
        "method": "get"
      },
      {
        "path": "/bbs/articles/{id}",
        "method": "put"
      },
      {
        "path": "/bbs/articles/{id}",
        "method": "delete"
      },
      {
        "path": "/bbs/articles/snapshots",
        "method": "patch"
      },
      {
        "path": "/bbs/articles/snapshots/{id}",
        "method": "get"
      },
      {
        "path": "/bbs/articles/snapshots/{id}",
        "method": "put"
      },
      {
        "path": "/bbs/articles/snapshots/{id}",
        "method": "delete"
      },
      {
        "path": "/bbs/articles/{articleId}/comments",
        "method": "patch"
      },
      {
        "path": "/bbs/articles/{articleId}/comments",
        "method": "post"
      },
      {
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "get"
      },
      {
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "put"
      },
      {
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "delete"
      },
      {
        "path": "/bbs/articles/comments/snapshots",
        "method": "patch"
      },
      {
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "get"
      },
      {
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "put"
      },
      {
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "delete"
      },
      {
        "path": "/attachmentFiles",
        "method": "patch"
      },
      {
        "path": "/attachmentFiles",
        "method": "post"
      },
      {
        "path": "/attachmentFiles/{id}",
        "method": "get"
      },
      {
        "path": "/attachmentFiles/{id}",
        "method": "put"
      },
      {
        "path": "/attachmentFiles/{id}",
        "method": "delete"
      }
    ],
    "created_at": "2025-05-23T12:19:06.900Z",
    "step": 1
  },
  {
    "type": "interfaceOperations",
    "operations": [
      {
        "specification": "Update an existing comment entity under a specific article. Associated with the 'bbs_article_comments' table in the Prisma schema. The update operation is performed after password verification and requires the articleId and commentId as path parameters. The request body contains the fields that can be updated such as writer, password, and possible references for comment structure. On successful update, all linked fields and snapshot references will reflect the new details, and a new snapshot should be created in accordance with the evidence-preserving policy. Logical constraints include password validation, upholding the logical deletion pattern (no physical removal), and reference integrity for hierarchical nesting.",
        "description": "This API endpoint allows a user to update a specific comment in the bulletin board system while maintaining a snapshot of the modification for evidence. The operation is secured by requiring the correct password for comment modification, as dictated by the system's security policy. On execution, a new snapshot will be generated, storing the old version and the modifying client's IP address, as per the evidential design. Only non-deleted comments are modifiable; comments previously soft-deleted (deleted_at set) will be rejected.\n\nValidation rules enforce existence of the referenced article and comment, correct hierarchical relationships for nested replies, required fields, and adherence to data consistency regarding attachments and format. The operation also ensures that password hashes are compared and never exposed in the API, supporting encrypted password storage.\n\nThis endpoint is related to: GET /bbs/articles/{articleId}/comments/{id} (fetch detail), POST /bbs/articles/{articleId}/comments (creation), and DELETE /bbs/articles/{articleId}/comments/{id} (logical deletion). Error responses include unauthorized modification, resource not found, and input validation failures.",
        "summary": "Update existing comment information in 'bbs_article_comments' for a given article and comment.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Updated data for the comment. Requires writer and password for authentication, and allows update of body/content fields.",
          "typeName": "IBbsArticleComment.IUpdate"
        },
        "responseBody": {
          "description": "Updated comment info with latest snapshot reference.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "put"
      },
      {
        "specification": "Logically delete a specific comment from an article while preserving evidence, linked with the 'bbs_article_comments' entity in the database. The operation does not actually remove the comment but sets 'deleted_at' timestamp, excluding it from standard queries except for administrative viewing. A password check ensures only authorized users can logically delete. Related comment snapshots remain untouched to guarantee revision traceability for possible disputes.",
        "description": "This endpoint marks a specified comment under a particular article as deleted (soft delete). In accordance with the requirements, the comment is not physically removed, but its 'deleted_at' field is set to the current timestamp. If the supplied password does not match or the comment is already deleted, an error is returned. All historical snapshots for the comment are preserved, ensuring the full audit log needed for dispute resolution.\n\nThe endpoint performs validation for the existence of both the article and comment, ensures correct authorization (password validation), and returns the final comment record reflecting the logical deletion. This supports system requirements for evidence retention and access control for administrators.",
        "summary": "Logically delete a comment (set deleted_at) in 'bbs_article_comments' for a given article and comment ID.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Target article's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Target comment's ID",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Password required for logical deletion/authentication.",
          "typeName": "IBbsArticleComment.IDelete"
        },
        "responseBody": {
          "description": "Comment info after logical deletion (deleted_at set).",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "delete"
      },
      {
        "specification": "List snapshot records (historical versions) for all comments across articles. Associated with the 'bbs_article_comment_snapshots' table. This patch search endpoint supports filtering, pagination, and sorting criteria to efficiently retrieve multiple comment snapshot records based on attributes such as commentId, format, creation date, or IP address as required for audit, evidence, or administrative review.",
        "description": "This API operation retrieves a filtered and/or paginated list of comment snapshot records, representing the edit histories for comments. It serves both evidence management (viewing revision history) and administrative oversight (monitoring modifications and IP addresses). Supports filters for attributes such as comment ID(s), date range, format, or other metadata.\n\nThe endpoint enables clients to efficiently perform evidence review, discover all edits for a given comment or set of comments, and optionally aggregate statistics or metadata as needed. Error handling includes invalid filter criteria, pagination issues, or lack of results for the requested conditions.",
        "summary": "Retrieve a paginated list of comment snapshot records from 'bbs_article_comment_snapshots'.",
        "parameters": [],
        "requestBody": {
          "description": "Filtering and pagination parameters for searching comment snapshots.",
          "typeName": "IBbsArticleCommentSnapshot.IRequest"
        },
        "responseBody": {
          "description": "Paginated result of comment snapshot entities with filtering info.",
          "typeName": "IPageIBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/comments/snapshots",
        "method": "patch"
      },
      {
        "specification": "Retrieve a specific comment snapshot entity by its unique identifier. Associated with the 'bbs_article_comment_snapshots' table, this GET operation obtains all evidential data about a particular version, for audit, user, or admin reference. Returns both the snapshot meta and, where applicable, related attachment metadata.",
        "description": "This endpoint fetches detailed information about a single comment snapshot, uniquely identified by its ID. It exposes all evidential attributes: body, format, creation time, IP address of the modifier, and linkage to its comment and parent article.\n\nIntended for history management screens or audit review, it supports full details, including attached file metadata, and can be used to display previous comment versions or investigate disputes. Related endpoints are PATCH /bbs/articles/comments/snapshots (for list/search) and PUT /bbs/articles/comments/snapshots/{id} (for administrative corrections, if permitted). Error handling includes resource not found, or access denied if applicable.",
        "summary": "Fetch detail information for a single comment snapshot by ID from 'bbs_article_comment_snapshots'.",
        "parameters": [
          {
            "name": "id",
            "description": "Target comment snapshot's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "The full information for a given comment snapshot, including content, meta, and file links.",
          "typeName": "IBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "get"
      },
      {
        "specification": "Update administrative or evidential attributes of a specific comment snapshot. Associated with 'bbs_article_comment_snapshots', this endpoint allows precise modifications (e.g., corrections, administrative annotations) while preserving audit trails. Typically reserved for admin use as post-creation edits to snapshot content are generally prohibited by standard users in evidence-preserving systems.",
        "description": "This endpoint permits authorized administrative actors to update certain attributes of a comment snapshot, such as correcting metadata errors or annotating revisions, without breaking the snapshot audit chain. Input validation ensures that evidence integrity is not violated (for example, core content cannot be retroactively altered by general users). The endpoint is intended for corrective or special administrative functions.\n\nSecurity is enforced by access control: only privileged accounts may utilize this endpoint, and attempted use by general users will result in authorization errors. Error handling includes not found, insufficient rights, and input validation failures. Related operations include GET /bbs/articles/comments/snapshots/{id} (for reading) and PATCH /bbs/articles/comments/snapshots (for search/listing).",
        "summary": "Update specific snapshot attributes in 'bbs_article_comment_snapshots', primarily for admin use.",
        "parameters": [
          {
            "name": "id",
            "description": "Target comment snapshot's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Fields for administrative update of the snapshot. Restricted to allowable attributes only.",
          "typeName": "IBbsArticleCommentSnapshot.IUpdate"
        },
        "responseBody": {
          "description": "Updated comment snapshot info with admin/meta corrections applied.",
          "typeName": "IBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "put"
      },
      {
        "specification": "Logically delete a specific comment snapshot for evidence maintenance or administrative purposes. Linked with the 'bbs_article_comment_snapshots' table. The operation will typically soft-delete (set a deleted indicator or flag) and does not physically remove the record; this maintains auditability and regulatory compliance. Security policy prevents general users from using this endpoint; for admin-only deletion operations.",
        "description": "This endpoint marks a comment snapshot as deleted (usually via a logical delete flag or 'deleted_at' timestamp, in line with the overall evidence preservation policy). Physical deletion from the database is forbidden; the operation is reserved for administrators or regulatory compliance requirements only. Related files and linkages remain for audit traceability.\n\nAttempts to use this endpoint without sufficient privilege are denied. Related endpoints include GET /bbs/articles/comments/snapshots/{id} (for reading), PUT /bbs/articles/comments/snapshots/{id} (for administrative update), and DELETE /bbs/articles/comments/snapshots/{id} for logical removal. Error responses occur for not found, insufficient rights, and policy violations.",
        "summary": "Logically delete a comment snapshot in 'bbs_article_comment_snapshots' by ID, for admin use only.",
        "parameters": [
          {
            "name": "id",
            "description": "Target comment snapshot's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Administrative request to logically delete the given comment snapshot. Only privileged users allowed.",
          "typeName": "IBbsArticleCommentSnapshot.IDelete"
        },
        "responseBody": {
          "description": "The logically deleted comment snapshot info, with deletion meta/flag set.",
          "typeName": "IBbsArticleCommentSnapshot"
        },
        "path": "/bbs/articles/comments/snapshots/{id}",
        "method": "delete"
      },
      {
        "specification": "Retrieve a paginated, filterable list of attachment file entities as stored in the 'attachment_files' table. The endpoint should support common query parameters such as file name, extension, or creation date, and return both file metadata and usage context as needed.",
        "description": "This API operation returns a list of all attachment files stored within the system, with optional filters for name, extension, and creation date. Its main use cases involve browsing available files, administratively locating uploaded materials, and supplying metadata for attachment management operations (e.g., linking files to post/comment snapshots).\n\nResults support pagination, sorting, and advanced search conditions. Error handling ensures proper response to invalid search parameters and out-of-bounds pagination values.",
        "summary": "Get a paginated/searchable list of attachment files from 'attachment_files'.",
        "parameters": [],
        "requestBody": {
          "description": "Filtering and pagination options for searching attachment files.",
          "typeName": "IAttachmentFile.IRequest"
        },
        "responseBody": {
          "description": "Paginated, filtered list of matching attachment file entities.",
          "typeName": "IPageIAttachmentFile"
        },
        "path": "/attachmentFiles",
        "method": "patch"
      },
      {
        "specification": "Create a new attachment file entity within the 'attachment_files' table. The file is first uploaded (to storage or CDN), then its metadata and reference (URL, filename, extension, etc.) are recorded in the database. On success, the file becomes available for linking to article or comment snapshots. Requires all core fields, including storage location (url).",
        "description": "This endpoint registers a new file after upload by inserting its key metadata into the 'attachment_files' schema table. It records the file name, extension (if any), URL, and the creation date. Input validation ensures file name and URL are present, extension is allowed or nullable, and that no collisions occur for unique IDs. File upload should be processed prior to this call, which is only for metadata registration and not for the binary upload process itself.\n\nThe endpoint is often called by UI file upload interfaces before associating the file with posts/comments. Errors may include invalid input, file type restrictions, or unique constraint violations on file ID.",
        "summary": "Register a new attachment file in 'attachment_files' with all required metadata.",
        "parameters": [],
        "requestBody": {
          "description": "Attachment file registration information (metadata only, upload handled separately).",
          "typeName": "IAttachmentFile.ICreate"
        },
        "responseBody": {
          "description": "Attachment file metadata referencing the stored/uploaded file.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles",
        "method": "post"
      },
      {
        "specification": "Retrieve information for a specific attachment file from the 'attachment_files' table. This endpoint returns all file metadata including usage context if available. Used for management, UI preview, and integrity checking. Supports administrative and user contexts.",
        "description": "This API operation fetches the details of an individual attachment file by its unique ID. It returns all metadata (name, extension, URL, creation time), and can include cross-references to snapshots where used. Used in file management screens, attachment UI, or for audit purposes.\n\nThe endpoint validates the existence of the requested file and returns an informative error if not found. Related endpoints include PATCH /attachmentFiles (for listing) and DELETE /attachmentFiles/{id} (for deletion).",
        "summary": "Fetch information for a single attachment file by ID from 'attachment_files'.",
        "parameters": [
          {
            "name": "id",
            "description": "Target attachment file's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Complete metadata for the requested attachment file.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles/{id}",
        "method": "get"
      },
      {
        "specification": "Update metadata for an existing attachment file in 'attachment_files'. Use to rename, correct extensions, or alter usage notes. Modifications are restricted to admin users, ensuring integrity of references and system consistency. Prevents orphaning files still in use or breaking links from snapshots.",
        "description": "This endpoint updates fields such as the filename, extension, or other attributes for an attachment file already present in the database. Authorization is required (typically admin-level) to prevent accidental or malicious alteration of shared files. Validation ensures referential integrity with linked snapshots and prevents breaking links. Only fields allowed for update by business logic can be altered; changes to URL or creation dates may be restricted.\n\nError handling addresses non-existent files, permission errors, and attempts to update disallowed fields. Related endpoints: GET /attachmentFiles/{id} (for reading), PATCH /attachmentFiles (for listing), and DELETE /attachmentFiles/{id} (for deletion).",
        "summary": "Update metadata of an attachment file in 'attachment_files' (admin only).",
        "parameters": [
          {
            "name": "id",
            "description": "Target attachment file's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Fields for updating information about the attachment file.",
          "typeName": "IAttachmentFile.IUpdate"
        },
        "responseBody": {
          "description": "Updated metadata of the attachment file entity.",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles/{id}",
        "method": "put"
      },
      {
        "specification": "Logically delete an attachment file in 'attachment_files' by ID. The file metadata and record are preserved for audit, and actual deletion from storage is handled separately if allowed. Prevents removing files in use by posts or comments.",
        "description": "This endpoint marks an attachment file as logically deleted (typically by setting a flag or deletion timestamp) to preserve auditability and avoid removing files that may still be linked from evidence snapshots. Actual file removal from storage, if any, is beyond the scope of this endpoint. Authorization is enforced for only privileged users (like admins) to use this endpoint.\n\nBefore deletion, the system checks that the file is not referenced by any snapshots to prevent orphaning or evidence loss. Any deletion attempt for files still in use results in an error. Related endpoints: PUT /attachmentFiles/{id} (for update) and GET /attachmentFiles/{id} (for reading).",
        "summary": "Logically delete an attachment file by ID in 'attachment_files' (admin only, prevents deletion if referenced).",
        "parameters": [
          {
            "name": "id",
            "description": "Target attachment file's ID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Logical deletion request for attachment file, with admin authorization.",
          "typeName": "IAttachmentFile.IDelete"
        },
        "responseBody": {
          "description": "Attachment file entity after logical deletion (flag set or deleted).",
          "typeName": "IAttachmentFile"
        },
        "path": "/attachmentFiles/{id}",
        "method": "delete"
      }
    ],
    "completed": 11,
    "total": 23,
    "step": 1,
    "created_at": "2025-05-23T12:20:25.340Z"
  },
  {
    "type": "interfaceOperations",
    "operations": [
      {
        "specification": "List articles with filtering, searching, and pagination. Associated with the bbs_articles table. Should return summary information including linked last snapshot and basic info.",
        "description": "This API endpoint allows clients to retrieve a paginated, filtered, and/or sorted list of bulletin board articles. It references the bbs_articles table in Prisma, which holds basic post identity and author information, as well as deletion markers. Results typically include only non-deleted articles for general users (unless special admin permission is given). \n\nEach article summary should include the latest title (from the latest snapshot), author, creation time, and comment count. Filters may include search by title, author, date ranges, and possibly presence of comments. The endpoint should work efficiently by leveraging indexes on created_at and deleted_at for best performance. Soft-deleted posts are omitted except for admin access.\n\nRequest parameters support pagination with cursor/limit or offset/limit. Security: Access to deleted articles may depend on user role; listing of all (including deleted) may require admin level. Related API operation: GET /bbs/articles/{id} for detailed information. Errors for invalid search parameters, forbidden access, or server errors follow consistent patterns.",
        "summary": "List articles from bbs_articles with searching, pagination, and summary info.",
        "parameters": [],
        "requestBody": {
          "description": "Request parameters for listing articles, including filters (title, author, date), pagination (cursor/limit or offset/limit), and sorting options.",
          "typeName": "IBbsArticle.IRequest"
        },
        "responseBody": {
          "description": "Paged result containing articles' summary information, latest snapshot info, and comment counts.",
          "typeName": "IPageIBbsArticle.ISummary"
        },
        "path": "/bbs/articles",
        "method": "patch"
      },
      {
        "specification": "Create a new article. Associated with the bbs_articles and bbs_article_snapshots tables. Requires author, password, initial title/body, and can include files.",
        "description": "This endpoint allows a user to create a new bulletin board article. Upon invocation, a new record in bbs_articles is inserted, as well as a first snapshot in bbs_article_snapshots, containing the initial version's body, format, title, and IP address of the request. Attachments may also be uploaded and associated via attachment_files and bbs_article_snapshot_files junction.\n\nThe author provides a writer name, password (which must be encrypted before storage), and content (title, body, format). An array of file metadata may also be included. This route enforces presence of all required fields and validates file upload if present.\n\nSecurity: Password is stored only as a hash; plaintext password must not be stored. All significant actions (including IP address capture) must be logged and linked to the snapshot. Failure scenarios include missing/invalid required fields, unsupported file types, or database errors. Related: Modification is handled via PUT /bbs/articles/{id}; version retrieval by PATCH /bbs/articles/snapshots.",
        "summary": "Create a bulletin board article (bbs_articles + initial snapshot, with attachments).",
        "parameters": [],
        "requestBody": {
          "description": "New article creation info including writer, password, initial title and body, format, and optional file attachments.",
          "typeName": "IBbsArticle.ICreate"
        },
        "responseBody": {
          "description": "Created article info, including references to its first snapshot and any attachments.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles",
        "method": "post"
      },
      {
        "specification": "Get a single article's full details, including latest snapshot and all metadata. Associated with bbs_articles and bbs_article_snapshots tables.",
        "description": "This endpoint retrieves all information required for a specific article, given its unique id (UUID). It uses the bbs_articles table to obtain author, creation time, and status (deleted or not). The latest version is provided by linking to the most recent bbs_article_snapshots record, including title, body, and format. Attachments related to the latest snapshot are also returned.\n\nIf the article is soft-deleted, its access may be restricted to admin-level or special permission users. IP information may be redacted for standard users to enhance privacy. The endpoint returns an error if the id is invalid or the article does not exist. This operation does not modify the database and is considered safe for client retrieval.\n\nRelated API: PATCH /bbs/articles for the listing. Errors adhere to the API's standard error response structure.",
        "summary": "Get detail on a single article (bbs_articles & latest snapshot, attachments, safe info).",
        "parameters": [
          {
            "name": "id",
            "description": "The article's unique identifier (UUID).",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "All detail about the article, including metadata, current snapshot, and attachment files.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "get"
      },
      {
        "specification": "Update an article by creating a new snapshot/version. Associated with bbs_articles (for permission) and bbs_article_snapshots for versioning. Authors need to verify password.",
        "description": "This endpoint enables the modification of a previously created article. Modifications do not overwrite existing articles but result in a new record in bbs_article_snapshots linked to the same article. It enforces password verification against the article's hashed password before proceeding. Authors can change the title, body, body format, and update attachments through this operation.\n\nThe endpoint requires the article id, the writer's password (to be verified), and the new content. Attachments can be modified (added, removed, reordered) by specifying their metadata. If the password is invalid or missing, the operation fails with an appropriate error. Only non-deleted articles can be modified unless special permissions are given.\n\nSecurity: Store IP address and record the modification time. Existing snapshots remain immutable to preserve evidence/history. Updates to associated attachments create new junction entries for the new snapshot. Related API: GET /bbs/articles/{id} to fetch new version, PATCH /bbs/articles/snapshots to list all versions. All error and success responses follow universal API schema.",
        "summary": "Modify an article (bbs_articles): add snapshot and optionally modify attachments.",
        "parameters": [
          {
            "name": "id",
            "description": "Article's unique identifier (UUID) to update.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Update info for an article, including new title/body/format, re-attachment info, and password verification.",
          "typeName": "IBbsArticle.IUpdate"
        },
        "responseBody": {
          "description": "Article info and the newly created snapshot (representing the update), with attachments.",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "put"
      },
      {
        "specification": "Soft-delete an article (logical deletion). Mark deleted_at and do not actually remove. Associated with bbs_articles.",
        "description": "This endpoint is for logically deleting an existing bulletin board article. It only marks the deleted_at field with the current timestamp, preserving the record for evidence and possible future administrative review. The request must include password verification for standard users; admin users may delete without password depending on config/policy. If the password is invalid or missing, the deletion will fail.\n\nLogically deleted articles are not shown in public lists but are still accessible for admin/forensic reasons. Physical deletion is never performed to maintain history. Errors are returned if the article is not found, already deleted, or password is incorrect. The operation records who (user, IP) deleted the item.",
        "summary": "Soft-delete (logical delete) a bulletin board article. Only marks deleted_at, no physical removal.",
        "parameters": [
          {
            "name": "id",
            "description": "Article's unique identifier (UUID) to soft-delete.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Password for soft-deletion verification if not admin. Admins may bypass password check.",
          "typeName": "IBbsArticle.IDelete"
        },
        "responseBody": {
          "description": "Confirmation, updated article info (with deleted_at time set).",
          "typeName": "IBbsArticle"
        },
        "path": "/bbs/articles/{id}",
        "method": "delete"
      },
      {
        "specification": "List all article snapshots (versions/history) with searching and pagination. Associated with bbs_article_snapshots table and referencing bbs_articles.",
        "description": "This endpoint provides a paginated, filterable, and sortable list of all article snapshots (historical versions), from the bbs_article_snapshots Prisma table. Clients can use this to access the full modification history for articles. \n\nSearch/explore versions by article id, creation time, writer IP, format, or keywords in title/body; efficient index access is required for performance. Pagination parameters are mandatory for scalability with growing history. Deleted articles' snapshots may be accessible to admins only. For standard users, only versions for non-deleted articles are returned. Snapshots include all version metadata (format, title, body, created_at, IP) and attachment references.\n\nRelated API: PATCH /bbs/articles for article overviews, GET /bbs/articles/snapshots/{id} for version detail.",
        "summary": "List (paged) article snapshots from bbs_article_snapshots, filter by article id, etc.",
        "parameters": [],
        "requestBody": {
          "description": "Snapshot search parameters: filters for article id, date ranges, IP, body/title keywords; plus pagination info.",
          "typeName": "IBbsArticleSnapshot.IRequest"
        },
        "responseBody": {
          "description": "Paged result of article snapshots with metadata and attachment summaries.",
          "typeName": "IPageIBbsArticleSnapshot.ISummary"
        },
        "path": "/bbs/articles/snapshots",
        "method": "patch"
      },
      {
        "specification": "Get snapshot details for a specific article version. Associated with bbs_article_snapshots table and references attachments/metadata.",
        "description": "This operation returns the full metadata for a specified article snapshot (by UUID), including all version metadata (title, body, format, created_at, IP address) and linked attachment file info. It is typically used to view historical versions of an article for evidence or audit purposes.\n\nAppropriate authorization may be required if the snapshot is for an article that has been deleted or is restricted. Errors are returned for non-existent IDs or unauthorized access. IP addresses may only be visible to admins. No modification of state occurs here.\n\nSecurity: Carefully audit access to preserve privacy. Related: POST/PATCH to list versions, parent article access via GET /bbs/articles/{id}. Error responses standardized.",
        "summary": "Get details of one article snapshot (version), including all metadata and its attachments.",
        "parameters": [
          {
            "name": "id",
            "description": "Snapshot's unique identifier (UUID).",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Snapshot detail including metadata and attachments.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/snapshots/{id}",
        "method": "get"
      },
      {
        "specification": "Update an article snapshot (possibly only for admin, audit fix, or metadata tagging). bbs_article_snapshots table.",
        "description": "This admin-facing endpoint (rarely exposed to end-users) allows for partial updates (e.g., tagging or meta-corrections) to a specific snapshot record, identified by its UUID. Typical users will not modify snapshots (snapshots are append-only); this is for exceptional forensic or administrative cases.\n\nPermitted updates may include internal metadata such as status tagging or moderation flags, but NOT revision of original title/body/IP, to preserve evidence. Access strictly controlled; all actions audited. Operation rejected if forbidden fields are attempted to be changed or user is unauthorized. Related: GET /bbs/articles/snapshots/{id} for version details.",
        "summary": "Modify snapshot record's metadata (admin/forensic use only), not the actual version content.",
        "parameters": [
          {
            "name": "id",
            "description": "Snapshot's UUID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Patch request for allowed snapshot metadata fields (typ. tagging/status/mod notes).",
          "typeName": "IBbsArticleSnapshot.IUpdate"
        },
        "responseBody": {
          "description": "Snapshot record with updated metadata.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/snapshots/{id}",
        "method": "put"
      },
      {
        "specification": "Delete an article snapshot (admin/forensic use only). Physically removes a version. bbs_article_snapshots table.",
        "description": "This highly restricted endpoint allows physical deletion of a single article snapshot by its UUID. Typically, this would only be permitted in cases of evidence tampering, privacy requests, or system maintenance. Regular users have no access.\n\nThe operation removes the historical version and updates all connected records accordingly. Audit logs should capture all deletions. Invalid/dependent snapshot deletion attempts result in errors. Recognize that removing a snapshot could compromise historical integrity, so authorization and safety nets must be ensured. Related: GET for details, PATCH for list.",
        "summary": "Permanently delete an article snapshot (admin maintenance/correction use), not for public users.",
        "parameters": [
          {
            "name": "id",
            "description": "Snapshot's UUID.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Confirmation/metadata of deleted snapshot, or empty response.",
          "typeName": "IBbsArticleSnapshot"
        },
        "path": "/bbs/articles/snapshots/{id}",
        "method": "delete"
      },
      {
        "specification": "List comments for an article. Paginated, sorted, optionally filtered. bbs_article_comments, bbs_article_comment_snapshots, and tree structure.",
        "description": "This endpoint provides retrieval of a hierarchical, paginated, and searchable/commentable list of comments related to a particular article. Queries bbs_article_comments table for all comments (excluding deleted unless admin), joined with their latest snapshot record for current body/display (from bbs_article_comment_snapshots). Supports threaded replies with unlimited depth via parent_id.\n\nFilters include parent_id (for fetching root comments or replies), writer name, creation time, and support for pagination for large inputs. By default, only non-deleted comments are returned. Role-based logic may allow access to deleted comments for admins. Sorting can include time or hierarchy order.\n\nEfficient tree retrieval is required for good performance with nesting. Related endpoints: POST for new comment; GET /bbs/articles/{articleId}/comments/{id} for comment detail.",
        "summary": "Get a paginated and hierarchical list of comments for an article, showing current body.",
        "parameters": [
          {
            "name": "articleId",
            "description": "Article UUID for which to fetch comments.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "Comment list request parameters: pagination, optional parent_id for segment, or search filters.",
          "typeName": "IBbsArticleComment.IRequest"
        },
        "responseBody": {
          "description": "Paged list/hierarchy of comments with metadata and their latest version body, excludes deleted unless admin.",
          "typeName": "IPageIBbsArticleComment.ISummary"
        },
        "path": "/bbs/articles/{articleId}/comments",
        "method": "patch"
      },
      {
        "specification": "Create a new comment for an article. bbs_article_comments, bbs_article_comment_snapshots. Associate with optional parent for replies and with attachments.",
        "description": "Enables the creation of a new comment (reply or root) on a specific article, specified by articleId. A record is inserted into bbs_article_comments along with a corresponding first snapshot in bbs_article_comment_snapshots (body, format, IP). This supports direct comments or reply chains by specifying parent_id in the body (for nested comments).\n\nComment must include writer, password (stored securely via hash), body, format, and can optionally reference files. Enforces required fields, validates permissions, checks nesting rules. Upon creation, the first snapshot is linked and metadata set. Logical deletion applies for future removal, not on creation.\n\nSecurity: All actions (IP, times) are audited; sensitive data such as passwords are hashed before storage. Failure triggers: missing/invalid params, wrong parent/article ID, DB errors. Related: PATCH for comment list; GET for comment details.",
        "summary": "Create a new comment or reply to an article, supporting nesting and attachments. Snapshots required for history.",
        "parameters": [
          {
            "name": "articleId",
            "description": "UUID of the article to comment on.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": {
          "description": "New comment info: writer, password, body, format, parent_id (for reply), optional attachments.",
          "typeName": "IBbsArticleComment.ICreate"
        },
        "responseBody": {
          "description": "Newly created comment (and its first snapshot) with metadata, body, and attachments.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments",
        "method": "post"
      },
      {
        "specification": "Get the details (body, author, indexes, replies) of a specific comment, including its latest snapshot content and attachments. bbs_article_comments, bbs_article_comment_snapshots.",
        "description": "This endpoint fetches the full details for a single comment on a given article. Accepts the articleId for context and the comment's uuid as id. Joins the bbs_article_comments table (for metadata, writer, deletion status) with latest snapshot (from bbs_article_comment_snapshots) for body/format. Also fetches attachment info for the snapshot.\n\nDetails include: creation and (if) deletion timestamps, author, format, body, all attachments for the most recent version, parent/child info for replies, and optional list of immediate child comment IDs (to facilitate threaded UIs). Deleted comments are shown only with special permission (admin). If not found or not permitted, appropriate error returns.\n\nRelated: PATCH for listing, POST for creation. Error codes are standardized across comment operations.",
        "summary": "Get full details (including snapshot, attachments, and hierarchy) for one comment on an article.",
        "parameters": [
          {
            "name": "articleId",
            "description": "The article UUID where the comment belongs.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          },
          {
            "name": "id",
            "description": "Comment's UUID to consult.",
            "schema": {
              "type": "string",
              "format": "uuid"
            }
          }
        ],
        "requestBody": null,
        "responseBody": {
          "description": "Comment detail with latest version body/format, metadata, and all attachments.",
          "typeName": "IBbsArticleComment"
        },
        "path": "/bbs/articles/{articleId}/comments/{id}",
        "method": "get"
      }
    ],
    "completed": 23,
    "total": 23,
    "step": 1,
    "created_at": "2025-05-23T12:21:17.867Z"
  },
  {
    "type": "interfaceComponents",
    "components": {
      "schemas": {
        "IBbsArticleCommentSnapshot": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the comment snapshot.\n\nCorresponds to Prisma: `id` column. Primary Key."
            },
            "bbs_article_comment_id": {
              "type": "string",
              "format": "uuid",
              "description": "Reference to the parent comment this snapshot belongs to.\n\nPrisma: `bbs_article_comment_id`. Foreign Key referencing `bbs_article_comments.id`."
            },
            "format": {
              "type": "string",
              "description": "Format of the comment body. For example, 'html', 'md', 'txt'.\n\nMaps to Prisma: `format` column."
            },
            "body": {
              "type": "string",
              "description": "The actual content of the comment for this snapshot. Full bodies are preserved unmodified.\n\nPrisma: `body` column."
            },
            "ip": {
              "type": "string",
              "description": "IP address of the author/modifier for this snapshot. Used for fraud prevention and evidence.\n\nPrisma: `ip` column."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp (ISO8601) indicating when this version (snapshot) was created.\n\nCorresponds to: `created_at` column in Prisma."
            },
            "attachments": {
              "type": "array",
              "description": "List of attached files for this snapshot, with their sequence preserved.\n\nDerived from attachment M:N relations. Each item references `IAttachmentFile` with its own sequence.",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshot.IAttachment"
              }
            }
          },
          "required": [
            "id",
            "bbs_article_comment_id",
            "format",
            "body",
            "ip",
            "created_at"
          ],
          "description": "Snapshot entity containing revision information for a comment, preserving evidence for all edits or modifications.\n\nThis schema reflects the `bbs_article_comment_snapshots` table, storing all state for each modification, including content, format, timestamps, author IP, and attachments. Maintains historical records for compliance and dispute prevention."
        },
        "IBbsArticleCommentSnapshot.IAttachment": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the attached file in this snapshot."
            },
            "attachment_file_id": {
              "type": "string",
              "format": "uuid",
              "description": "ID reference of the attached file. Relates to `attachment_files.id`."
            },
            "sequence": {
              "type": "integer",
              "description": "Order of the attachment in the snapshot's attachment list.\n\nPrisma: `sequence` column."
            },
            "file": {
              "$ref": "#/components/schemas/IAttachmentFile",
              "description": "Metadata for the attachment file itself."
            }
          },
          "required": [
            "id",
            "attachment_file_id",
            "sequence",
            "file"
          ],
          "description": "Describes an attached file as linked through a comment snapshot, including metadata and sequence order.\n\nMaps to the join table in Prisma and composed for snapshot context."
        },
        "IBbsArticleCommentSnapshot.IUpdate": {
          "type": "object",
          "properties": {
            "meta_status": {
              "type": "string",
              "description": "Administrative or moderation status label for this snapshot, e.g., 'normal', 'flagged', 'corrected'. Not an original post field."
            },
            "admin_note": {
              "type": "string",
              "description": "Free-form admin/moderator note for audit/tagging purposes."
            }
          },
          "required": [],
          "description": "Update parameters for allowed snapshot attributes (typically admin-only correction/annotation fields).\n\nContents subject to access restrictions and do not alter evidential snapshot content like body or IP."
        },
        "IBbsArticleCommentSnapshot.IDelete": {
          "type": "object",
          "properties": {
            "reason": {
              "type": "string",
              "description": "Optional reason or case label for logical deletion, used in admin audit context."
            }
          },
          "required": [],
          "description": "Administrative request to logically delete a comment snapshot. Used only by privileged users to maintain evidential integrity."
        },
        "IAttachmentFile.IRequest": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "(Optional) Filter for the file name (not extension)."
            },
            "extension": {
              "type": "string",
              "description": "(Optional) Filter for file extension."
            },
            "created_from": {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Fetch attachment files created from this date/time (inclusive)."
            },
            "created_to": {
              "type": "string",
              "format": "date-time",
              "description": "(Optional) Fetch attachment files created up to this date/time (inclusive)."
            },
            "page": {
              "type": "integer",
              "description": "The page number to retrieve for paginated results (optional).\n\nSee IPage.IRequest."
            },
            "limit": {
              "type": "integer",
              "description": "Records per page to retrieve for paginated results (optional, default may be 100).\n\nSee IPage.IRequest."
            }
          },
          "required": [],
          "description": "Filtering and pagination query for searching attachment files.\n\nCombines optional name/extension filters and time-based constraints. Maps to Prisma query parameters and aligns with frontend search forms."
        },
        "IPageIAttachmentFile": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination",
              "description": "Pagination metadata, including page info and total records."
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IAttachmentFile"
              },
              "description": "List of attachment file entities for this page of results."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated container of attachment file records, with page metadata and current result set. Adheres to IPage<T> standard pattern in all API paginated returns."
        },
        "IAttachmentFile.ICreate": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the attachment file (if pre-specified or generated before upload)."
            },
            "name": {
              "type": "string",
              "description": "Name of the file (not including extension). Prisma column: name."
            },
            "extension": {
              "type": "string",
              "description": "File extension, e.g., 'jpg', 'pdf'. May be null or blank for extensionless files."
            },
            "url": {
              "type": "string",
              "description": "URL or storage path where the file is accessible by clients. Prisma: url."
            }
          },
          "required": [
            "name",
            "url"
          ],
          "description": "Payload for registering a new file attachment entity.\n\nCovers all required fields for new file metadata except automatically-generated fields such as creation time."
        },
        "IAttachmentFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the attachment file. Prisma column: id."
            },
            "name": {
              "type": "string",
              "description": "Filename without extension (original name)."
            },
            "extension": {
              "type": "string",
              "description": "File extension, e.g., 'png', 'pdf'. May be blank or null."
            },
            "url": {
              "type": "string",
              "description": "URL (complete path) where this file can be downloaded or viewed. Prisma: url."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the file record was created (ISO 8601). Prisma: created_at."
            }
          },
          "required": [
            "id",
            "name",
            "url",
            "created_at"
          ],
          "description": "Attachment file overview record. Reflects the `attachment_files` Prisma schema for representing files uploaded, with storage info and provenance. Used anywhere file metadata and references are needed."
        },
        "IAttachmentFile.IUpdate": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string",
              "description": "Updated file name without extension, if renaming is allowed."
            },
            "extension": {
              "type": "string",
              "description": "File extension update, if required (null for none)."
            }
          },
          "required": [],
          "description": "Editable fields for an attachment file, for updating metadata such as name or extension. Typically admin-only. Prisma: `name`, `extension` columns."
        },
        "IAttachmentFile.IDelete": {
          "type": "object",
          "properties": {
            "confirm": {
              "type": "boolean",
              "description": "Whether to confirm deletion (required for APIs using staged delete patterns)."
            },
            "admin_reason": {
              "type": "string",
              "description": "Optional note by admin for the reason this file is being deleted."
            }
          },
          "required": [],
          "description": "Payload to request logical deletion of an attachment file, with admin notes. For admin/audit use only."
        },
        "IPage.IPagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "description": "Current page number of the result set.",
              "format": "uint32"
            },
            "limit": {
              "type": "integer",
              "description": "Maximum records returned per page. Default is 100.",
              "format": "uint32"
            },
            "records": {
              "type": "integer",
              "description": "Total number of records found (for all pages).",
              "format": "uint32"
            },
            "pages": {
              "type": "integer",
              "description": "Total number of pages calculated from records/limit (with ceiling).",
              "format": "uint32"
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Page information for paginated responses.\n\nIncludes current, limit, total records, and total pages for API responses adhering to the IPage<T> pattern."
        }
      }
    },
    "completed": 9,
    "total": 27,
    "step": 1,
    "created_at": "2025-05-23T12:22:14.762Z"
  },
  {
    "type": "interfaceComponents",
    "components": {
      "schemas": {
        "IBbsArticle.IRequest": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "format": "uint32",
              "description": "The page number for pagination.\n\nPrisma schema correspondence: BBS article list query pagination. Optional value."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Number of articles per page. Defaults to 100.\n\nPrisma schema correspondence: Used in paginated queries."
            },
            "writer": {
              "type": "string",
              "description": "Writer's name filter.\n\nPrisma: bbs_articles.writer."
            },
            "title": {
              "type": "string",
              "description": "Article title filter. Search will apply to the latest snapshot's title.\n\nPrisma: bbs_article_snapshots.title."
            },
            "date_from": {
              "type": "string",
              "format": "date-time",
              "description": "Start date/time for filtering articles by creation time.\n\nPrisma: bbs_articles.created_at."
            },
            "date_to": {
              "type": "string",
              "format": "date-time",
              "description": "End date/time for filtering articles by creation time.\n\nPrisma: bbs_articles.created_at."
            },
            "has_comment": {
              "type": "boolean",
              "description": "Filter for articles with or without comments.\n\nPrisma: bbs_article_comments (count > 0)."
            }
          },
          "description": "Request parameters for listing/filtering bulletin board articles.\n\nReferences bbs_articles for identity, and bbs_article_snapshots for title filters. Supports pagination, search, and filter criteria. Used for PATCH /bbs/articles list endpoint.",
          "required": []
        },
        "IPageIBbsArticle.ISummary": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticle.ISummary"
              },
              "description": "List of summary objects for articles.\n\nEach includes last snapshot's title and metadata."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated result containing summary information for multiple bulletin board articles.\n\nUsed as the return type for article list endpoints with filtering, sort and pagination."
        },
        "IBbsArticle.ISummary": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the article.\n\nPrisma: bbs_articles.id."
            },
            "writer": {
              "type": "string",
              "description": "Name of the article writer. \n\nPrisma: bbs_articles.writer."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Creation timestamp of the article.\n\nPrisma: bbs_articles.created_at."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Deletion timestamp, if the article has been deleted (logical delete).\n\nPrisma: bbs_articles.deleted_at.\n\nNull when not deleted."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Deletion timestamp, if the article has been deleted (logical delete).\n\nPrisma: bbs_articles.deleted_at.\n\nNull when not deleted."
            },
            "title": {
              "type": "string",
              "description": "The title of the latest snapshot for the article.\n\nPrisma: bbs_article_snapshots.title (most recent)."
            },
            "comment_count": {
              "type": "integer",
              "description": "The number of non-deleted comments on the article.\n\nCalculated from bbs_article_comments where deleted_at is null."
            }
          },
          "required": [
            "id",
            "writer",
            "created_at",
            "title",
            "comment_count"
          ],
          "description": "Summary output for a bulletin board article. Contains identifying and display information, including latest title and comment count.\n\nDraws on bbs_articles and latest record in bbs_article_snapshots."
        },
        "IBbsArticle.ICreate": {
          "type": "object",
          "properties": {
            "writer": {
              "type": "string",
              "description": "Name of the article's writer. Required on creation.\n\nPrisma: bbs_articles.writer."
            },
            "password": {
              "type": "string",
              "description": "Write-access password for the article, supplied as plain text and stored hashed.\n\nPrisma: bbs_articles.password."
            },
            "title": {
              "type": "string",
              "description": "Article's initial title.\n\nStored within the first snapshot. Prisma: bbs_article_snapshots.title."
            },
            "body": {
              "type": "string",
              "description": "The initial body/content of the article.\n\nPrisma: bbs_article_snapshots.body."
            },
            "format": {
              "type": "string",
              "description": "Format of the article body (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
            },
            "attachments": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "List of attachment file UUIDs to be linked with initial snapshot (order preserved). Optional.\n\nPrisma: bbs_article_snapshot_files. Can be empty array."
            }
          },
          "required": [
            "writer",
            "password",
            "title",
            "body",
            "format"
          ],
          "description": "Request body to create a new article. Includes metadata, content, attachments.\n\nMaps to bbs_articles for writer/password and to bbs_article_snapshots for content/history. Passwords are never stored in plain text after receipt."
        },
        "IBbsArticle": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the article.\n\nPrisma: bbs_articles.id."
            },
            "writer": {
              "type": "string",
              "description": "The article's writer name.\n\nPrisma: bbs_articles.writer."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Time article was created.\n\nPrisma: bbs_articles.created_at."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Logical deletion timestamp. Set on article deletion, or null if not deleted.\n\nPrisma: bbs_articles.deleted_at."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Logical deletion timestamp. Set on article deletion, or null if not deleted.\n\nPrisma: bbs_articles.deleted_at."
            },
            "latest_snapshot": {
              "$ref": "#/components/schemas/IBbsArticleSnapshot",
              "description": "Current/latest snapshot information for the article (title/body/format).\n\nReferences most recent bbs_article_snapshots record."
            },
            "comment_count": {
              "type": "integer",
              "description": "Number of non-deleted comments attached to this article.\n\nDerived from bbs_article_comments."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IAttachmentFile"
              },
              "description": "Files attached to the latest article snapshot, ordered.\n\nReferences attachment_files via bbs_article_snapshot_files."
            }
          },
          "required": [
            "id",
            "writer",
            "created_at",
            "latest_snapshot",
            "comment_count"
          ],
          "description": "Full representation of a bulletin board article, including metadata, current version info, comments count, and attachments.\n\nCombines bbs_articles with latest bbs_article_snapshots and relevant relationships."
        },
        "IBbsArticle.IUpdate": {
          "type": "object",
          "properties": {
            "password": {
              "type": "string",
              "description": "Writer's password for authentication prior to modification.\n\nPrisma: bbs_articles.password (hashed, verify only)."
            },
            "title": {
              "type": "string",
              "description": "Updated article title (becomes latest snapshot when modified).\n\nPrisma: bbs_article_snapshots.title."
            },
            "body": {
              "type": "string",
              "description": "Updated article content/body.\n\nPrisma: bbs_article_snapshots.body."
            },
            "format": {
              "type": "string",
              "description": "Updated body format (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
            },
            "attachments": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uuid"
              },
              "description": "New array of attachment file UUIDs to associate with new snapshot (order preserved). Optional.\n\nPrisma: bbs_article_snapshot_files."
            }
          },
          "required": [
            "password",
            "title",
            "body",
            "format"
          ],
          "description": "Body for updating an article. All modifications result in creation of a new snapshot with revised content/attachments.\n\nRequires password verification for security. Snapshots are appended, not overwritten."
        },
        "IBbsArticle.IDelete": {
          "type": "object",
          "properties": {
            "password": {
              "type": "string",
              "description": "Password for writer authentication prior to logical deletion.\n\nPrisma: bbs_articles.password. Admins may not require."
            }
          },
          "required": [
            "password"
          ],
          "description": "Delete request body for soft-deletion of an article. Verifies password.\n\nMarks deleted_at, but keeps record for dispute evidence preservation. Only privileged roles may bypass password."
        },
        "IBbsArticleSnapshot.IRequest": {
          "type": "object",
          "properties": {
            "page": {
              "type": "integer",
              "format": "uint32",
              "description": "Pagination: page number.\n\nUsed for paginated history listing."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Pagination: number of items per page.\n\nDefaults to 100."
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "Filter snapshots to a single article.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
            },
            "ip": {
              "type": "string",
              "description": "IP address filter for snapshot writer.\n\nPrisma: bbs_article_snapshots.ip."
            },
            "format": {
              "type": "string",
              "description": "Body format filter (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
            },
            "date_from": {
              "type": "string",
              "format": "date-time",
              "description": "Filter: Only snapshots created after this ISO datetime."
            },
            "date_to": {
              "type": "string",
              "format": "date-time",
              "description": "Filter: Only snapshots created before this ISO datetime."
            }
          },
          "description": "Request body for searching/listing article snapshots. Supports filter and pagination fields. Used for PATCH /bbs/articles/snapshots endpoint.",
          "required": []
        },
        "IPageIBbsArticleSnapshot.ISummary": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleSnapshot.ISummary"
              },
              "description": "List of article snapshot summaries (basic version info, omitting full body)."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated result type for listing snapshot summaries for articles.\n\nAggregates bbs_article_snapshots metadata for multiple snapshots."
        },
        "IBbsArticleSnapshot.ISummary": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the article snapshot.\n\nPrisma: bbs_article_snapshots.id."
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "Article to which this snapshot belongs.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
            },
            "title": {
              "type": "string",
              "description": "Title for this version of the article.\n\nPrisma: bbs_article_snapshots.title."
            },
            "format": {
              "type": "string",
              "description": "Body format for this version.\n\nPrisma: bbs_article_snapshots.format."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp (ISO) when this snapshot record was created.\n\nPrisma: bbs_article_snapshots.created_at."
            }
          },
          "required": [
            "id",
            "bbs_article_id",
            "title",
            "format",
            "created_at"
          ],
          "description": "Summary object for an article snapshot, containing identifying info and display metadata.\n\nExcludes body/content and attachments."
        },
        "IBbsArticleSnapshot": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID for this article snapshot (version record).\n\nPrisma: bbs_article_snapshots.id."
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "Article this version belongs to.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
            },
            "title": {
              "type": "string",
              "description": "Display title for this version state.\n\nPrisma: bbs_article_snapshots.title."
            },
            "body": {
              "type": "string",
              "description": "Content body of the article at this snapshot/version.\n\nPrisma: bbs_article_snapshots.body."
            },
            "format": {
              "type": "string",
              "description": "Body format (e.g., md, html, txt).\n\nPrisma: bbs_article_snapshots.format."
            },
            "ip": {
              "type": "string",
              "description": "IP address of the snapshot's author/editor.\n\nPrisma: bbs_article_snapshots.ip."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when the snapshot was created.\n\nPrisma: bbs_article_snapshots.created_at."
            },
            "attachments": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IAttachmentFile"
              },
              "description": "Attachment files for this article snapshot, in order.\n\nReferences attachment_files via bbs_article_snapshot_files."
            }
          },
          "required": [
            "id",
            "bbs_article_id",
            "title",
            "body",
            "format",
            "ip",
            "created_at"
          ],
          "description": "Full representation of a specific article snapshot/version. Contains title, content, author IP, creation time, and all associated attachments.\n\nMaps to bbs_article_snapshots, attachment_files, and related junction tables."
        },
        "IAttachmentFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Attachment file UUID.\n\nPrisma: attachment_files.id."
            },
            "name": {
              "type": "string",
              "description": "Filename, without extension (e.g., 'manual').\n\nPrisma: attachment_files.name."
            },
            "extension": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "File extension (null for files like 'README').\n\nPrisma: attachment_files.extension."
                },
                {
                  "type": "null"
                }
              ],
              "description": "File extension (null for files like 'README').\n\nPrisma: attachment_files.extension."
            },
            "url": {
              "type": "string",
              "description": "Storage URL/path where file is accessed.\n\nPrisma: attachment_files.url."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Time the file was registered in the system.\n\nPrisma: attachment_files.created_at."
            }
          },
          "required": [
            "id",
            "name",
            "url",
            "created_at"
          ],
          "description": "Metadata entity for an attachment file managed in the system. Records filename, extension, file location, and creation time.\n\nMatches attachment_files table in Prisma DB."
        },
        "IPage.IPagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number in pagination."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Number of records per page."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total number of records matching the query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total page count, computed from total records and per-page limit."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Standard pagination metadata container for paginated endpoint results.\n\nMatches IPage.IPagination standard type."
        }
      }
    },
    "completed": 18,
    "total": 27,
    "step": 1,
    "created_at": "2025-05-23T12:22:21.160Z"
  },
  {
    "type": "interfaceComponents",
    "components": {
      "schemas": {
        "IBbsArticleSnapshot.IUpdate": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "The unique identifier of the article snapshot to update. (Prisma: id)\n\nRequired for targeting the specific snapshot for partial update. Referenced as the 'id' column in bbs_article_snapshots."
            },
            "tag": {
              "type": "string",
              "description": "Administrative tag or internal label for the snapshot. (example: evidence, correction). Not part of core article evidence body. Optional property for metadata management."
            },
            "status": {
              "type": "string",
              "description": "Administrative status or moderation note (e.g. valid, under_review, censored, etc.). Optional. Used for possible status workflow by admins."
            }
          },
          "required": [
            "id"
          ],
          "description": "Administrative update object for article snapshot entity. Used only by privileged actors for meta changes; does NOT allow editing of core version evidence content. Based on bbs_article_snapshots table, focusing on tag/status/meta-correction scenarios. Can be extended for further admin fields if required."
        },
        "IBbsArticleComment.IRequest": {
          "type": "object",
          "properties": {
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)"
            },
            "page": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Page number for pagination. Optional. Defaults to 1 if absent."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Page number for pagination. Optional. Defaults to 1 if absent."
            },
            "limit": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Number of comments per page. Optional. Defaults to 100."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Number of comments per page. Optional. Defaults to 100."
            },
            "writer": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Filter for comments by specific writer's name. Used for searching. Optional."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter for comments by specific writer's name. Used for searching. Optional."
            }
          },
          "required": [],
          "description": "Parameters used for listing or searching comments linked to a specific article. Supports hierarchy, writer filter, and pagination. Corresponds to segment queries for comments shown in UI tree. Derived from comment request UI and bbs_article_comments schema."
        },
        "IPageIBbsArticleComment.ISummary": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleComment.ISummary"
              },
              "description": "Array of summarized comment objects for the current page."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Paginated result of comment summaries for a given article. Includes a page info object and an array of summary comment objects (IBbsArticleComment.ISummary). Used for efficient comment list rendering with pagination in UI. Respects evidence and logical delete policy in returned records."
        },
        "IBbsArticleComment.ICreate": {
          "type": "object",
          "properties": {
            "writer": {
              "type": "string",
              "description": "Author name for the comment. (Prisma: writer, bbs_article_comments)\n\nRequired during creation, displayed publicly. Not a unique identifier but user-supplied."
            },
            "password": {
              "type": "string",
              "description": "Plaintext password for comment creation. Stored in DB ONLY as a cryptographic hash. (Prisma: password, bbs_article_comments)\n\nMust not be returned in reads. Used for authentication in later mod/delete."
            },
            "format": {
              "type": "string",
              "description": "Format of the comment body: e.g. 'html', 'markdown', 'txt'. (Prisma: format, bbs_article_comment_snapshots)\n\nEnables rendering multi-format body content in UI, evidence preservation."
            },
            "body": {
              "type": "string",
              "description": "Actual comment content.\n\nWhen created, stored in a snapshot record (bbs_article_comment_snapshots). Forms part of the evidential history."
            },
            "attachments": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAttachmentFile.IReference"
                  },
                  "description": "Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)"
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)"
            },
            "ip": {
              "type": "string",
              "description": "IP address of commenter (from request context, not settable by user in API). Recorded for each evidence/snapshot. Used for dispute/evidence policy."
            }
          },
          "required": [
            "writer",
            "password",
            "format",
            "body"
          ],
          "description": "Request body for creating a new comment (root or reply). Carries author/writer, password, comment content (body), body format (html/md/txt), and (optionally) attachments. Parent_id links replies. On create, initializes a first snapshot for evidence. Based on bbs_article_comments and bbs_article_comment_snapshots schema columns."
        },
        "IBbsArticleComment": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Unique identifier for the comment record. (Prisma: id, bbs_article_comments)"
            },
            "bbs_article_id": {
              "type": "string",
              "format": "uuid",
              "description": "UUID of the parent article. (Prisma: bbs_article_id)"
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)"
            },
            "writer": {
              "type": "string",
              "description": "Writer's name (saved as plaintext, public)."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Comment creation timestamp (Prisma: created_at)\n\nIndicates original posting time and used in sorting/UI display."
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Logical deletion timestamp (Prisma: deleted_at; null if not deleted)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Logical deletion timestamp (Prisma: deleted_at; null if not deleted)."
            },
            "latest_snapshot": {
              "$ref": "#/components/schemas/IBbsArticleCommentSnapshot",
              "description": "The latest version/snapshot of the comment content.\n\nReferences evidence record for current visible body, format, and attachments. (bbs_article_comment_snapshots)"
            },
            "children": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IBbsArticleComment.ISummary"
                  },
                  "description": "Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI."
            },
            "attachments": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAttachmentFile"
                  },
                  "description": "Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)"
            },
            "is_deleted": {
              "type": "boolean",
              "description": "Indicate whether comment is deleted (deleted_at != null). Not a DB field, for convenience only."
            }
          },
          "required": [
            "id",
            "bbs_article_id",
            "writer",
            "created_at",
            "latest_snapshot"
          ],
          "description": "Full comment object with evidence/latest body, parent/child relations, deletion marker, and all metadata. Core entity is bbs_article_comments, with latest body joined from bbs_article_comment_snapshots. Attachments from attachment_files joined as needed. Used in detailed comment views, evidence review, or admin panels."
        },
        "IBbsArticleComment.ISummary": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Comment's unique ID"
            },
            "writer": {
              "type": "string",
              "description": "Writer's display name (public)"
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Comment creation timestamp"
            },
            "deleted_at": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Comment logical deletion time (null if active)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Comment logical deletion time (null if active)"
            },
            "body": {
              "type": "string",
              "description": "Most recent comment content (from latest snapshot for list view efficiency).\n\nNot always entire evidence record (see IBbsArticleComment for full version history)."
            },
            "attachments": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAttachmentFile.ISummary"
                  },
                  "description": "Brief info on attached files for the latest snapshot. Null or empty if none."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Brief info on attached files for the latest snapshot. Null or empty if none."
            },
            "parent_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of parent comment if nested/reply, null if root-level."
                },
                {
                  "type": "null"
                }
              ],
              "description": "ID of parent comment if nested/reply, null if root-level."
            }
          },
          "required": [
            "id",
            "writer",
            "created_at",
            "body"
          ],
          "description": "Summary view for comment list (e.g., in IPageIBbsArticleComment.ISummary). Contains basic info for rendering top-level and nested comments efficiently. Attachments only as summary (IAttachmentFile.ISummary)."
        },
        "IBbsArticleComment.IUpdate": {
          "type": "object",
          "properties": {
            "password": {
              "type": "string",
              "description": "Password supplied for verification (plaintext, compared securely to hash in DB).\n\nRequired for authentication before modifying the comment or any evidence content."
            },
            "body": {
              "type": "string",
              "description": "New comment content/body to be recorded in a new snapshot version history (not in-place overwrite).\n\nPreserves evidence trail."
            },
            "format": {
              "type": "string",
              "description": "Format indicator for new body (e.g. 'html', 'md', 'txt').\n\nAllows rich editing and multi-format content."
            },
            "attachments": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAttachmentFile.IReference"
                  },
                  "description": "Optional list of file attachment references for new revision (can add/remove/reorder)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Optional list of file attachment references for new revision (can add/remove/reorder)."
            },
            "ip": {
              "type": "string",
              "description": "IP address of the modifier (system/infra-injected, not user-supplied)."
            }
          },
          "required": [
            "password",
            "body",
            "format"
          ],
          "description": "Request body for updating (editing) an existing comment. Password check required. New body content, format, and attachments create a new version snapshot for evidence. Based on schemas for bbs_article_comments and bbs_article_comment_snapshots."
        },
        "IBbsArticleComment.IDelete": {
          "type": "object",
          "properties": {
            "password": {
              "type": "string",
              "description": "Password supplied to verify correct authorization for logical deletion (soft delete). (Prisma: password, bbs_article_comments)\n\nSystem will check supplied plaintext against hash in DB."
            }
          },
          "required": [
            "password"
          ],
          "description": "Request body for logical (soft) deletion of a comment. Only accepted from author with password verification. Triggers logical delete (sets deleted_at), but never physical removal."
        },
        "IBbsArticleCommentSnapshot.IRequest": {
          "type": "object",
          "properties": {
            "bbs_article_comment_id": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "uuid",
                  "description": "ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments."
                },
                {
                  "type": "null"
                }
              ],
              "description": "ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments."
            },
            "format": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Format filter (e.g.: html, md, txt)"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Format filter (e.g.: html, md, txt)"
            },
            "ip": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "IP address filter. Allows audit by IP evidence trail."
                },
                {
                  "type": "null"
                }
              ],
              "description": "IP address filter. Allows audit by IP evidence trail."
            },
            "from_date": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "Start of creation date range filter (UTC)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Start of creation date range filter (UTC)."
            },
            "to_date": {
              "oneOf": [
                {
                  "type": "string",
                  "format": "date-time",
                  "description": "End of creation date range filter (UTC)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "End of creation date range filter (UTC)."
            },
            "page": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Page number for pagination."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Page number for pagination."
            },
            "limit": {
              "oneOf": [
                {
                  "type": "integer",
                  "format": "uint32",
                  "description": "Max records per page (default 100)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Max records per page (default 100)."
            }
          },
          "required": [],
          "description": "Parameters for searching/filtering comment snapshot records. Derived from bbs_article_comment_snapshots; used for evidence/audit UIs and administration. Includes support for paging, filtering by comment, format, IP address, date."
        },
        "IPageIBbsArticleCommentSnapshot": {
          "type": "object",
          "properties": {
            "pagination": {
              "$ref": "#/components/schemas/IPage.IPagination"
            },
            "data": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshot"
              },
              "description": "Snapshots for the selected page and criteria; array of full objects."
            }
          },
          "required": [
            "pagination",
            "data"
          ],
          "description": "Page result type for listing comment snapshots. Returns IBbsArticleCommentSnapshot entities in paginated form with metadata for UI or admin consumption."
        },
        "IBbsArticleCommentSnapshot": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Snapshot's unique identifier. (Prisma: id, bbs_article_comment_snapshots)"
            },
            "bbs_article_comment_id": {
              "type": "string",
              "format": "uuid",
              "description": "Parent comment's UUID (bbs_article_comment_id)\n\nLinks snapshot to its comment; forms 1:N version tree."
            },
            "format": {
              "type": "string",
              "description": "Format of content: html, md, txt, etc. (Prisma: format)\n\nPrepares content for rendering."
            },
            "body": {
              "type": "string",
              "description": "Comment body content as preserved at this version. Immutable for evidence/policy (Prisma: body)"
            },
            "ip": {
              "type": "string",
              "description": "IP address of author/modifier as captured for audit (Prisma: ip)\n\nNever changeable; maintained for audit chain."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Timestamp when this snapshot/version was created (Prisma: created_at)\n\nPreserves order and evidence."
            },
            "attachments": {
              "oneOf": [
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/IAttachmentFile"
                  },
                  "description": "Files associated with this snapshot (via attachment_files/bbs_article_comment_snapshot_files join).\n\nPreserves evidential linkage for attachments."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Files associated with this snapshot (via attachment_files/bbs_article_comment_snapshot_files join).\n\nPreserves evidential linkage for attachments."
            }
          },
          "required": [
            "id",
            "bbs_article_comment_id",
            "format",
            "body",
            "ip",
            "created_at"
          ],
          "description": "Represents an immutable snapshot/version of a comment's content. All edits create a new object. Used to maintain revision trail for evidence/audit. Based on bbs_article_comment_snapshots schema."
        },
        "IAttachmentFile.IReference": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Attachment File unique ID."
            },
            "sequence": {
              "type": "integer",
              "description": "Order/position of file in attachments array (required for reordering files in snapshot, not in core 'attachment_files')."
            }
          },
          "required": [
            "id",
            "sequence"
          ],
          "description": "Reference to attachment file for linking to comments or comment snapshots. Used during comment create/update to form connection in evidence."
        },
        "IAttachmentFile.ISummary": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Attachment File unique ID (summary view)."
            },
            "name": {
              "type": "string",
              "description": "File name (without extension)."
            },
            "extension": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Extension (nullable, e.g. for README)."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Extension (nullable, e.g. for README)."
            },
            "url": {
              "type": "string",
              "description": "Web-accessible URL for file download/preview."
            }
          },
          "required": [
            "id",
            "name",
            "url"
          ],
          "description": "Summary view of attachment file, for efficient preview in lists or minimal context popups (less than IAttachmentFile)."
        },
        "IAttachmentFile": {
          "type": "object",
          "properties": {
            "id": {
              "type": "string",
              "format": "uuid",
              "description": "Attachment file's UUID. (attachment_files.id)"
            },
            "name": {
              "type": "string",
              "description": "File name (excluding extension)"
            },
            "extension": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Extension, or null if no extension."
                },
                {
                  "type": "null"
                }
              ],
              "description": "Extension, or null if no extension."
            },
            "url": {
              "type": "string",
              "description": "Web URL for file download/view."
            },
            "created_at": {
              "type": "string",
              "format": "date-time",
              "description": "Creation timestamp (UTC)."
            }
          },
          "required": [
            "id",
            "name",
            "url",
            "created_at"
          ],
          "description": "Full attachment file object; includes all fields in Prisma attachment_files table. Used in comment, snapshot, and article file relationships."
        },
        "IPage.IPagination": {
          "type": "object",
          "properties": {
            "current": {
              "type": "integer",
              "format": "uint32",
              "description": "Current page number."
            },
            "limit": {
              "type": "integer",
              "format": "uint32",
              "description": "Records per page (default 100)."
            },
            "records": {
              "type": "integer",
              "format": "uint32",
              "description": "Total record count in DB for query."
            },
            "pages": {
              "type": "integer",
              "format": "uint32",
              "description": "Total available pages for current filter."
            }
          },
          "required": [
            "current",
            "limit",
            "records",
            "pages"
          ],
          "description": "Paging metadata for trunked list or search API responses. Used throughout all IPage<T> typed responses."
        }
      }
    },
    "completed": 27,
    "total": 27,
    "step": 1,
    "created_at": "2025-05-23T12:22:29.299Z"
  },
  {
    "type": "interfaceComplete",
    "files": {
      "/.env.local": "API_PORT=37001",
      "/.eslintrc.cjs": "module.exports = {\n  root: true,\n  plugins: [\"@typescript-eslint\", \"deprecation\"],\n  extends: [\"plugin:@typescript-eslint/recommended\"],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    project: [\"tsconfig.json\", \"test/tsconfig.json\"],\n  },\n  overrides: [\n    {\n      files: [\"src/**/*.ts\", \"test/**/*.ts\"],\n      rules: {\n        \"@typescript-eslint/consistent-type-definitions\": \"off\",\n        \"@typescript-eslint/no-empty-function\": \"off\",\n        \"@typescript-eslint/no-empty-interface\": \"off\",\n        \"@typescript-eslint/no-explicit-any\": \"off\",\n        \"@typescript-eslint/no-inferrable-types\": \"off\",\n        \"@typescript-eslint/no-namespace\": \"off\",\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-unused-vars\": \"off\",\n        \"@typescript-eslint/no-var-requires\": \"off\",\n        \"@typescript-eslint/no-floating-promises\": \"error\",\n        \"@typescript-eslint/no-require-imports\": \"off\",\n        \"@typescript-eslint/no-empty-object-type\": \"off\",\n      },\n    },\n  ],\n};\n",
      ".github/workflows/build.yml": "name: build\non:\n  pull_request:\n    paths:\n      - 'src/**'\n      - 'test/**'\n      - 'package.json'\njobs:\n  Ubuntu:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20.x\n      - uses: pnpm/action-setup@v4\n        with:\n          version: 8\n      \n      - name: Install Backend-Server\n        run: pnpm install\n\n      - name: Build Swagger\n        run: npm run build:swagger\n\n      - name: Build SDK\n        run: npm run build:sdk\n\n      - name: Compile Backend-Server\n        run: npm run build\n\n      - name: Run Test Program\n        run: npm run test -- --simultaneous 16\n\n      - name: EsLint\n        run: npm run eslint\n",
      ".github/workflows/typos.yml": "name: typos\non:\n  pull_request:\n\njobs:\n  typos:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Actions Repository\n        uses: actions/checkout@v4\n\n      - uses: crate-ci/typos@master\n        with:\n          config: ./typos.toml\n",
      "/.gitignore": ".git/\nbin/\ndist/\nlib/\nnode_modules/\npackages/api/lib/\n\n.env\npackage-lock.json\npnpm-lock.yaml",
      "/.prettierignore": "dist\nbin\nnode_modules\npackages\nsrc/api/functional\nsrc/api/utils/NestiaSimulator.ts\nREADME.md\ntsconfig.json",
      ".vscode/launch.json": "{\n  // Use IntelliSense to learn about possible Node.js debug attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n  {\n    \"type\": \"node\",\n    \"request\": \"launch\",\n    \"name\": \"Backend Test\",\n    \"program\": \"${workspaceRoot}/test/index.ts\",\n    \"cwd\": \"${workspaceRoot}\",\n    \"args\": [\n      // //----\n      // // Not possible to reset DB in debugging mode\n      // //\n      // // Therefore, if you need DB reset, then do it \n      // // through `npm run reset-for-debugging` command\n      // //----\n      // \"--reset\", \"false\",\n      // \"--mode\", \"local\",\n      \n      //----\n      // You can run specific test functions\n      //\n      // If you want to include or exclude multiple words,\n      // then separate them with space character\n      //----\n      // \"--include\", \"some-words-to-include\",\n      // \"--exclude\", \"some-word another-word\",\n  ],\n    \"outFiles\": [\"${workspaceRoot}/bin/**/*.js\"],\n  }\n]\n}",
      ".vscode/settings.json": "{\n  \"editor.tabSize\": 2,\n  \"editor.formatOnSave\": true,\n  \"[javascript][typescript]\": {\n    \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n    \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": \"explicit\"\n    },\n  }\n}",
      "/LICENSE": "MIT License\n\nCopyright (c) 2022 Jeongho Nam\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
      "/README.md": "# Nestia Template\n## Outline\n[![Build Status](https://github.com/samchon/nestia-start/workflows/build/badge.svg)](https://github.com/samchon/nestia-start/actions?query=workflow%3Abuild)\n\nA template repository for backend projects using [nestia](https://github.com/samchon/nestia).\n\nYou can create a new project from this boilerplate by running below command:\n\n```bash\nnpx nestia start <directory>\n```\n\nFor reference, this is a minimal boilerplate project concentrating only on [nestia](https://github.com/samchon/nestia) SDK generation. \n\nIf you wanna much detailed boilerplate project, visit [`@samchon/backend`](https://github.com/samchon/backend).\n\n\n\n\n## Directories and Files\nThis template project has categorized directories like below.\n\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\n\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\n  - [src/](src): Backend source directory\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\n      - [**src/api/structures/**](src/api/structures/): DTO structures\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\n  - [**test/**](test): Test Automation Program\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\n  - [package.json](package.json): NPM configuration\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\n\n\n\n\n## NPM Run Commands\nList of the run commands defined in the [package.json](package.json) are like below:\n\n  - Test\n    - **`test`**: Run test automation program\n    - `benchmark`: Run performance benchmark program\n  - Build\n    - `build`: Build everything\n    - `build:main`: Build main program (`src` directory)\n    - `build:test` Build test automation program (`test` directory)\n    - `build:sdk`: Build SDK into main program only\n    - `build:swagger`: Build Swagger Documents\n    - **`dev`**: Incremental build for development (test program)\n  - Deploy\n    - `package:api`: Build and deploy the SDK library to the NPM\n    - `start`: Start the backend server\n    - `start:dev`: Start the backend server with incremental build and reload\n  - Webpack\n    - `webpack`: Run webpack bundler\n    - `webpack:start`: Start the backend server built by webpack\n    - `webpack:test`: Run test program to the webpack built\n\n\n\n\n## Specialization\nTransform this template project to be yours.\n\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\n\n| Before          | After\n|-----------------|----------------------------------------\n| ORGANIZATION | Your account or corporation name\n| PROJECT      | Your own project name\n| AUTHOR       | Author name\n| https://github.com/samchon/nestia-start | Your repository URL\n\n\n\n\n## Test Driven Development\nWith [nestia](https://github.com/samchon/nestia) helps to accomplish TDD (Test Driven Development). \n\nJust define DTOs and API controllers' methods (only declarations) first. After the definitions, and build SDK (Software Development Kit) through [nestia](https://github.com/samchon/nestia) (`npm run build:sdk`). After buildling those SDK, develop test automation program using the SDK, following use-case scenarios in the framework of client side.\n\nDuring the test automation program development, you can find that which API is miss-designed or which requirement analysis is not exact. Development of the main program must be the last step after such validation process during TDD.\n\n> Visit the [samchon/backend](https://github.com/samchon/backend), then you may find much detailed story about this TDD.\n>\n> 1. Definitions\n> 2. SDK\n> 3. Test Automation Program\n> 4. Main Program\n\n```typescript\nimport {\n  ArrayUtil,\n  GaffComparator,\n  RandomGenerator,\n  TestValidator,\n} from \"@nestia/e2e\";\n\nimport api from \"@ORGANIZATION/PROJECT-api/lib/index\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/bbs/IBbsArticle\";\nimport { IPage } from \"@ORGANIZATION/PROJECT-api/lib/structures/common/IPage\";\n\nexport async function test_api_bbs_article_index_sort(\n  connection: api.IConnection,\n): Promise<void> {\n  // GENERATE 100 ARTICLES\n  const section: string = \"general\";\n  await ArrayUtil.asyncRepeat(100)(() =>\n    api.functional.bbs.articles.create(connection, section, {\n      writer: RandomGenerator.name(),\n      title: RandomGenerator.paragraph(5)(),\n      body: RandomGenerator.content(8)()(),\n      format: \"txt\",\n      files: [],\n      password: RandomGenerator.alphabets(8),\n    }),\n  );\n\n  // PREPARE VALIDATOR\n  const validator = TestValidator.sort(\"BbsArticleProvider.index()\")(async (\n    sort: IPage.Sort<IBbsArticle.IRequest.SortableColumns>,\n  ) => {\n    const page: IPage<IBbsArticle.ISummary> =\n      await api.functional.bbs.articles.index(connection, section, {\n        limit: 100,\n        sort,\n      });\n    return page.data;\n  });\n\n  // DO VALIDATE\n  const components = [\n    validator(\"created_at\")(GaffComparator.dates((x) => x.created_at)),\n    validator(\"updated_at\")(GaffComparator.dates((x) => x.updated_at)),\n    validator(\"title\")(GaffComparator.strings((x) => x.title)),\n    validator(\"writer\")(GaffComparator.strings((x) => x.writer)),\n    validator(\n      \"writer\",\n      \"title\",\n    )(GaffComparator.strings((x) => [x.writer, x.title])),\n  ];\n  for (const comp of components) {\n    await comp(\"+\", false);\n    await comp(\"-\", false);\n  }\n}\n```\n\nFor reference, if you run `npm run benchmark` command, your test functions defined in the [test/features/api](test/features/api) directory would be utilized for performance benchmarking. If you want to see the performance bench result earlier, visit below link please:\n\n  - [docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md](https://github.com/samchon/nestia-start/blob/master/docs/benchmarks/AMD%20Ryzen%209%207940HS%20w%20Radeon%20780M%20Graphics.md)",
      "build/env.ts": "import fs from \"fs\";\n\nif (fs.existsSync(`${__dirname}/../.env`) === false)\n  fs.copyFileSync(`${__dirname}/../.env.local`, `${__dirname}/../.env`);\n",
      "docs/benchmarks/AMD Ryzen 9 7940HS w Radeon 780M Graphics.md": "# Benchmark Report\n> Generated by [`@nestia/benchmark`](https://github.com/samchon/nestia)\n\n  - Specifications\n    - CPU: AMD Ryzen 9 7940HS w/ Radeon 780M Graphics     \n    - RAM: 31 GB\n    - NodeJS Version: v20.10.0\n    - Backend Server: 1 core / 1 thread\n  - Arguments\n    - Count: 40,000\n    - Threads: 4\n    - Simultaneous: 32\n  - Time\n    - Start: 2024-10-29T19:14:35.941Z\n    - Complete: 2024-10-29T19:16:11.418Z\n    - Elapsed: 95,477 ms\n\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nTotal | 41,586 | 41,586 | 69.24 | 73.05 | 5 | 546\n\n> Unit: milliseconds\n\n## Memory Consumptions\n```mermaid\nxychart-beta\n  x-axis \"Time (second)\"\n  y-axis \"Memory (MB)\"\n  line \"Resident Set Size\" [122, 156, 159, 142, 154, 165, 184, 185, 187, 189, 200, 205, 209, 217, 221, 225, 229, 224, 230, 235, 242, 250, 256, 262, 267, 272, 234, 237, 249, 259, 266, 273, 285, 292, 291, 216, 225, 235, 243, 200, 208, 214, 186, 186, 171, 177, 187, 199, 185, 192, 205, 171, 180, 158, 170, 179, 163, 163, 176, 188, 193, 202, 213, 219, 230, 239, 256, 265, 283, 301, 240, 249, 257, 267, 284, 282, 290, 202, 213, 166, 178, 188, 200, 203, 208, 180, 191, 199, 175]\n  line \"Heap Total\" [85, 116, 120, 103, 114, 124, 146, 146, 147, 148, 158, 166, 170, 176, 180, 184, 187, 185, 190, 195, 203, 211, 217, 222, 225, 229, 194, 197, 209, 218, 225, 232, 241, 249, 247, 176, 185, 194, 202, 160, 168, 173, 146, 146, 130, 136, 146, 158, 145, 151, 165, 129, 139, 116, 128, 137, 120, 123, 136, 148, 152, 161, 172, 179, 189, 198, 215, 223, 241, 257, 200, 209, 216, 227, 244, 242, 249, 163, 174, 127, 136, 147, 159, 162, 166, 138, 150, 158, 132]\n  line \"Heap Used + External\" [69, 94, 62, 82, 88, 107, 71, 83, 93, 107, 136, 72, 76, 85, 92, 106, 139, 48, 68, 69, 86, 95, 108, 116, 140, 175, 67, 74, 88, 112, 125, 136, 142, 169, 180, 91, 104, 105, 121, 60, 71, 91, 64, 74, 86, 110, 121, 135, 76, 82, 103, 70, 93, 66, 91, 107, 76, 75, 95, 101, 115, 127, 136, 154, 165, 168, 196, 193, 214, 232, 84, 94, 101, 118, 145, 147, 149, 86, 96, 72, 90, 112, 126, 133, 132, 78, 87, 107, 88]\n  line \"Heap Used Only\" [66, 89, 59, 78, 83, 100, 68, 79, 88, 101, 129, 68, 72, 80, 86, 100, 131, 45, 64, 65, 81, 90, 103, 110, 133, 168, 64, 71, 84, 108, 120, 130, 136, 162, 173, 88, 100, 101, 117, 58, 68, 87, 61, 71, 83, 107, 118, 130, 73, 79, 99, 67, 89, 63, 88, 103, 74, 72, 91, 98, 111, 123, 132, 149, 160, 163, 190, 187, 208, 225, 81, 90, 97, 114, 140, 143, 145, 83, 93, 70, 87, 108, 122, 130, 128, 76, 84, 104, 85]\n```\n\n> -  Resident Set Size\n> -  Heap Total\n> -  Heap Used + External\n> -  Heap Used Only\n\n## Endpoints\nType | Count | Success | Mean. | Stdev. | Minimum | Maximum\n----|----|----|----|----|----|----\nPATCH /bbs/articles/:section | 6,439 | 6,439 | 108.37 | 76.56 | 6 | 546\nPUT /bbs/articles/:section/:id | 380 | 380 | 78.52 | 69.03 | 6 | 296\nGET /bbs/articles/:section/:id | 917 | 917 | 77.65 | 69.84 | 6 | 463\nDELETE /bbs/articles/:section/:id | 201 | 201 | 73.89 | 63.55 | 7 | 307\nPOST /bbs/articles/:section | 33,649 | 33,649 | 61.39 | 70.04 | 5 | 546\n\n> Unit: milliseconds\n\n## Failures\nMethod | Path | Count | Failures\n-------|------|-------|----------",
      "/nest-cli.json": "{\n  \"$schema\": \"https://json.schemastore.org/nest-cli\",\n  \"collection\": \"@nestjs/schematics\",\n  \"sourceRoot\": \"src\",\n  \"entryFile\": \"executable/server\",\n  \"compilerOptions\": {\n    \"deleteOutDir\": true\n  }\n}\n",
      "/nestia.config.ts": "// nestia configuration file\nimport type sdk from \"@nestia/sdk\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyModule } from \"./src/MyModule\";\n\nconst NESTIA_CONFIG: sdk.INestiaConfig = {\n  input: () => NestFactory.create(MyModule),\n  output: \"src/api\",\n  swagger: {\n    output: \"packages/api/swagger.json\",\n    servers: [\n      {\n        url: \"http://localhost:37001\",\n        description: \"Local Server\",\n      },\n    ],\n    beautify: true,\n  },\n  distribute: \"packages/api\",\n  primitive: false,\n  simulate: true,\n};\nexport default NESTIA_CONFIG;\n",
      "/package.json": "{\n  \"private\": true,\n  \"name\": \"@ORGANIZATION/PROJECT\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Starter kit of Nestia\",\n  \"main\": \"lib/index.js\",\n  \"scripts\": {\n    \"benchmark\": \"node bin/test/benchmark\",\n    \"test\": \"node bin/test\",\n    \"test:webpack\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------BUILDS------------------------\": \"\",\n    \"build\": \"npm run build:sdk && npm run build:main && npm run build:test\",\n    \"build:api\": \"rimraf packages/api/lib && nestia all && rimraf packages/api/lib && tsc -p packages/api/tsconfig.json && rollup -c packages/api/rollup.config.js\",\n    \"build:main\": \"rimraf lib && tsc\",\n    \"build:sdk\": \"rimraf src/api/functional && nestia sdk\",\n    \"build:swagger\": \"npx nestia swagger\",\n    \"build:test\": \"rimraf bin && tsc -p test/tsconfig.json\",\n    \"dev\": \"npm run build:test -- --watch\",\n    \"eslint\": \"eslint src && eslint test\",\n    \"eslint:fix\": \"eslint --fix src && eslint --fix test\",\n    \"prepare\": \"ts-patch install && ts-node build/env.ts\",\n    \"prettier\": \"prettier src --write && prettier test --write\",\n    \"------------------------WEBPACK------------------------\": \"\",\n    \"webpack\": \"rimraf dist && webpack\",\n    \"webpack:start\": \"cd dist && node dist/server\",\n    \"webpack:test\": \"npm run webpack && node bin/test/webpack.js\",\n    \"------------------------DEPLOYS------------------------\": \"\",\n    \"package:api\": \"npm run build:api && cd packages/api && npm publish\",\n    \"start\": \"node lib/executable/server\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:swagger\": \"ts-node src/executable/swagger.ts\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia-start\"\n  },\n  \"keywords\": [\n    \"nestia\",\n    \"template\",\n    \"boilerplate\"\n  ],\n  \"author\": \"AUTHOR\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia-start/issues\"\n  },\n  \"homepage\": \"https://github.com/samchon/nestia-start#readme\",\n  \"devDependencies\": {\n    \"@nestia/benchmark\": \"^6.0.4\",\n    \"@nestia/e2e\": \"^6.0.4\",\n    \"@nestia/sdk\": \"^6.0.6\",\n    \"@nestjs/cli\": \"^11.0.7\",\n    \"@rollup/plugin-terser\": \"^0.4.4\",\n    \"@rollup/plugin-typescript\": \"^11.1.6\",\n    \"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n    \"@types/cli\": \"^0.11.21\",\n    \"@types/cli-progress\": \"^3.11.5\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/inquirer\": \"^8.2.5\",\n    \"@types/node\": \"^18.11.0\",\n    \"@types/uuid\": \"^8.3.4\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.1.0\",\n    \"@typescript-eslint/parser\": \"^8.1.0\",\n    \"chalk\": \"^4.1.2\",\n    \"cli\": \"^1.0.1\",\n    \"cli-progress\": \"^3.12.0\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"eslint-plugin-deprecation\": \"^3.0.0\",\n    \"express\": \"^4.18.2\",\n    \"nestia\": \"^7.0.0\",\n    \"prettier\": \"^3.2.4\",\n    \"prettier-plugin-prisma\": \"^5.0.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^4.18.0\",\n    \"source-map-support\": \"^0.5.21\",\n    \"swagger-ui-express\": \"^5.0.0\",\n    \"ts-loader\": \"^9.5.1\",\n    \"ts-node\": \"^10.9.1\",\n    \"ts-patch\": \"^3.3.0\",\n    \"typescript\": \"~5.8.3\",\n    \"typescript-transform-paths\": \"^3.5.5\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"write-file-webpack-plugin\": \"^4.5.1\"\n  },\n  \"dependencies\": {\n    \"@nestia/core\": \"^6.0.6\",\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"@nestjs/common\": \"^11.1.1\",\n    \"@nestjs/core\": \"^11.1.1\",\n    \"@nestjs/platform-express\": \"^11.1.1\",\n    \"commander\": \"10.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"dotenv-expand\": \"^10.0.0\",\n    \"inquirer\": \"8.2.5\",\n    \"serialize-error\": \"^4.1.0\",\n    \"tgrid\": \"^1.1.0\",\n    \"tstl\": \"^3.0.0\",\n    \"typia\": \"^9.3.1\",\n    \"uuid\": \"^9.0.0\"\n  },\n  \"stackblitz\": {\n    \"startCommand\": \"npm run prepare && npm run build:test && npm run test -- --simultaneous 1\"\n  }\n}",
      "packages/api/.gitignore": "lib/\nnode_modules/\n\nswagger.json\nopenai.json",
      "packages/api/LICENSE": "MIT License\n\nCopyright (c) 2021 ORGANIZATION\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.",
      "packages/api/README.md": "# SDK Library\nThis is a SDK library generated by [`nestia`](https://nestia.io).\n\nWith this SDK library, you can easily and safely interact with backend server.\n\nJust import and call some API functions like gif image below:\n\n![nestia-sdk-demo](https://user-images.githubusercontent.com/13158709/215004990-368c589d-7101-404e-b81b-fbc936382f05.gif)\n\n> Left is server code, and right is client code utilizing the SDK\n\n\n\n\n# What [`Nestia`](https://nestia.io) is:\n![Nestia Logo](https://nestia.io/logo.png)\n\n[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/samchon/nestia/blob/master/LICENSE)\n[![npm version](https://img.shields.io/npm/v/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Downloads](https://img.shields.io/npm/dm/@nestia/core.svg)](https://www.npmjs.com/package/@nestia/core)\n[![Build Status](https://github.com/samchon/nestia/workflows/build/badge.svg)](https://github.com/samchon/nestia/actions?query=workflow%3Abuild)\n[![Guide Documents](https://img.shields.io/badge/guide-documents-forestgreen)](https://nestia.io/docs/)\n\nNestia is a set of helper libraries for NestJS, supporting below features:\n\n  - `@nestia/core`: super-fast decorators\n  - `@nestia/sdk`:\n    - Swagger generator evolved than ever\n    - SDK library generator for clients\n    - Mockup Simulator for client applications\n    - Automatic E2E test functions generator\n  - `@nestia/migrate`: migration from Swagger to NestJS\n  - `nestia`: just CLI (command line interface) tool\n\n> **Note**\n> \n> - **Only one line** required, with pure TypeScript type\n> - Enhance performance **30x** up\n>   - Runtime validator is **20,000x faster** than `class-validator`\n>   - JSON serialization is **200x faster** than `class-transformer`\n> - Software Development Kit\n>   - SDK is a collection of `fetch` functions with type definitions like [tRPC](https://trpc.io/)\n>   - Mockup simulator means embedded backend simulator in SDK\n>     - similar with [msw](https://mswjs.io/), but fully automated",
      "packages/api/package.json": "{\n  \"name\": \"@ORGANIZATION/PROJECT-api\",\n  \"version\": \"0.1.0\",\n  \"description\": \"SDK library generated by Nestia\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"lib/index.mjs\",\n  \"typings\": \"lib/index.d.ts\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/samchon/nestia\"\n  },\n  \"author\": \"Jeongho Nam\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/samchon/nestia/issues\"\n  },\n  \"homepage\": \"https://nestia.io\",\n  \"files\": [\n    \"lib\",\n    \"package.json\",\n    \"swagger.json\",\n    \"openai.json\",\n    \"README.md\"\n  ],\n  \"dependencies\": {\n    \"@nestia/fetcher\": \"^6.0.6\",\n    \"tgrid\": \"^1.1.0\",\n    \"typia\": \"^9.3.1\"\n  }\n}",
      "packages/api/rollup.config.js": "const typescript = require(\"@rollup/plugin-typescript\");\nconst terser = require(\"@rollup/plugin-terser\");\n\nmodule.exports = {\n  input: `${__dirname}/../../src/api/index.ts`,\n  output: {\n    dir: `${__dirname}/lib`,\n    format: \"esm\",\n    entryFileNames: \"[name].mjs\",\n    sourcemap: true,\n  },\n  plugins: [\n    typescript({\n      tsconfig: `${__dirname}/tsconfig.json`,\n      module: \"ESNext\",\n      target: \"ESNext\",\n    }),\n    terser({\n      format: {\n        comments: \"some\",\n        beautify: true,\n        ecma: \"2020\",\n      },\n      compress: false,\n      mangle: false,\n      module: true,\n    }),\n  ],\n};\n",
      "packages/api/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n    /* Language and Environment */\n    \"target\": \"ES5\", /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    \"lib\": [\n      \"DOM\",\n      \"ES2015\"\n    ], /* Specify a set of bundled library declaration files that describe the target runtime environment. */// \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    // \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    // \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n    /* Modules */\n    \"module\": \"commonjs\", /* Specify what module code is generated. */// \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    // \"paths\": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n    /* Emit */\n    \"declaration\": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true, /* Create source map files for emitted JavaScript files. */// \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\", /* Specify an output folder for all emitted files. */// \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    \"downlevelIteration\": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\", /* Set the newline character for emitting files. */// \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true, /* Ensure that casing is correct in imports. *//* Type Checking */\n    \"strict\": true, /* Enable all strict type-checking options. */// \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    // \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    // \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    // \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    // \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true, /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      {\n        \"transform\": \"typia/lib/transform\"\n      }\n    ],\n    \"strictNullChecks\": true\n  },\n  \"include\": [\n    \"../../src/api\"\n  ]\n}",
      "/prettier.config.js": "module.exports = {\n  // DEFAULT CONFIGURATIONS\n  parser: \"typescript\",\n  printWidth: 80,\n  semi: true,\n  tabWidth: 2,\n  trailingComma: \"all\",\n\n  // PLUG-IN CONFIGURATIONS\n  plugins: [\"@trivago/prettier-plugin-sort-imports\"],\n  importOrder: [\n    \"<THIRD_PARTY_MODULES>\",\n    \"^@ORGANIZATION/PROJECT-api(.*)$\",\n    \"^[./]\",\n  ],\n  importOrderSeparation: true,\n  importOrderSortSpecifiers: true,\n  importOrderParserPlugins: [\"decorators-legacy\", \"typescript\"],\n};\n",
      "src/MyBackend.ts": "import { WebSocketAdaptor } from \"@nestia/core\";\nimport { INestApplication } from \"@nestjs/common\";\nimport { NestFactory } from \"@nestjs/core\";\n\nimport { MyConfiguration } from \"./MyConfiguration\";\nimport { MyModule } from \"./MyModule\";\n\nexport class MyBackend {\n  private application_?: INestApplication;\n\n  public async open(): Promise<void> {\n    //----\n    // OPEN THE BACKEND SERVER\n    //----\n    // MOUNT CONTROLLERS\n    this.application_ = await NestFactory.create(MyModule, { logger: false });\n    await WebSocketAdaptor.upgrade(this.application_);\n\n    // DO OPEN\n    this.application_.enableCors();\n    await this.application_.listen(MyConfiguration.API_PORT(), \"0.0.0.0\");\n\n    //----\n    // POST-PROCESSES\n    //----\n    // INFORM TO THE PM2\n    if (process.send) process.send(\"ready\");\n\n    // WHEN KILL COMMAND COMES\n    process.on(\"SIGINT\", async () => {\n      await this.close();\n      process.exit(0);\n    });\n  }\n\n  public async close(): Promise<void> {\n    if (this.application_ === undefined) return;\n\n    // DO CLOSE\n    await this.application_.close();\n    delete this.application_;\n  }\n}\n",
      "src/MyConfiguration.ts": "import fs from \"fs\";\nimport path from \"path\";\n\nimport { MyGlobal } from \"./MyGlobal\";\n\nexport namespace MyConfiguration {\n  export const API_PORT = () => Number(MyGlobal.env.API_PORT);\n\n  export const ROOT = (() => {\n    const split: string[] = __dirname.split(path.sep);\n    return split.at(-1) === \"src\" && split.at(-2) === \"bin\"\n      ? path.resolve(__dirname + \"/../..\")\n      : fs.existsSync(__dirname + \"/.env\")\n        ? __dirname\n        : path.resolve(__dirname + \"/..\");\n  })();\n}\n",
      "src/MyGlobal.ts": "import dotenv from \"dotenv\";\nimport dotenvExpand from \"dotenv-expand\";\nimport { Singleton } from \"tstl\";\nimport typia from \"typia\";\n\n/* eslint-disable */\nexport class MyGlobal {\n  public static testing: boolean = false;\n  public static get env(): MyGlobal.IEnvironments {\n    return environments.get();\n  }\n}\nexport namespace MyGlobal {\n  export interface IEnvironments {\n    API_PORT: `${number}`;\n  }\n}\n\nconst environments = new Singleton(() => {\n  const env = dotenv.config();\n  dotenvExpand.expand(env);\n  return typia.assert<MyGlobal.IEnvironments>(process.env);\n});\n",
      "src/api/HttpError.ts": "export { HttpError } from \"@nestia/fetcher\";\n",
      "src/api/IConnection.ts": "export type { IConnection } from \"@nestia/fetcher\";\n",
      "src/api/Primitive.ts": "export type { Primitive } from \"typia\";\n",
      "src/api/Resolved.ts": "export type { Resolved } from \"typia\";\n",
      "src/api/index.ts": "import * as api from \"./module\";\n\nexport * from \"./module\";\nexport default api;\n",
      "src/api/module.ts": "export type * from \"./IConnection\";\nexport * from \"./HttpError\";\n\nexport * as functional from \"./functional\";\n",
      "src/executable/server.ts": "import { MyBackend } from \"../MyBackend\";\n\nconst EXTENSION = __filename.substring(__filename.length - 2);\nif (EXTENSION === \"js\") require(\"source-map-support/register\");\n\nasync function main(): Promise<void> {\n  // BACKEND SEVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // UNEXPECTED ERRORS\n  global.process.on(\"uncaughtException\", console.error);\n  global.process.on(\"unhandledRejection\", console.error);\n}\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/executable/swagger.ts": "import cp from \"child_process\";\nimport express from \"express\";\n\nconst execute = (command: string): void => {\n  console.log(`\\n$ ${command}\\n`);\n  cp.execSync(command, { stdio: \"inherit\" });\n};\n\nconst main = async (): Promise<void> => {\n  if (!process.argv.some((str) => str === \"--skipBuild\"))\n    execute(\"npm run build:swagger\");\n\n  const docs = await import(\"../../packages/api/swagger.json\" as any);\n\n  const app = express();\n  const swaggerUi = require(\"swagger-ui-express\");\n  app.use(\"/api-docs\", swaggerUi.serve, swaggerUi.setup(docs));\n  app.listen(37810);\n\n  console.log(\"\\n\");\n  console.log(\"-----------------------------------------------------------\");\n  console.log(\"\\n Swagger UI Address: http://127.0.0.1:37810/api-docs \\n\");\n  console.log(\"-----------------------------------------------------------\");\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "src/utils/ErrorUtil.ts": "import serializeError = require(\"serialize-error\");\n\nexport namespace ErrorUtil {\n  export const toJSON = (err: any): object =>\n    err instanceof Object && err.toJSON instanceof Function\n      ? err.toJSON()\n      : serializeError(err);\n}\n",
      "src/utils/MapUtil.ts": "export namespace MapUtil {\n  export function take<Key, T>(\n    dict: Map<Key, T>,\n    key: Key,\n    generator: () => T,\n  ): T {\n    const oldbie: T | undefined = dict.get(key);\n    if (oldbie) return oldbie;\n\n    const value: T = generator();\n    dict.set(key, value);\n    return value;\n  }\n}\n",
      "test/TestAutomation.ts": "import { DynamicExecutor } from \"@nestia/e2e\";\nimport chalk from \"chalk\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport api from \"../src/api\";\nimport { ArgumentParser } from \"./helpers/ArgumentParser\";\n\nexport namespace TestAutomation {\n  export interface IProps<T> {\n    open(options: IOptions): Promise<T>;\n    close(backend: T): Promise<void>;\n  }\n\n  export interface IOptions {\n    simultaneous: number;\n    include?: string[];\n    exclude?: string[];\n  }\n\n  export const execute = async <T,>(props: IProps<T>): Promise<void> => {\n    // OPEN BACKEND\n    const options: IOptions = await getOptions();\n    const backend: T = await props.open(options);\n\n    // DO TEST\n    const connection: api.IConnection = {\n      host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n    };\n    const report: DynamicExecutor.IReport = await DynamicExecutor.validate({\n      prefix: \"test\",\n      location: __dirname + \"/features\",\n      parameters: () => [\n        {\n          host: connection.host,\n          encryption: connection.encryption,\n        },\n      ],\n      filter: (func) =>\n        (!options.include?.length ||\n          (options.include ?? []).some((str) => func.includes(str))) &&\n        (!options.exclude?.length ||\n          (options.exclude ?? []).every((str) => !func.includes(str))),\n      onComplete: (exec) => {\n        const trace = (str: string) =>\n          console.log(`  - ${chalk.green(exec.name)}: ${str}`);\n        if (exec.error === null) {\n          const elapsed: number =\n            new Date(exec.completed_at).getTime() -\n            new Date(exec.started_at).getTime();\n          trace(`${chalk.yellow(elapsed.toLocaleString())} ms`);\n        } else trace(chalk.red(exec.error.name));\n      },\n      simultaneous: options.simultaneous,\n    });\n\n    // TERMINATE - WAIT FOR BACKGROUND EVENTS\n    await sleep_for(2500);\n    await props.close(backend);\n\n    const failures: DynamicExecutor.IExecution[] = report.executions.filter(\n      (exec) => exec.error !== null,\n    );\n    if (failures.length === 0) {\n      console.log(\"Success\");\n      console.log(\"Elapsed time\", report.time.toLocaleString(), `ms`);\n    } else {\n      for (const f of failures) console.log(f.error);\n      process.exit(-1);\n    }\n\n    console.log(\n      [\n        `All: #${report.executions.length}`,\n        `Success: #${report.executions.length - failures.length}`,\n        `Failed: #${failures.length}`,\n      ].join(\"\\n\"),\n    );\n  };\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<TestAutomation.IOptions>(\n    async (command, prompt, action) => {\n      command.option(\n        \"--simultaneous <number>\",\n        \"number of simultaneous requests\",\n      );\n      command.option(\"--include <string...>\", \"include feature files\");\n      command.option(\"--exclude <string...>\", \"exclude feature files\");\n\n      return action(async (options) => {\n        options.simultaneous = Number(\n          options.simultaneous ??\n            (await prompt.number(\"simultaneous\")(\n              \"Number of simultaneous requests to make\",\n            )),\n        );\n        if (isNaN(options.simultaneous) || options.simultaneous <= 0)\n          options.simultaneous = 1;\n        return options as TestAutomation.IOptions;\n      });\n    },\n  );\n",
      "test/benchmark/index.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\nimport cliProgress from \"cli-progress\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport { IPointer } from \"tstl\";\n\nimport { MyBackend } from \"../../src/MyBackend\";\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\nimport { MyGlobal } from \"../../src/MyGlobal\";\nimport { ArgumentParser } from \"../helpers/ArgumentParser\";\n\ninterface IOptions {\n  include?: string[];\n  exclude?: string[];\n  count: number;\n  threads: number;\n  simultaneous: number;\n}\n\nconst getOptions = () =>\n  ArgumentParser.parse<IOptions>(async (command, prompt, action) => {\n    // command.option(\"--mode <string>\", \"target mode\");\n    // command.option(\"--reset <true|false>\", \"reset local DB or not\");\n    command.option(\"--include <string...>\", \"include feature files\");\n    command.option(\"--exclude <string...>\", \"exclude feature files\");\n    command.option(\"--count <number>\", \"number of requests to make\");\n    command.option(\"--threads <number>\", \"number of threads to use\");\n    command.option(\n      \"--simultaneous <number>\",\n      \"number of simultaneous requests to make\",\n    );\n    return action(async (options) => {\n      // if (typeof options.reset === \"string\")\n      //     options.reset = options.reset === \"true\";\n      // options.mode ??= await prompt.select(\"mode\")(\"Select mode\")([\n      //     \"LOCAL\",\n      //     \"DEV\",\n      //     \"REAL\",\n      // ]);\n      // options.reset ??= await prompt.boolean(\"reset\")(\"Reset local DB\");\n      options.count = Number(\n        options.count ??\n          (await prompt.number(\"count\")(\"Number of requests to make\")),\n      );\n      options.threads = Number(\n        options.threads ??\n          (await prompt.number(\"threads\")(\"Number of threads to use\")),\n      );\n      options.simultaneous = Number(\n        options.simultaneous ??\n          (await prompt.number(\"simultaneous\")(\n            \"Number of simultaneous requests to make\",\n          )),\n      );\n      return options as IOptions;\n    });\n  });\n\nconst main = async (): Promise<void> => {\n  // CONFIGURATIONS\n  const options: IOptions = await getOptions();\n  MyGlobal.testing = true;\n\n  // BACKEND SERVER\n  const backend: MyBackend = new MyBackend();\n  await backend.open();\n\n  // DO BENCHMARK\n  const prev: IPointer<number> = { value: 0 };\n  const bar: cliProgress.SingleBar = new cliProgress.SingleBar(\n    {},\n    cliProgress.Presets.shades_classic,\n  );\n  bar.start(options.count, 0);\n\n  const report: DynamicBenchmarker.IReport = await DynamicBenchmarker.master({\n    servant: `${__dirname}/servant.js`,\n    count: options.count,\n    threads: options.threads,\n    simultaneous: options.simultaneous,\n    filter: (func) =>\n      (!options.include?.length ||\n        (options.include ?? []).some((str) => func.includes(str))) &&\n      (!options.exclude?.length ||\n        (options.exclude ?? []).every((str) => !func.includes(str))),\n    progress: (value: number) => {\n      if (value >= 100 + prev.value) {\n        bar.update(value);\n        prev.value = value;\n      }\n    },\n    stdio: \"ignore\",\n  });\n  bar.stop();\n\n  // DOCUMENTATION\n  try {\n    await fs.promises.mkdir(`${MyConfiguration.ROOT}/docs/benchmarks`, {\n      recursive: true,\n    });\n  } catch {}\n  await fs.promises.writeFile(\n    `${MyConfiguration.ROOT}/docs/benchmarks/${os\n      .cpus()[0]\n      .model.trim()\n      .split(\"\\\\\")\n      .join(\"\")\n      .split(\"/\")\n      .join(\"\")}.md`,\n    DynamicBenchmarker.markdown(report),\n    \"utf8\",\n  );\n\n  // CLOSE\n  await backend.close();\n};\nmain().catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/benchmark/servant.ts": "import { DynamicBenchmarker } from \"@nestia/benchmark\";\n\nimport { MyConfiguration } from \"../../src/MyConfiguration\";\n\nDynamicBenchmarker.servant({\n  connection: {\n    host: `http://127.0.0.1:${MyConfiguration.API_PORT()}`,\n  },\n  location: `${__dirname}/../features`,\n  parameters: (connection) => [connection],\n  prefix: \"test_api_\",\n}).catch((exp) => {\n  console.error(exp);\n  process.exit(-1);\n});\n",
      "test/helpers/ArgumentParser.ts": "import commander from \"commander\";\nimport * as inquirer from \"inquirer\";\n\nexport namespace ArgumentParser {\n  export type Inquiry<T> = (\n    command: commander.Command,\n    prompt: (opt?: inquirer.StreamOptions) => inquirer.PromptModule,\n    action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n  ) => Promise<T>;\n\n  export interface Prompt {\n    select: (\n      name: string,\n    ) => (\n      message: string,\n    ) => <Choice extends string>(choices: Choice[]) => Promise<Choice>;\n    boolean: (name: string) => (message: string) => Promise<boolean>;\n    number: (name: string) => (message: string) => Promise<number>;\n  }\n\n  export const parse = async <T,>(\n    inquiry: (\n      command: commander.Command,\n      prompt: Prompt,\n      action: (closure: (options: Partial<T>) => Promise<T>) => Promise<T>,\n    ) => Promise<T>,\n  ): Promise<T> => {\n    // TAKE OPTIONS\n    const action = (closure: (options: Partial<T>) => Promise<T>) =>\n      new Promise<T>((resolve, reject) => {\n        commander.program.action(async (options) => {\n          try {\n            resolve(await closure(options));\n          } catch (exp) {\n            reject(exp);\n          }\n        });\n        commander.program.parseAsync().catch(reject);\n      });\n\n    const select =\n      (name: string) =>\n      (message: string) =>\n      async <Choice extends string>(choices: Choice[]): Promise<Choice> =>\n        (\n          await inquirer.createPromptModule()({\n            type: \"list\",\n            name,\n            message,\n            choices,\n          })\n        )[name];\n    const boolean = (name: string) => async (message: string) =>\n      (\n        await inquirer.createPromptModule()({\n          type: \"confirm\",\n          name,\n          message,\n        })\n      )[name] as boolean;\n    const number = (name: string) => async (message: string) =>\n      Number(\n        (\n          await inquirer.createPromptModule()({\n            type: \"number\",\n            name,\n            message,\n          })\n        )[name],\n      );\n\n    const output: T | Error = await (async () => {\n      try {\n        return await inquiry(\n          commander.program,\n          { select, boolean, number },\n          action,\n        );\n      } catch (error) {\n        return error as Error;\n      }\n    })();\n\n    // RETURNS\n    if (output instanceof Error) throw output;\n    return output;\n  };\n}\n",
      "test/index.ts": "import { MyBackend } from \"../src/MyBackend\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: MyBackend = new MyBackend();\n      await backend.open();\n      return backend;\n    },\n    close: (backend) => backend.close(),\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "test/tsconfig.json": "{\n  \"extends\": \"../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"../bin\",\n  },\n  \"include\": [\".\", \"../src\"]\n}",
      "test/webpack.ts": "import cp from \"child_process\";\nimport { sleep_for } from \"tstl\";\n\nimport { MyConfiguration } from \"../src/MyConfiguration\";\nimport { MyGlobal } from \"../src/MyGlobal\";\nimport { TestAutomation } from \"./TestAutomation\";\n\nconst wait = async (): Promise<void> => {\n  while (true)\n    try {\n      await fetch(`http://localhost:${MyConfiguration.API_PORT()}/dsafdsafsd`);\n      return;\n    } catch (exp) {\n      await sleep_for(100);\n    }\n};\n\nconst main = async (): Promise<void> => {\n  MyGlobal.testing = true;\n  await TestAutomation.execute({\n    open: async () => {\n      const backend: cp.ChildProcess = cp.fork(\n        `${MyConfiguration.ROOT}/dist/server.js`,\n        {\n          cwd: `${MyConfiguration.ROOT}/dist`,\n        },\n      );\n      await wait();\n      return backend;\n    },\n    close: async (backend) => {\n      backend.kill();\n    },\n  });\n};\nmain().catch((exp) => {\n  console.log(exp);\n  process.exit(-1);\n});\n",
      "/tsconfig.json": "{\n  \"compilerOptions\": {\n    /* Visit https://aka.ms/tsconfig to read more about this file */\n\n    /* Projects */\n    // \"incremental\": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */\n    // \"composite\": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */\n    // \"tsBuildInfoFile\": \"./.tsbuildinfo\",              /* Specify the path to .tsbuildinfo incremental compilation file. */\n    // \"disableSourceOfProjectReferenceRedirect\": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */\n    // \"disableSolutionSearching\": true,                 /* Opt a project out of multi-project reference checking when editing. */\n    // \"disableReferencedProjectLoad\": true,             /* Reduce the number of projects loaded automatically by TypeScript. */\n\n    /* Language and Environment */\n    \"target\": \"ES2015\",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */\n    // \"lib\": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */\n    // \"jsx\": \"preserve\",                                /* Specify what JSX code is generated. */\n    \"experimentalDecorators\": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */\n    \"emitDecoratorMetadata\": true,                    /* Emit design-type metadata for decorated declarations in source files. */\n    // \"jsxFactory\": \"\",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */\n    // \"jsxFragmentFactory\": \"\",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */\n    // \"jsxImportSource\": \"\",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */\n    // \"reactNamespace\": \"\",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */\n    // \"noLib\": true,                                    /* Disable including any library files, including the default lib.d.ts. */\n    // \"useDefineForClassFields\": true,                  /* Emit ECMAScript-standard-compliant class fields. */\n    // \"moduleDetection\": \"auto\",                        /* Control what method is used to detect module-format JS files. */\n\n    /* Modules */\n    \"module\": \"commonjs\",                                /* Specify what module code is generated. */\n    // \"rootDir\": \"./\",                                  /* Specify the root folder within your source files. */\n    // \"moduleResolution\": \"node\",                       /* Specify how TypeScript looks up a file from a given module specifier. */\n    // \"baseUrl\": \"./\",                                  /* Specify the base directory to resolve non-relative module names. */\n    \"paths\": {\n      \"@ORGANIZATION/PROJECT-api/lib/*\": [\"./src/api/*\"],\n      \"@ORGANIZATION/PROJECT-api\": [\"./src/api\"],\n    },                                      /* Specify a set of entries that re-map imports to additional lookup locations. */\n    // \"rootDirs\": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */\n    // \"typeRoots\": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */\n    // \"types\": [],                                      /* Specify type package names to be included without being referenced in a source file. */\n    // \"allowUmdGlobalAccess\": true,                     /* Allow accessing UMD globals from modules. */\n    // \"moduleSuffixes\": [],                             /* List of file name suffixes to search when resolving a module. */\n    // \"resolveJsonModule\": true,                        /* Enable importing .json files. */\n    // \"noResolve\": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */\n\n    /* JavaScript Support */\n    // \"allowJs\": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */\n    // \"checkJs\": true,                                  /* Enable error reporting in type-checked JavaScript files. */\n    // \"maxNodeModuleJsDepth\": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */\n\n    /* Emit */\n    // \"declaration\": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */\n    // \"declarationMap\": true,                           /* Create sourcemaps for d.ts files. */\n    // \"emitDeclarationOnly\": true,                      /* Only output d.ts files and not JavaScript files. */\n    \"sourceMap\": true,                                /* Create source map files for emitted JavaScript files. */\n    // \"outFile\": \"./\",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */\n    \"outDir\": \"./lib\",                                   /* Specify an output folder for all emitted files. */\n    // \"removeComments\": true,                           /* Disable emitting comments. */\n    // \"noEmit\": true,                                   /* Disable emitting files from a compilation. */\n    // \"importHelpers\": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */\n    // \"importsNotUsedAsValues\": \"remove\",               /* Specify emit/checking behavior for imports that are only used for types. */\n    // \"downlevelIteration\": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */\n    // \"sourceRoot\": \"\",                                 /* Specify the root path for debuggers to find the reference source code. */\n    // \"mapRoot\": \"\",                                    /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,                          /* Include sourcemap files inside the emitted JavaScript. */\n    // \"inlineSources\": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */\n    // \"emitBOM\": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */\n    \"newLine\": \"lf\",                                /* Set the newline character for emitting files. */\n    \"stripInternal\": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */\n    // \"noEmitHelpers\": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */\n    // \"noEmitOnError\": true,                            /* Disable emitting files if any type checking errors are reported. */\n    // \"preserveConstEnums\": true,                       /* Disable erasing 'const enum' declarations in generated code. */\n    // \"declarationDir\": \"./\",                           /* Specify the output directory for generated declaration files. */\n    // \"preserveValueImports\": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */\n\n    /* Interop Constraints */\n    // \"isolatedModules\": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */\n    // \"allowSyntheticDefaultImports\": true,             /* Allow 'import x from y' when a module doesn't have a default export. */\n    \"esModuleInterop\": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */\n    // \"preserveSymlinks\": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */\n    \"forceConsistentCasingInFileNames\": true,            /* Ensure that casing is correct in imports. */\n\n    /* Type Checking */\n    \"strict\": true,                                      /* Enable all strict type-checking options. */\n    // \"noImplicitAny\": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */\n    // \"strictNullChecks\": true,                         /* When type checking, take into account 'null' and 'undefined'. */\n    // \"strictFunctionTypes\": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */\n    // \"strictBindCallApply\": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */\n    // \"strictPropertyInitialization\": true,             /* Check for class properties that are declared but not set in the constructor. */\n    // \"noImplicitThis\": true,                           /* Enable error reporting when 'this' is given the type 'any'. */\n    // \"useUnknownInCatchVariables\": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */\n    // \"alwaysStrict\": true,                             /* Ensure 'use strict' is always emitted. */\n    \"noUnusedLocals\": true,                           /* Enable error reporting when local variables aren't read. */\n    \"noUnusedParameters\": true,                       /* Raise an error when a function parameter isn't read. */\n    // \"exactOptionalPropertyTypes\": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */\n    \"noImplicitReturns\": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */\n    \"noFallthroughCasesInSwitch\": true,               /* Enable error reporting for fallthrough cases in switch statements. */\n    // \"noUncheckedIndexedAccess\": true,                 /* Add 'undefined' to a type when accessed using an index. */\n    // \"noImplicitOverride\": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */\n    // \"noPropertyAccessFromIndexSignature\": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */\n    // \"allowUnusedLabels\": true,                        /* Disable error reporting for unused labels. */\n    // \"allowUnreachableCode\": true,                     /* Disable error reporting for unreachable code. */\n\n    /* Completeness */\n    // \"skipDefaultLibCheck\": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */\n    \"skipLibCheck\": true,                                 /* Skip type checking all .d.ts files. */\n    \"plugins\": [\n      { \"transform\": \"typescript-transform-paths\" },\n      { \"transform\": \"typia/lib/transform\" },\n      { \n        \"transform\": \"@nestia/core/lib/transform\",\n        /**\n         * Validate request body.\n         * \n         *   - \"assert\": Use typia.assert() function\n         *   - \"is\": Use typia.is() function\n         *   - \"validate\": Use typia.validate() function\n         *   - \"assertEquals\": Use typia.assertEquals() function\n         *   - \"equals\": Use typia.equals() function\n         *   - \"validateEquals\": Use typia.validateEquals() function\n         */\n        \"validate\": \"validate\",\n        /**\n         * Validate JSON typed response body.\n         * \n         *   - \"assert\": Use typia.assertStringify() function\n         *   - \"is\": Use typia.isStringify() function\n         *   - \"validate\": Use typia.validateStringify() function\n         *   - \"validate.log\": typia.validateStringify(), but do not throw and just log it\n         *   - \"stringify\": Use typia.stringify() function, but dangerous\n         *   - null: Just use JSON.stringify() function, without boosting\n         */\n        \"stringify\": \"assert\",\n      },\n    ]\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"packages\",\n  ]\n}\n",
      "/typos.toml": "[default]\nlocale = 'en-us'\nextend-ignore-re = [\n  \"(?Rm)^.*(<!--|#|//)\\\\s*spellchecker:disable-line(-->|\\n)?$\",\n  \"(?s)(<!--|#|//)\\\\s*spellchecker:off\\\\s*(-->|\\n).*?(<!--|#|//)\\\\s*spellchecker:on\",\n]\n\n[default.extend-words]\nJeongho = \"Jeongho\"\nNam = \"Nam\"\ntypia = \"typia\"\n\n[files]\nextend-exclude = [\"*.json\"]",
      "/webpack.config.js": "const path = require(\"path\");\n\nconst CopyWebpackPlugin = require(\"copy-webpack-plugin\");\nconst WriteFilePlugin = require(\"write-file-webpack-plugin\");\nconst { IgnorePlugin } = require(\"webpack\");\n\nconst lazyImports = [\n  \"@fastify/static\",\n  \"@fastify/view\",\n  \"@nestjs/microservices\",\n  \"@nestjs/websockets\",\n  \"class-transformer\",\n  \"class-validator\",\n];\n\n// @reference https://tech-blog.s-yoshiki.com/entry/297\nmodule.exports = {\n  // CUSTOMIZE HERE\n  entry: {\n    server: \"./src/executable/server.ts\",\n  },\n  output: {\n    path: path.join(__dirname, \"dist\"),\n    filename: \"[name].js\",\n  },\n  optimization: {\n    minimize: true,\n  },\n\n  // JUST KEEP THEM\n  mode: \"production\",\n  target: \"node\",\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        loader: \"ts-loader\",\n      },\n    ],\n  },\n  resolve: {\n    extensions: [\".tsx\", \".ts\", \".js\"],\n  },\n  plugins: [\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: \".env\",\n          to: \"[name][ext]\",\n        },\n        // {\n        //   from: \"./node_modules/.prisma/client/*.node\",\n        //   to: () => Promise.resolve(\"[path][name][ext]\"),\n        //   globOptions: {\n        //     dot: true,\n        //   },\n        // },\n      ],\n    }),\n    new WriteFilePlugin(),\n    new IgnorePlugin({\n      checkResource: (resource) => {\n        if (lazyImports.some((modulo) => resource.startsWith(modulo))) {\n          try {\n            require.resolve(resource);\n          } catch (err) {\n            return true;\n          }\n        }\n        return false;\n      },\n    }),\n  ],\n};\n",
      "src/MyModule.ts": "import { Module } from \"@nestjs/common\";\n\nimport { BbsArticlesController } from \"./controllers/bbs/articles/BbsArticlesController\";\nimport { BbsArticlesSnapshotsController } from \"./controllers/bbs/articles/snapshots/BbsArticlesSnapshotsController\";\nimport { BbsArticlesCommentsController } from \"./controllers/bbs/articles/comments/BbsArticlesCommentsController\";\nimport { BbsArticlesCommentsSnapshotsController } from \"./controllers/bbs/articles/comments/snapshots/BbsArticlesCommentsSnapshotsController\";\nimport { AttachmentfilesController } from \"./controllers/attachmentFiles/AttachmentfilesController\";\n\n@Module({\n  controllers: [\n    BbsArticlesController,\n    BbsArticlesSnapshotsController,\n    BbsArticlesCommentsController,\n    BbsArticlesCommentsSnapshotsController,\n    AttachmentfilesController,\n  ],\n})\nexport class MyModule {}\n",
      "src/controllers/bbs/articles/BbsArticlesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"../../../api/structures/IBbsArticle\";\nimport { IPageIBbsArticle } from \"../../../api/structures/IPageIBbsArticle\";\n\n@Controller(\"/bbs/articles\")\nexport class BbsArticlesController {\n  /**\n   * Create a bulletin board article (bbs_articles + initial snapshot, with\n   * attachments).\n   *\n   * This endpoint allows a user to create a new bulletin board article. Upon\n   * invocation, a new record in bbs_articles is inserted, as well as a first\n   * snapshot in bbs_article_snapshots, containing the initial version's body,\n   * format, title, and IP address of the request. Attachments may also be\n   * uploaded and associated via attachment_files and\n   * bbs_article_snapshot_files junction.\n   *\n   * The author provides a writer name, password (which must be encrypted\n   * before storage), and content (title, body, format). An array of file\n   * metadata may also be included. This route enforces presence of all\n   * required fields and validates file upload if present.\n   *\n   * Security: Password is stored only as a hash; plaintext password must not\n   * be stored. All significant actions (including IP address capture) must be\n   * logged and linked to the snapshot. Failure scenarios include\n   * missing/invalid required fields, unsupported file types, or database\n   * errors. Related: Modification is handled via PUT /bbs/articles/{id};\n   * version retrieval by PATCH /bbs/articles/snapshots.\n   *\n   * @param body New article creation info including writer, password, initial\n   *   title and body, format, and optional file attachments.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IBbsArticle.ICreate,\n  ): Promise<IBbsArticle> {\n    body;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * List articles from bbs_articles with searching, pagination, and summary\n   * info.\n   *\n   * This API endpoint allows clients to retrieve a paginated, filtered,\n   * and/or sorted list of bulletin board articles. It references the\n   * bbs_articles table in Prisma, which holds basic post identity and author\n   * information, as well as deletion markers. Results typically include only\n   * non-deleted articles for general users (unless special admin permission\n   * is given).\n   *\n   * Each article summary should include the latest title (from the latest\n   * snapshot), author, creation time, and comment count. Filters may include\n   * search by title, author, date ranges, and possibly presence of comments.\n   * The endpoint should work efficiently by leveraging indexes on created_at\n   * and deleted_at for best performance. Soft-deleted posts are omitted\n   * except for admin access.\n   *\n   * Request parameters support pagination with cursor/limit or offset/limit.\n   * Security: Access to deleted articles may depend on user role; listing of\n   * all (including deleted) may require admin level. Related API operation:\n   * GET /bbs/articles/{id} for detailed information. Errors for invalid\n   * search parameters, forbidden access, or server errors follow consistent\n   * patterns.\n   *\n   * @param body Request parameters for listing articles, including filters\n   *   (title, author, date), pagination (cursor/limit or offset/limit), and\n   *   sorting options.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsArticle.IRequest,\n  ): Promise<IPageIBbsArticle.ISummary> {\n    body;\n    return typia.random<IPageIBbsArticle.ISummary>();\n  }\n\n  /**\n   * Get detail on a single article (bbs_articles & latest snapshot,\n   * attachments, safe info).\n   *\n   * This endpoint retrieves all information required for a specific article,\n   * given its unique id (UUID). It uses the bbs_articles table to obtain\n   * author, creation time, and status (deleted or not). The latest version is\n   * provided by linking to the most recent bbs_article_snapshots record,\n   * including title, body, and format. Attachments related to the latest\n   * snapshot are also returned.\n   *\n   * If the article is soft-deleted, its access may be restricted to\n   * admin-level or special permission users. IP information may be redacted\n   * for standard users to enhance privacy. The endpoint returns an error if\n   * the id is invalid or the article does not exist. This operation does not\n   * modify the database and is considered safe for client retrieval.\n   *\n   * Related API: PATCH /bbs/articles for the listing. Errors adhere to the\n   * API's standard error response structure.\n   *\n   * @param id The article's unique identifier (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticle> {\n    id;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * Modify an article (bbs_articles): add snapshot and optionally modify\n   * attachments.\n   *\n   * This endpoint enables the modification of a previously created article.\n   * Modifications do not overwrite existing articles but result in a new\n   * record in bbs_article_snapshots linked to the same article. It enforces\n   * password verification against the article's hashed password before\n   * proceeding. Authors can change the title, body, body format, and update\n   * attachments through this operation.\n   *\n   * The endpoint requires the article id, the writer's password (to be\n   * verified), and the new content. Attachments can be modified (added,\n   * removed, reordered) by specifying their metadata. If the password is\n   * invalid or missing, the operation fails with an appropriate error. Only\n   * non-deleted articles can be modified unless special permissions are\n   * given.\n   *\n   * Security: Store IP address and record the modification time. Existing\n   * snapshots remain immutable to preserve evidence/history. Updates to\n   * associated attachments create new junction entries for the new snapshot.\n   * Related API: GET /bbs/articles/{id} to fetch new version, PATCH\n   * /bbs/articles/snapshots to list all versions. All error and success\n   * responses follow universal API schema.\n   *\n   * @param id Article's unique identifier (UUID) to update.\n   * @param body Update info for an article, including new title/body/format,\n   *   re-attachment info, and password verification.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.IUpdate,\n  ): Promise<IBbsArticle> {\n    id;\n    body;\n    return typia.random<IBbsArticle>();\n  }\n\n  /**\n   * Soft-delete (logical delete) a bulletin board article. Only marks\n   * deleted_at, no physical removal.\n   *\n   * This endpoint is for logically deleting an existing bulletin board\n   * article. It only marks the deleted_at field with the current timestamp,\n   * preserving the record for evidence and possible future administrative\n   * review. The request must include password verification for standard\n   * users; admin users may delete without password depending on\n   * config/policy. If the password is invalid or missing, the deletion will\n   * fail.\n   *\n   * Logically deleted articles are not shown in public lists but are still\n   * accessible for admin/forensic reasons. Physical deletion is never\n   * performed to maintain history. Errors are returned if the article is not\n   * found, already deleted, or password is incorrect. The operation records\n   * who (user, IP) deleted the item.\n   *\n   * @param id Article's unique identifier (UUID) to soft-delete.\n   * @param body Password for soft-deletion verification if not admin. Admins\n   *   may bypass password check.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticle.IDelete,\n  ): Promise<IBbsArticle> {\n    id;\n    body;\n    return typia.random<IBbsArticle>();\n  }\n}\n",
      "src/controllers/bbs/articles/snapshots/BbsArticlesSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleSnapshot } from \"../../../../api/structures/IPageIBbsArticleSnapshot\";\nimport { IBbsArticleSnapshot } from \"../../../../api/structures/IBbsArticleSnapshot\";\n\n@Controller(\"/bbs/articles/snapshots\")\nexport class BbsArticlesSnapshotsController {\n  /**\n   * List (paged) article snapshots from bbs_article_snapshots, filter by\n   * article id, etc.\n   *\n   * This endpoint provides a paginated, filterable, and sortable list of all\n   * article snapshots (historical versions), from the bbs_article_snapshots\n   * Prisma table. Clients can use this to access the full modification\n   * history for articles.\n   *\n   * Search/explore versions by article id, creation time, writer IP, format,\n   * or keywords in title/body; efficient index access is required for\n   * performance. Pagination parameters are mandatory for scalability with\n   * growing history. Deleted articles' snapshots may be accessible to admins\n   * only. For standard users, only versions for non-deleted articles are\n   * returned. Snapshots include all version metadata (format, title, body,\n   * created_at, IP) and attachment references.\n   *\n   * Related API: PATCH /bbs/articles for article overviews, GET\n   * /bbs/articles/snapshots/{id} for version detail.\n   *\n   * @param body Snapshot search parameters: filters for article id, date\n   *   ranges, IP, body/title keywords; plus pagination info.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsArticleSnapshot.IRequest,\n  ): Promise<IPageIBbsArticleSnapshot.ISummary> {\n    body;\n    return typia.random<IPageIBbsArticleSnapshot.ISummary>();\n  }\n\n  /**\n   * Get details of one article snapshot (version), including all metadata and\n   * its attachments.\n   *\n   * This operation returns the full metadata for a specified article snapshot\n   * (by UUID), including all version metadata (title, body, format,\n   * created_at, IP address) and linked attachment file info. It is typically\n   * used to view historical versions of an article for evidence or audit\n   * purposes.\n   *\n   * Appropriate authorization may be required if the snapshot is for an\n   * article that has been deleted or is restricted. Errors are returned for\n   * non-existent IDs or unauthorized access. IP addresses may only be visible\n   * to admins. No modification of state occurs here.\n   *\n   * Security: Carefully audit access to preserve privacy. Related: POST/PATCH\n   * to list versions, parent article access via GET /bbs/articles/{id}. Error\n   * responses standardized.\n   *\n   * @param id Snapshot's unique identifier (UUID).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleSnapshot> {\n    id;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n\n  /**\n   * Modify snapshot record's metadata (admin/forensic use only), not the\n   * actual version content.\n   *\n   * This admin-facing endpoint (rarely exposed to end-users) allows for\n   * partial updates (e.g., tagging or meta-corrections) to a specific\n   * snapshot record, identified by its UUID. Typical users will not modify\n   * snapshots (snapshots are append-only); this is for exceptional forensic\n   * or administrative cases.\n   *\n   * Permitted updates may include internal metadata such as status tagging or\n   * moderation flags, but NOT revision of original title/body/IP, to preserve\n   * evidence. Access strictly controlled; all actions audited. Operation\n   * rejected if forbidden fields are attempted to be changed or user is\n   * unauthorized. Related: GET /bbs/articles/snapshots/{id} for version\n   * details.\n   *\n   * @param id Snapshot's UUID.\n   * @param body Patch request for allowed snapshot metadata fields (typ.\n   *   tagging/status/mod notes).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleSnapshot.IUpdate,\n  ): Promise<IBbsArticleSnapshot> {\n    id;\n    body;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n\n  /**\n   * Permanently delete an article snapshot (admin maintenance/correction\n   * use), not for public users.\n   *\n   * This highly restricted endpoint allows physical deletion of a single\n   * article snapshot by its UUID. Typically, this would only be permitted in\n   * cases of evidence tampering, privacy requests, or system maintenance.\n   * Regular users have no access.\n   *\n   * The operation removes the historical version and updates all connected\n   * records accordingly. Audit logs should capture all deletions.\n   * Invalid/dependent snapshot deletion attempts result in errors. Recognize\n   * that removing a snapshot could compromise historical integrity, so\n   * authorization and safety nets must be ensured. Related: GET for details,\n   * PATCH for list.\n   *\n   * @param id Snapshot's UUID.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleSnapshot> {\n    id;\n    return typia.random<IBbsArticleSnapshot>();\n  }\n}\n",
      "src/controllers/bbs/articles/comments/BbsArticlesCommentsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedParam, TypedBody } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"../../../../api/structures/IBbsArticleComment\";\nimport { IPageIBbsArticleComment } from \"../../../../api/structures/IPageIBbsArticleComment\";\n\n@Controller(\"/bbs/articles/:articleId/comments\")\nexport class BbsArticlesCommentsController {\n  /**\n   * Create a new comment or reply to an article, supporting nesting and\n   * attachments. Snapshots required for history.\n   *\n   * Enables the creation of a new comment (reply or root) on a specific\n   * article, specified by articleId. A record is inserted into\n   * bbs_article_comments along with a corresponding first snapshot in\n   * bbs_article_comment_snapshots (body, format, IP). This supports direct\n   * comments or reply chains by specifying parent_id in the body (for nested\n   * comments).\n   *\n   * Comment must include writer, password (stored securely via hash), body,\n   * format, and can optionally reference files. Enforces required fields,\n   * validates permissions, checks nesting rules. Upon creation, the first\n   * snapshot is linked and metadata set. Logical deletion applies for future\n   * removal, not on creation.\n   *\n   * Security: All actions (IP, times) are audited; sensitive data such as\n   * passwords are hashed before storage. Failure triggers: missing/invalid\n   * params, wrong parent/article ID, DB errors. Related: PATCH for comment\n   * list; GET for comment details.\n   *\n   * @param articleId UUID of the article to comment on.\n   * @param body New comment info: writer, password, body, format, parent_id\n   *   (for reply), optional attachments.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async postByArticleid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.ICreate,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    body;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * Get a paginated and hierarchical list of comments for an article, showing\n   * current body.\n   *\n   * This endpoint provides retrieval of a hierarchical, paginated, and\n   * searchable/commentable list of comments related to a particular article.\n   * Queries bbs_article_comments table for all comments (excluding deleted\n   * unless admin), joined with their latest snapshot record for current\n   * body/display (from bbs_article_comment_snapshots). Supports threaded\n   * replies with unlimited depth via parent_id.\n   *\n   * Filters include parent_id (for fetching root comments or replies), writer\n   * name, creation time, and support for pagination for large inputs. By\n   * default, only non-deleted comments are returned. Role-based logic may\n   * allow access to deleted comments for admins. Sorting can include time or\n   * hierarchy order.\n   *\n   * Efficient tree retrieval is required for good performance with nesting.\n   * Related endpoints: POST for new comment; GET\n   * /bbs/articles/{articleId}/comments/{id} for comment detail.\n   *\n   * @param articleId Article UUID for which to fetch comments.\n   * @param body Comment list request parameters: pagination, optional\n   *   parent_id for segment, or search filters.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patchByArticleid(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.IRequest,\n  ): Promise<IPageIBbsArticleComment.ISummary> {\n    articleId;\n    body;\n    return typia.random<IPageIBbsArticleComment.ISummary>();\n  }\n\n  /**\n   * Get full details (including snapshot, attachments, and hierarchy) for one\n   * comment on an article.\n   *\n   * This endpoint fetches the full details for a single comment on a given\n   * article. Accepts the articleId for context and the comment's uuid as id.\n   * Joins the bbs_article_comments table (for metadata, writer, deletion\n   * status) with latest snapshot (from bbs_article_comment_snapshots) for\n   * body/format. Also fetches attachment info for the snapshot.\n   *\n   * Details include: creation and (if) deletion timestamps, author, format,\n   * body, all attachments for the most recent version, parent/child info for\n   * replies, and optional list of immediate child comment IDs (to facilitate\n   * threaded UIs). Deleted comments are shown only with special permission\n   * (admin). If not found or not permitted, appropriate error returns.\n   *\n   * Related: PATCH for listing, POST for creation. Error codes are\n   * standardized across comment operations.\n   *\n   * @param articleId The article UUID where the comment belongs.\n   * @param id Comment's UUID to consult.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * Update existing comment information in 'bbs_article_comments' for a given\n   * article and comment.\n   *\n   * This API endpoint allows a user to update a specific comment in the\n   * bulletin board system while maintaining a snapshot of the modification\n   * for evidence. The operation is secured by requiring the correct password\n   * for comment modification, as dictated by the system's security policy. On\n   * execution, a new snapshot will be generated, storing the old version and\n   * the modifying client's IP address, as per the evidential design. Only\n   * non-deleted comments are modifiable; comments previously soft-deleted\n   * (deleted_at set) will be rejected.\n   *\n   * Validation rules enforce existence of the referenced article and comment,\n   * correct hierarchical relationships for nested replies, required fields,\n   * and adherence to data consistency regarding attachments and format. The\n   * operation also ensures that password hashes are compared and never\n   * exposed in the API, supporting encrypted password storage.\n   *\n   * This endpoint is related to: GET /bbs/articles/{articleId}/comments/{id}\n   * (fetch detail), POST /bbs/articles/{articleId}/comments (creation), and\n   * DELETE /bbs/articles/{articleId}/comments/{id} (logical deletion). Error\n   * responses include unauthorized modification, resource not found, and\n   * input validation failures.\n   *\n   * @param articleId Target article's ID\n   * @param id Target comment's ID\n   * @param body Updated data for the comment. Requires writer and password\n   *   for authentication, and allows update of body/content fields.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.IUpdate,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    body;\n    return typia.random<IBbsArticleComment>();\n  }\n\n  /**\n   * Logically delete a comment (set deleted_at) in 'bbs_article_comments' for\n   * a given article and comment ID.\n   *\n   * This endpoint marks a specified comment under a particular article as\n   * deleted (soft delete). In accordance with the requirements, the comment\n   * is not physically removed, but its 'deleted_at' field is set to the\n   * current timestamp. If the supplied password does not match or the comment\n   * is already deleted, an error is returned. All historical snapshots for\n   * the comment are preserved, ensuring the full audit log needed for dispute\n   * resolution.\n   *\n   * The endpoint performs validation for the existence of both the article\n   * and comment, ensures correct authorization (password validation), and\n   * returns the final comment record reflecting the logical deletion. This\n   * supports system requirements for evidence retention and access control\n   * for administrators.\n   *\n   * @param articleId Target article's ID\n   * @param id Target comment's ID\n   * @param body Password required for logical deletion/authentication.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseByArticleidAndId(\n    @TypedParam(\"articleId\")\n    articleId: string & tags.Format<\"uuid\">,\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleComment.IDelete,\n  ): Promise<IBbsArticleComment> {\n    articleId;\n    id;\n    body;\n    return typia.random<IBbsArticleComment>();\n  }\n}\n",
      "src/controllers/bbs/articles/comments/snapshots/BbsArticlesCommentsSnapshotsController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleCommentSnapshot } from \"../../../../../api/structures/IPageIBbsArticleCommentSnapshot\";\nimport { IBbsArticleCommentSnapshot } from \"../../../../../api/structures/IBbsArticleCommentSnapshot\";\n\n@Controller(\"/bbs/articles/comments/snapshots\")\nexport class BbsArticlesCommentsSnapshotsController {\n  /**\n   * Retrieve a paginated list of comment snapshot records from\n   * 'bbs_article_comment_snapshots'.\n   *\n   * This API operation retrieves a filtered and/or paginated list of comment\n   * snapshot records, representing the edit histories for comments. It serves\n   * both evidence management (viewing revision history) and administrative\n   * oversight (monitoring modifications and IP addresses). Supports filters\n   * for attributes such as comment ID(s), date range, format, or other\n   * metadata.\n   *\n   * The endpoint enables clients to efficiently perform evidence review,\n   * discover all edits for a given comment or set of comments, and optionally\n   * aggregate statistics or metadata as needed. Error handling includes\n   * invalid filter criteria, pagination issues, or lack of results for the\n   * requested conditions.\n   *\n   * @param body Filtering and pagination parameters for searching comment\n   *   snapshots.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IBbsArticleCommentSnapshot.IRequest,\n  ): Promise<IPageIBbsArticleCommentSnapshot> {\n    body;\n    return typia.random<IPageIBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Fetch detail information for a single comment snapshot by ID from\n   * 'bbs_article_comment_snapshots'.\n   *\n   * This endpoint fetches detailed information about a single comment\n   * snapshot, uniquely identified by its ID. It exposes all evidential\n   * attributes: body, format, creation time, IP address of the modifier, and\n   * linkage to its comment and parent article.\n   *\n   * Intended for history management screens or audit review, it supports full\n   * details, including attached file metadata, and can be used to display\n   * previous comment versions or investigate disputes. Related endpoints are\n   * PATCH /bbs/articles/comments/snapshots (for list/search) and PUT\n   * /bbs/articles/comments/snapshots/{id} (for administrative corrections, if\n   * permitted). Error handling includes resource not found, or access denied\n   * if applicable.\n   *\n   * @param id Target comment snapshot's ID.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IBbsArticleCommentSnapshot> {\n    id;\n    return typia.random<IBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Update specific snapshot attributes in 'bbs_article_comment_snapshots',\n   * primarily for admin use.\n   *\n   * This endpoint permits authorized administrative actors to update certain\n   * attributes of a comment snapshot, such as correcting metadata errors or\n   * annotating revisions, without breaking the snapshot audit chain. Input\n   * validation ensures that evidence integrity is not violated (for example,\n   * core content cannot be retroactively altered by general users). The\n   * endpoint is intended for corrective or special administrative functions.\n   *\n   * Security is enforced by access control: only privileged accounts may\n   * utilize this endpoint, and attempted use by general users will result in\n   * authorization errors. Error handling includes not found, insufficient\n   * rights, and input validation failures. Related operations include GET\n   * /bbs/articles/comments/snapshots/{id} (for reading) and PATCH\n   * /bbs/articles/comments/snapshots (for search/listing).\n   *\n   * @param id Target comment snapshot's ID.\n   * @param body Fields for administrative update of the snapshot. Restricted\n   *   to allowable attributes only.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleCommentSnapshot.IUpdate,\n  ): Promise<IBbsArticleCommentSnapshot> {\n    id;\n    body;\n    return typia.random<IBbsArticleCommentSnapshot>();\n  }\n\n  /**\n   * Logically delete a comment snapshot in 'bbs_article_comment_snapshots' by\n   * ID, for admin use only.\n   *\n   * This endpoint marks a comment snapshot as deleted (usually via a logical\n   * delete flag or 'deleted_at' timestamp, in line with the overall evidence\n   * preservation policy). Physical deletion from the database is forbidden;\n   * the operation is reserved for administrators or regulatory compliance\n   * requirements only. Related files and linkages remain for audit\n   * traceability.\n   *\n   * Attempts to use this endpoint without sufficient privilege are denied.\n   * Related endpoints include GET /bbs/articles/comments/snapshots/{id} (for\n   * reading), PUT /bbs/articles/comments/snapshots/{id} (for administrative\n   * update), and DELETE /bbs/articles/comments/snapshots/{id} for logical\n   * removal. Error responses occur for not found, insufficient rights, and\n   * policy violations.\n   *\n   * @param id Target comment snapshot's ID.\n   * @param body Administrative request to logically delete the given comment\n   *   snapshot. Only privileged users allowed.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IBbsArticleCommentSnapshot.IDelete,\n  ): Promise<IBbsArticleCommentSnapshot> {\n    id;\n    body;\n    return typia.random<IBbsArticleCommentSnapshot>();\n  }\n}\n",
      "src/controllers/attachmentFiles/AttachmentfilesController.ts": "import { Controller } from \"@nestjs/common\";\nimport { TypedRoute, TypedBody, TypedParam } from \"@nestia/core\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"../../api/structures/IAttachmentFile\";\nimport { IPageIAttachmentFile } from \"../../api/structures/IPageIAttachmentFile\";\n\n@Controller(\"/attachmentFiles\")\nexport class AttachmentfilesController {\n  /**\n   * Register a new attachment file in 'attachment_files' with all required\n   * metadata.\n   *\n   * This endpoint registers a new file after upload by inserting its key\n   * metadata into the 'attachment_files' schema table. It records the file\n   * name, extension (if any), URL, and the creation date. Input validation\n   * ensures file name and URL are present, extension is allowed or nullable,\n   * and that no collisions occur for unique IDs. File upload should be\n   * processed prior to this call, which is only for metadata registration and\n   * not for the binary upload process itself.\n   *\n   * The endpoint is often called by UI file upload interfaces before\n   * associating the file with posts/comments. Errors may include invalid\n   * input, file type restrictions, or unique constraint violations on file\n   * ID.\n   *\n   * @param body Attachment file registration information (metadata only,\n   *   upload handled separately).\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Post()\n  public async post(\n    @TypedBody()\n    body: IAttachmentFile.ICreate,\n  ): Promise<IAttachmentFile> {\n    body;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Get a paginated/searchable list of attachment files from\n   * 'attachment_files'.\n   *\n   * This API operation returns a list of all attachment files stored within\n   * the system, with optional filters for name, extension, and creation date.\n   * Its main use cases involve browsing available files, administratively\n   * locating uploaded materials, and supplying metadata for attachment\n   * management operations (e.g., linking files to post/comment snapshots).\n   *\n   * Results support pagination, sorting, and advanced search conditions.\n   * Error handling ensures proper response to invalid search parameters and\n   * out-of-bounds pagination values.\n   *\n   * @param body Filtering and pagination options for searching attachment\n   *   files.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Patch()\n  public async patch(\n    @TypedBody()\n    body: IAttachmentFile.IRequest,\n  ): Promise<IPageIAttachmentFile> {\n    body;\n    return typia.random<IPageIAttachmentFile>();\n  }\n\n  /**\n   * Fetch information for a single attachment file by ID from\n   * 'attachment_files'.\n   *\n   * This API operation fetches the details of an individual attachment file\n   * by its unique ID. It returns all metadata (name, extension, URL, creation\n   * time), and can include cross-references to snapshots where used. Used in\n   * file management screens, attachment UI, or for audit purposes.\n   *\n   * The endpoint validates the existence of the requested file and returns an\n   * informative error if not found. Related endpoints include PATCH\n   * /attachmentFiles (for listing) and DELETE /attachmentFiles/{id} (for\n   * deletion).\n   *\n   * @param id Target attachment file's ID.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Get(\":id\")\n  public async getById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n  ): Promise<IAttachmentFile> {\n    id;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Update metadata of an attachment file in 'attachment_files' (admin only).\n   *\n   * This endpoint updates fields such as the filename, extension, or other\n   * attributes for an attachment file already present in the database.\n   * Authorization is required (typically admin-level) to prevent accidental\n   * or malicious alteration of shared files. Validation ensures referential\n   * integrity with linked snapshots and prevents breaking links. Only fields\n   * allowed for update by business logic can be altered; changes to URL or\n   * creation dates may be restricted.\n   *\n   * Error handling addresses non-existent files, permission errors, and\n   * attempts to update disallowed fields. Related endpoints: GET\n   * /attachmentFiles/{id} (for reading), PATCH /attachmentFiles (for\n   * listing), and DELETE /attachmentFiles/{id} (for deletion).\n   *\n   * @param id Target attachment file's ID.\n   * @param body Fields for updating information about the attachment file.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Put(\":id\")\n  public async putById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IAttachmentFile.IUpdate,\n  ): Promise<IAttachmentFile> {\n    id;\n    body;\n    return typia.random<IAttachmentFile>();\n  }\n\n  /**\n   * Logically delete an attachment file by ID in 'attachment_files' (admin\n   * only, prevents deletion if referenced).\n   *\n   * This endpoint marks an attachment file as logically deleted (typically by\n   * setting a flag or deletion timestamp) to preserve auditability and avoid\n   * removing files that may still be linked from evidence snapshots. Actual\n   * file removal from storage, if any, is beyond the scope of this endpoint.\n   * Authorization is enforced for only privileged users (like admins) to use\n   * this endpoint.\n   *\n   * Before deletion, the system checks that the file is not referenced by any\n   * snapshots to prevent orphaning or evidence loss. Any deletion attempt for\n   * files still in use results in an error. Related endpoints: PUT\n   * /attachmentFiles/{id} (for update) and GET /attachmentFiles/{id} (for\n   * reading).\n   *\n   * @param id Target attachment file's ID.\n   * @param body Logical deletion request for attachment file, with admin\n   *   authorization.\n   * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n   */\n  @TypedRoute.Delete(\":id\")\n  public async eraseById(\n    @TypedParam(\"id\")\n    id: string & tags.Format<\"uuid\">,\n    @TypedBody()\n    body: IAttachmentFile.IDelete,\n  ): Promise<IAttachmentFile> {\n    id;\n    body;\n    return typia.random<IAttachmentFile>();\n  }\n}\n",
      "src/api/structures/IBbsArticle.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"./IBbsArticleSnapshot\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Full representation of a bulletin board article, including metadata, current\n * version info, comments count, and attachments.\n *\n * Combines bbs_articles with latest bbs_article_snapshots and relevant\n * relationships.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticle = {\n  /**\n   * Unique identifier for the article.\n   *\n   * Prisma: bbs_articles.id.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * The article's writer name.\n   *\n   * Prisma: bbs_articles.writer.\n   */\n  writer: string;\n\n  /**\n   * Time article was created.\n   *\n   * Prisma: bbs_articles.created_at.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Logical deletion timestamp. Set on article deletion, or null if not\n   * deleted.\n   *\n   * Prisma: bbs_articles.deleted_at.\n   */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n  /**\n   * Current/latest snapshot information for the article (title/body/format).\n   *\n   * References most recent bbs_article_snapshots record.\n   */\n  latest_snapshot: IBbsArticleSnapshot;\n\n  /**\n   * Number of non-deleted comments attached to this article.\n   *\n   * Derived from bbs_article_comments.\n   */\n  comment_count: number & tags.Type<\"int32\">;\n\n  /**\n   * Files attached to the latest article snapshot, ordered.\n   *\n   * References attachment_files via bbs_article_snapshot_files.\n   */\n  attachments?: IAttachmentFile[];\n};\nexport namespace IBbsArticle {\n  /**\n   * Request parameters for listing/filtering bulletin board articles.\n   *\n   * References bbs_articles for identity, and bbs_article_snapshots for title\n   * filters. Supports pagination, search, and filter criteria. Used for PATCH\n   * /bbs/articles list endpoint.\n   */\n  export type IRequest = {\n    /**\n     * The page number for pagination.\n     *\n     * Prisma schema correspondence: BBS article list query pagination.\n     * Optional value.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Number of articles per page. Defaults to 100.\n     *\n     * Prisma schema correspondence: Used in paginated queries.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Writer's name filter.\n     *\n     * Prisma: bbs_articles.writer.\n     */\n    writer?: string;\n\n    /**\n     * Article title filter. Search will apply to the latest snapshot's\n     * title.\n     *\n     * Prisma: bbs_article_snapshots.title.\n     */\n    title?: string;\n\n    /**\n     * Start date/time for filtering articles by creation time.\n     *\n     * Prisma: bbs_articles.created_at.\n     */\n    date_from?: string & tags.Format<\"date-time\">;\n\n    /**\n     * End date/time for filtering articles by creation time.\n     *\n     * Prisma: bbs_articles.created_at.\n     */\n    date_to?: string & tags.Format<\"date-time\">;\n\n    /**\n     * Filter for articles with or without comments.\n     *\n     * Prisma: bbs_article_comments (count > 0).\n     */\n    has_comment?: boolean;\n  };\n\n  /**\n   * Summary output for a bulletin board article. Contains identifying and\n   * display information, including latest title and comment count.\n   *\n   * Draws on bbs_articles and latest record in bbs_article_snapshots.\n   */\n  export type ISummary = {\n    /**\n     * Unique identifier for the article.\n     *\n     * Prisma: bbs_articles.id.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Name of the article writer.\n     *\n     * Prisma: bbs_articles.writer.\n     */\n    writer: string;\n\n    /**\n     * Creation timestamp of the article.\n     *\n     * Prisma: bbs_articles.created_at.\n     */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /**\n     * Deletion timestamp, if the article has been deleted (logical delete).\n     *\n     * Prisma: bbs_articles.deleted_at.\n     *\n     * Null when not deleted.\n     */\n    deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * The title of the latest snapshot for the article.\n     *\n     * Prisma: bbs_article_snapshots.title (most recent).\n     */\n    title: string;\n\n    /**\n     * The number of non-deleted comments on the article.\n     *\n     * Calculated from bbs_article_comments where deleted_at is null.\n     */\n    comment_count: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Request body to create a new article. Includes metadata, content,\n   * attachments.\n   *\n   * Maps to bbs_articles for writer/password and to bbs_article_snapshots for\n   * content/history. Passwords are never stored in plain text after receipt.\n   */\n  export type ICreate = {\n    /**\n     * Name of the article's writer. Required on creation.\n     *\n     * Prisma: bbs_articles.writer.\n     */\n    writer: string;\n\n    /**\n     * Write-access password for the article, supplied as plain text and\n     * stored hashed.\n     *\n     * Prisma: bbs_articles.password.\n     */\n    password: string;\n\n    /**\n     * Article's initial title.\n     *\n     * Stored within the first snapshot. Prisma:\n     * bbs_article_snapshots.title.\n     */\n    title: string;\n\n    /**\n     * The initial body/content of the article.\n     *\n     * Prisma: bbs_article_snapshots.body.\n     */\n    body: string;\n\n    /**\n     * Format of the article body (e.g., 'md', 'html', 'txt').\n     *\n     * Prisma: bbs_article_snapshots.format.\n     */\n    format: string;\n\n    /**\n     * List of attachment file UUIDs to be linked with initial snapshot\n     * (order preserved). Optional.\n     *\n     * Prisma: bbs_article_snapshot_files. Can be empty array.\n     */\n    attachments?: (string & tags.Format<\"uuid\">)[];\n  };\n\n  /**\n   * Body for updating an article. All modifications result in creation of a\n   * new snapshot with revised content/attachments.\n   *\n   * Requires password verification for security. Snapshots are appended, not\n   * overwritten.\n   */\n  export type IUpdate = {\n    /**\n     * Writer's password for authentication prior to modification.\n     *\n     * Prisma: bbs_articles.password (hashed, verify only).\n     */\n    password: string;\n\n    /**\n     * Updated article title (becomes latest snapshot when modified).\n     *\n     * Prisma: bbs_article_snapshots.title.\n     */\n    title: string;\n\n    /**\n     * Updated article content/body.\n     *\n     * Prisma: bbs_article_snapshots.body.\n     */\n    body: string;\n\n    /**\n     * Updated body format (e.g., 'md', 'html', 'txt').\n     *\n     * Prisma: bbs_article_snapshots.format.\n     */\n    format: string;\n\n    /**\n     * New array of attachment file UUIDs to associate with new snapshot\n     * (order preserved). Optional.\n     *\n     * Prisma: bbs_article_snapshot_files.\n     */\n    attachments?: (string & tags.Format<\"uuid\">)[];\n  };\n\n  /**\n   * Delete request body for soft-deletion of an article. Verifies password.\n   *\n   * Marks deleted_at, but keeps record for dispute evidence preservation.\n   * Only privileged roles may bypass password.\n   */\n  export type IDelete = {\n    /**\n     * Password for writer authentication prior to logical deletion.\n     *\n     * Prisma: bbs_articles.password. Admins may not require.\n     */\n    password: string;\n  };\n}\n",
      "src/api/structures/IPageIBbsArticle.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticle } from \"./IBbsArticle\";\n\nexport namespace IPageIBbsArticle {\n  /**\n   * Paginated result containing summary information for multiple bulletin\n   * board articles.\n   *\n   * Used as the return type for article list endpoints with filtering, sort\n   * and pagination.\n   */\n  export type ISummary = {\n    pagination: IPage.IPagination;\n\n    /**\n     * List of summary objects for articles.\n     *\n     * Each includes last snapshot's title and metadata.\n     */\n    data: IBbsArticle.ISummary[];\n  };\n}\n",
      "src/api/structures/IBbsArticleSnapshot.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Full representation of a specific article snapshot/version. Contains title,\n * content, author IP, creation time, and all associated attachments.\n *\n * Maps to bbs_article_snapshots, attachment_files, and related junction tables.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleSnapshot = {\n  /**\n   * UUID for this article snapshot (version record).\n   *\n   * Prisma: bbs_article_snapshots.id.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Article this version belongs to.\n   *\n   * Prisma: bbs_article_snapshots.bbs_article_id.\n   */\n  bbs_article_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Display title for this version state.\n   *\n   * Prisma: bbs_article_snapshots.title.\n   */\n  title: string;\n\n  /**\n   * Content body of the article at this snapshot/version.\n   *\n   * Prisma: bbs_article_snapshots.body.\n   */\n  body: string;\n\n  /**\n   * Body format (e.g., md, html, txt).\n   *\n   * Prisma: bbs_article_snapshots.format.\n   */\n  format: string;\n\n  /**\n   * IP address of the snapshot's author/editor.\n   *\n   * Prisma: bbs_article_snapshots.ip.\n   */\n  ip: string;\n\n  /**\n   * Timestamp when the snapshot was created.\n   *\n   * Prisma: bbs_article_snapshots.created_at.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * Attachment files for this article snapshot, in order.\n   *\n   * References attachment_files via bbs_article_snapshot_files.\n   */\n  attachments?: IAttachmentFile[];\n};\nexport namespace IBbsArticleSnapshot {\n  /**\n   * Request body for searching/listing article snapshots. Supports filter and\n   * pagination fields. Used for PATCH /bbs/articles/snapshots endpoint.\n   */\n  export type IRequest = {\n    /**\n     * Pagination: page number.\n     *\n     * Used for paginated history listing.\n     */\n    page?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Pagination: number of items per page.\n     *\n     * Defaults to 100.\n     */\n    limit?: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /**\n     * Filter snapshots to a single article.\n     *\n     * Prisma: bbs_article_snapshots.bbs_article_id.\n     */\n    bbs_article_id?: string & tags.Format<\"uuid\">;\n\n    /**\n     * IP address filter for snapshot writer.\n     *\n     * Prisma: bbs_article_snapshots.ip.\n     */\n    ip?: string;\n\n    /**\n     * Body format filter (e.g., 'md', 'html', 'txt').\n     *\n     * Prisma: bbs_article_snapshots.format.\n     */\n    format?: string;\n\n    /** Filter: Only snapshots created after this ISO datetime. */\n    date_from?: string & tags.Format<\"date-time\">;\n\n    /** Filter: Only snapshots created before this ISO datetime. */\n    date_to?: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Summary object for an article snapshot, containing identifying info and\n   * display metadata.\n   *\n   * Excludes body/content and attachments.\n   */\n  export type ISummary = {\n    /**\n     * UUID of the article snapshot.\n     *\n     * Prisma: bbs_article_snapshots.id.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Article to which this snapshot belongs.\n     *\n     * Prisma: bbs_article_snapshots.bbs_article_id.\n     */\n    bbs_article_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Title for this version of the article.\n     *\n     * Prisma: bbs_article_snapshots.title.\n     */\n    title: string;\n\n    /**\n     * Body format for this version.\n     *\n     * Prisma: bbs_article_snapshots.format.\n     */\n    format: string;\n\n    /**\n     * Timestamp (ISO) when this snapshot record was created.\n     *\n     * Prisma: bbs_article_snapshots.created_at.\n     */\n    created_at: string & tags.Format<\"date-time\">;\n  };\n\n  /**\n   * Administrative update object for article snapshot entity. Used only by\n   * privileged actors for meta changes; does NOT allow editing of core\n   * version evidence content. Based on bbs_article_snapshots table, focusing\n   * on tag/status/meta-correction scenarios. Can be extended for further\n   * admin fields if required.\n   */\n  export type IUpdate = {\n    /**\n     * The unique identifier of the article snapshot to update. (Prisma: id)\n     *\n     * Required for targeting the specific snapshot for partial update.\n     * Referenced as the 'id' column in bbs_article_snapshots.\n     */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Administrative tag or internal label for the snapshot. (example:\n     * evidence, correction). Not part of core article evidence body.\n     * Optional property for metadata management.\n     */\n    tag?: string;\n\n    /**\n     * Administrative status or moderation note (e.g. valid, under_review,\n     * censored, etc.). Optional. Used for possible status workflow by\n     * admins.\n     */\n    status?: string;\n  };\n}\n",
      "src/api/structures/IPageIBbsArticleSnapshot.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleSnapshot } from \"./IBbsArticleSnapshot\";\n\nexport namespace IPageIBbsArticleSnapshot {\n  /**\n   * Paginated result type for listing snapshot summaries for articles.\n   *\n   * Aggregates bbs_article_snapshots metadata for multiple snapshots.\n   */\n  export type ISummary = {\n    pagination: IPage.IPagination;\n\n    /**\n     * List of article snapshot summaries (basic version info, omitting full\n     * body).\n     */\n    data: IBbsArticleSnapshot.ISummary[];\n  };\n}\n",
      "src/api/structures/IAttachmentFile.ts": "import { tags } from \"typia\";\n\n/**\n * Attachment file overview record. Reflects the `attachment_files` Prisma\n * schema for representing files uploaded, with storage info and provenance.\n * Used anywhere file metadata and references are needed.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IAttachmentFile = {\n  /** Unique identifier for the attachment file. Prisma column: id. */\n  id: string & tags.Format<\"uuid\">;\n\n  /** Filename without extension (original name). */\n  name: string;\n\n  /** File extension, e.g., 'png', 'pdf'. May be blank or null. */\n  extension?: string;\n\n  /**\n   * URL (complete path) where this file can be downloaded or viewed. Prisma:\n   * url.\n   */\n  url: string;\n\n  /**\n   * Timestamp when the file record was created (ISO 8601). Prisma:\n   * created_at.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n};\nexport namespace IAttachmentFile {\n  /**\n   * Reference to attachment file for linking to comments or comment\n   * snapshots. Used during comment create/update to form connection in\n   * evidence.\n   */\n  export type IReference = {\n    /** Attachment File unique ID. */\n    id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Order/position of file in attachments array (required for reordering\n     * files in snapshot, not in core 'attachment_files').\n     */\n    sequence: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Summary view of attachment file, for efficient preview in lists or\n   * minimal context popups (less than IAttachmentFile).\n   */\n  export type ISummary = {\n    /** Attachment File unique ID (summary view). */\n    id: string & tags.Format<\"uuid\">;\n\n    /** File name (without extension). */\n    name: string;\n\n    /** Extension (nullable, e.g. for README). */\n    extension?: string | null;\n\n    /** Web-accessible URL for file download/preview. */\n    url: string;\n  };\n\n  /**\n   * Filtering and pagination query for searching attachment files.\n   *\n   * Combines optional name/extension filters and time-based constraints. Maps\n   * to Prisma query parameters and aligns with frontend search forms.\n   */\n  export type IRequest = {\n    /** (Optional) Filter for the file name (not extension). */\n    name?: string;\n\n    /** (Optional) Filter for file extension. */\n    extension?: string;\n\n    /**\n     * (Optional) Fetch attachment files created from this date/time\n     * (inclusive).\n     */\n    created_from?: string & tags.Format<\"date-time\">;\n\n    /**\n     * (Optional) Fetch attachment files created up to this date/time\n     * (inclusive).\n     */\n    created_to?: string & tags.Format<\"date-time\">;\n\n    /**\n     * The page number to retrieve for paginated results (optional).\n     *\n     * See IPage.IRequest.\n     */\n    page?: number & tags.Type<\"int32\">;\n\n    /**\n     * Records per page to retrieve for paginated results (optional, default\n     * may be 100).\n     *\n     * See IPage.IRequest.\n     */\n    limit?: number & tags.Type<\"int32\">;\n  };\n\n  /**\n   * Payload for registering a new file attachment entity.\n   *\n   * Covers all required fields for new file metadata except\n   * automatically-generated fields such as creation time.\n   */\n  export type ICreate = {\n    /**\n     * Unique identifier for the attachment file (if pre-specified or\n     * generated before upload).\n     */\n    id?: string & tags.Format<\"uuid\">;\n\n    /** Name of the file (not including extension). Prisma column: name. */\n    name: string;\n\n    /**\n     * File extension, e.g., 'jpg', 'pdf'. May be null or blank for\n     * extensionless files.\n     */\n    extension?: string;\n\n    /**\n     * URL or storage path where the file is accessible by clients. Prisma:\n     * url.\n     */\n    url: string;\n  };\n\n  /**\n   * Editable fields for an attachment file, for updating metadata such as\n   * name or extension. Typically admin-only. Prisma: `name`, `extension`\n   * columns.\n   */\n  export type IUpdate = {\n    /** Updated file name without extension, if renaming is allowed. */\n    name?: string;\n\n    /** File extension update, if required (null for none). */\n    extension?: string;\n  };\n\n  /**\n   * Payload to request logical deletion of an attachment file, with admin\n   * notes. For admin/audit use only.\n   */\n  export type IDelete = {\n    /**\n     * Whether to confirm deletion (required for APIs using staged delete\n     * patterns).\n     */\n    confirm?: boolean;\n\n    /** Optional note by admin for the reason this file is being deleted. */\n    admin_reason?: string;\n  };\n}\n",
      "src/api/structures/IPage.ts": "import { tags } from \"typia\";\n\nexport namespace IPage {\n  /**\n   * Page information for paginated responses.\n   *\n   * Includes current, limit, total records, and total pages for API responses\n   * adhering to the IPage<T> pattern.\n   */\n  export type IPagination = {\n    /** Current page number of the result set. */\n    current: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Maximum records returned per page. Default is 100. */\n    limit: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total number of records found (for all pages). */\n    records: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n\n    /** Total number of pages calculated from records/limit (with ceiling). */\n    pages: number &\n      tags.Type<\"int32\"> &\n      tags.JsonSchemaPlugin<{\n        format: \"uint32\";\n      }>;\n  };\n}\n",
      "src/api/structures/IBbsArticleComment.ts": "import { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"./IBbsArticleCommentSnapshot\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Full comment object with evidence/latest body, parent/child relations,\n * deletion marker, and all metadata. Core entity is bbs_article_comments, with\n * latest body joined from bbs_article_comment_snapshots. Attachments from\n * attachment_files joined as needed. Used in detailed comment views, evidence\n * review, or admin panels.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleComment = {\n  /**\n   * Unique identifier for the comment record. (Prisma: id,\n   * bbs_article_comments)\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /** UUID of the parent article. (Prisma: bbs_article_id) */\n  bbs_article_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Parent comment id for reply/nesting structure. (Prisma: parent_id;\n   * nullable for top-level comments)\n   */\n  parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n  /** Writer's name (saved as plaintext, public). */\n  writer: string;\n\n  /**\n   * Comment creation timestamp (Prisma: created_at)\n   *\n   * Indicates original posting time and used in sorting/UI display.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /** Logical deletion timestamp (Prisma: deleted_at; null if not deleted). */\n  deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n  /**\n   * The latest version/snapshot of the comment content.\n   *\n   * References evidence record for current visible body, format, and\n   * attachments. (bbs_article_comment_snapshots)\n   */\n  latest_snapshot: IBbsArticleCommentSnapshot;\n\n  /**\n   * Immediate children comments (replies) for threading/hierarchy. Populated\n   * depending on endpoint and UI.\n   */\n  children?: IBbsArticleComment.ISummary[] | null;\n\n  /**\n   * Array of files attached to the latest version/snapshot. (via\n   * bbs_article_comment_snapshot_files, joined from attachment_files)\n   */\n  attachments?: IAttachmentFile[] | null;\n\n  /**\n   * Indicate whether comment is deleted (deleted_at != null). Not a DB field,\n   * for convenience only.\n   */\n  is_deleted?: boolean;\n};\nexport namespace IBbsArticleComment {\n  /**\n   * Parameters used for listing or searching comments linked to a specific\n   * article. Supports hierarchy, writer filter, and pagination. Corresponds\n   * to segment queries for comments shown in UI tree. Derived from comment\n   * request UI and bbs_article_comments schema.\n   */\n  export type IRequest = {\n    /**\n     * ID of parent comment, if retrieving replies or subtree. If null,\n     * fetch root comments. (Prisma: parent_id, bbs_article_comments)\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Page number for pagination. Optional. Defaults to 1 if absent. */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /** Number of comments per page. Optional. Defaults to 100. */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /**\n     * Filter for comments by specific writer's name. Used for searching.\n     * Optional.\n     */\n    writer?: string | null;\n  };\n\n  /**\n   * Request body for creating a new comment (root or reply). Carries\n   * author/writer, password, comment content (body), body format\n   * (html/md/txt), and (optionally) attachments. Parent_id links replies. On\n   * create, initializes a first snapshot for evidence. Based on\n   * bbs_article_comments and bbs_article_comment_snapshots schema columns.\n   */\n  export type ICreate = {\n    /**\n     * Author name for the comment. (Prisma: writer, bbs_article_comments)\n     *\n     * Required during creation, displayed publicly. Not a unique identifier\n     * but user-supplied.\n     */\n    writer: string;\n\n    /**\n     * Plaintext password for comment creation. Stored in DB ONLY as a\n     * cryptographic hash. (Prisma: password, bbs_article_comments)\n     *\n     * Must not be returned in reads. Used for authentication in later\n     * mod/delete.\n     */\n    password: string;\n\n    /**\n     * Format of the comment body: e.g. 'html', 'markdown', 'txt'. (Prisma:\n     * format, bbs_article_comment_snapshots)\n     *\n     * Enables rendering multi-format body content in UI, evidence\n     * preservation.\n     */\n    format: string;\n\n    /**\n     * Actual comment content.\n     *\n     * When created, stored in a snapshot record\n     * (bbs_article_comment_snapshots). Forms part of the evidential\n     * history.\n     */\n    body: string;\n\n    /**\n     * Array of file metadata for attachments (if any) included with comment\n     * creation. Each entry references file uploaded by user. (Relationship\n     * to attachment_files via bbs_article_comment_snapshot_files)\n     */\n    attachments?: IAttachmentFile.IReference[] | null;\n\n    /**\n     * Optional; ID of parent comment for replies. If present, links this\n     * comment as a reply in nesting tree. Enables hierarchy. (Prisma:\n     * parent_id)\n     */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /**\n     * IP address of commenter (from request context, not settable by user\n     * in API). Recorded for each evidence/snapshot. Used for\n     * dispute/evidence policy.\n     */\n    ip?: string;\n  };\n\n  /**\n   * Summary view for comment list (e.g., in\n   * IPageIBbsArticleComment.ISummary). Contains basic info for rendering\n   * top-level and nested comments efficiently. Attachments only as summary\n   * (IAttachmentFile.ISummary).\n   */\n  export type ISummary = {\n    /** Comment's unique ID */\n    id: string & tags.Format<\"uuid\">;\n\n    /** Writer's display name (public) */\n    writer: string;\n\n    /** Comment creation timestamp */\n    created_at: string & tags.Format<\"date-time\">;\n\n    /** Comment logical deletion time (null if active) */\n    deleted_at?: (string & tags.Format<\"date-time\">) | null;\n\n    /**\n     * Most recent comment content (from latest snapshot for list view\n     * efficiency).\n     *\n     * Not always entire evidence record (see IBbsArticleComment for full\n     * version history).\n     */\n    body: string;\n\n    /**\n     * Brief info on attached files for the latest snapshot. Null or empty\n     * if none.\n     */\n    attachments?: IAttachmentFile.ISummary[] | null;\n\n    /** ID of parent comment if nested/reply, null if root-level. */\n    parent_id?: (string & tags.Format<\"uuid\">) | null;\n  };\n\n  /**\n   * Request body for updating (editing) an existing comment. Password check\n   * required. New body content, format, and attachments create a new version\n   * snapshot for evidence. Based on schemas for bbs_article_comments and\n   * bbs_article_comment_snapshots.\n   */\n  export type IUpdate = {\n    /**\n     * Password supplied for verification (plaintext, compared securely to\n     * hash in DB).\n     *\n     * Required for authentication before modifying the comment or any\n     * evidence content.\n     */\n    password: string;\n\n    /**\n     * New comment content/body to be recorded in a new snapshot version\n     * history (not in-place overwrite).\n     *\n     * Preserves evidence trail.\n     */\n    body: string;\n\n    /**\n     * Format indicator for new body (e.g. 'html', 'md', 'txt').\n     *\n     * Allows rich editing and multi-format content.\n     */\n    format: string;\n\n    /**\n     * Optional list of file attachment references for new revision (can\n     * add/remove/reorder).\n     */\n    attachments?: IAttachmentFile.IReference[] | null;\n\n    /**\n     * IP address of the modifier (system/infra-injected, not\n     * user-supplied).\n     */\n    ip?: string;\n  };\n\n  /**\n   * Request body for logical (soft) deletion of a comment. Only accepted from\n   * author with password verification. Triggers logical delete (sets\n   * deleted_at), but never physical removal.\n   */\n  export type IDelete = {\n    /**\n     * Password supplied to verify correct authorization for logical\n     * deletion (soft delete). (Prisma: password, bbs_article_comments)\n     *\n     * System will check supplied plaintext against hash in DB.\n     */\n    password: string;\n  };\n}\n",
      "src/api/structures/IPageIBbsArticleComment.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleComment } from \"./IBbsArticleComment\";\n\nexport namespace IPageIBbsArticleComment {\n  /**\n   * Paginated result of comment summaries for a given article. Includes a\n   * page info object and an array of summary comment objects\n   * (IBbsArticleComment.ISummary). Used for efficient comment list rendering\n   * with pagination in UI. Respects evidence and logical delete policy in\n   * returned records.\n   */\n  export type ISummary = {\n    pagination: IPage.IPagination;\n\n    /** Array of summarized comment objects for the current page. */\n    data: IBbsArticleComment.ISummary[];\n  };\n}\n",
      "src/api/structures/IBbsArticleCommentSnapshot.ts": "import { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Snapshot entity containing revision information for a comment, preserving\n * evidence for all edits or modifications.\n *\n * This schema reflects the `bbs_article_comment_snapshots` table, storing all\n * state for each modification, including content, format, timestamps, author\n * IP, and attachments. Maintains historical records for compliance and dispute\n * prevention.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IBbsArticleCommentSnapshot = {\n  /**\n   * Unique identifier for the comment snapshot.\n   *\n   * Corresponds to Prisma: `id` column. Primary Key.\n   */\n  id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Reference to the parent comment this snapshot belongs to.\n   *\n   * Prisma: `bbs_article_comment_id`. Foreign Key referencing\n   * `bbs_article_comments.id`.\n   */\n  bbs_article_comment_id: string & tags.Format<\"uuid\">;\n\n  /**\n   * Format of the comment body. For example, 'html', 'md', 'txt'.\n   *\n   * Maps to Prisma: `format` column.\n   */\n  format: string;\n\n  /**\n   * The actual content of the comment for this snapshot. Full bodies are\n   * preserved unmodified.\n   *\n   * Prisma: `body` column.\n   */\n  body: string;\n\n  /**\n   * IP address of the author/modifier for this snapshot. Used for fraud\n   * prevention and evidence.\n   *\n   * Prisma: `ip` column.\n   */\n  ip: string;\n\n  /**\n   * Timestamp (ISO8601) indicating when this version (snapshot) was created.\n   *\n   * Corresponds to: `created_at` column in Prisma.\n   */\n  created_at: string & tags.Format<\"date-time\">;\n\n  /**\n   * List of attached files for this snapshot, with their sequence preserved.\n   *\n   * Derived from attachment M:N relations. Each item references\n   * `IAttachmentFile` with its own sequence.\n   */\n  attachments?: IBbsArticleCommentSnapshot.IAttachment[];\n};\nexport namespace IBbsArticleCommentSnapshot {\n  /**\n   * Parameters for searching/filtering comment snapshot records. Derived from\n   * bbs_article_comment_snapshots; used for evidence/audit UIs and\n   * administration. Includes support for paging, filtering by comment,\n   * format, IP address, date.\n   */\n  export type IRequest = {\n    /**\n     * ID of the comment whose snapshots are being fetched. Optional filter,\n     * can be null for global search in all comments.\n     */\n    bbs_article_comment_id?: (string & tags.Format<\"uuid\">) | null;\n\n    /** Format filter (e.g.: html, md, txt) */\n    format?: string | null;\n\n    /** IP address filter. Allows audit by IP evidence trail. */\n    ip?: string | null;\n\n    /** Start of creation date range filter (UTC). */\n    from_date?: (string & tags.Format<\"date-time\">) | null;\n\n    /** End of creation date range filter (UTC). */\n    to_date?: (string & tags.Format<\"date-time\">) | null;\n\n    /** Page number for pagination. */\n    page?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n\n    /** Max records per page (default 100). */\n    limit?:\n      | (number &\n          tags.Type<\"int32\"> &\n          tags.JsonSchemaPlugin<{\n            format: \"uint32\";\n          }>)\n      | null;\n  };\n\n  /**\n   * Describes an attached file as linked through a comment snapshot,\n   * including metadata and sequence order.\n   *\n   * Maps to the join table in Prisma and composed for snapshot context.\n   */\n  export type IAttachment = {\n    /** Unique identifier for the attached file in this snapshot. */\n    id: string & tags.Format<\"uuid\">;\n\n    /** ID reference of the attached file. Relates to `attachment_files.id`. */\n    attachment_file_id: string & tags.Format<\"uuid\">;\n\n    /**\n     * Order of the attachment in the snapshot's attachment list.\n     *\n     * Prisma: `sequence` column.\n     */\n    sequence: number & tags.Type<\"int32\">;\n\n    /** Metadata for the attachment file itself. */\n    file: IAttachmentFile;\n  };\n\n  /**\n   * Update parameters for allowed snapshot attributes (typically admin-only\n   * correction/annotation fields).\n   *\n   * Contents subject to access restrictions and do not alter evidential\n   * snapshot content like body or IP.\n   */\n  export type IUpdate = {\n    /**\n     * Administrative or moderation status label for this snapshot, e.g.,\n     * 'normal', 'flagged', 'corrected'. Not an original post field.\n     */\n    meta_status?: string;\n\n    /** Free-form admin/moderator note for audit/tagging purposes. */\n    admin_note?: string;\n  };\n\n  /**\n   * Administrative request to logically delete a comment snapshot. Used only\n   * by privileged users to maintain evidential integrity.\n   */\n  export type IDelete = {\n    /**\n     * Optional reason or case label for logical deletion, used in admin\n     * audit context.\n     */\n    reason?: string;\n  };\n}\n",
      "src/api/structures/IPageIBbsArticleCommentSnapshot.ts": "import { IPage } from \"./IPage\";\nimport { IBbsArticleCommentSnapshot } from \"./IBbsArticleCommentSnapshot\";\n\n/**\n * Page result type for listing comment snapshots. Returns\n * IBbsArticleCommentSnapshot entities in paginated form with metadata for UI or\n * admin consumption.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIBbsArticleCommentSnapshot = {\n  pagination: IPage.IPagination;\n\n  /** Snapshots for the selected page and criteria; array of full objects. */\n  data: IBbsArticleCommentSnapshot[];\n};\n",
      "src/api/structures/IPageIAttachmentFile.ts": "import { IPage } from \"./IPage\";\nimport { IAttachmentFile } from \"./IAttachmentFile\";\n\n/**\n * Paginated container of attachment file records, with page metadata and\n * current result set. Adheres to IPage<T> standard pattern in all API paginated\n * returns.\n *\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport type IPageIAttachmentFile = {\n  /** Pagination metadata, including page info and total records. */\n  pagination: IPage.IPagination;\n\n  /** List of attachment file entities for this page of results. */\n  data: IAttachmentFile[];\n};\n",
      "src/api/functional/bbs/articles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticle } from \"../../../structures/IBbsArticle\";\nimport { IPageIBbsArticle } from \"../../../structures/IPageIBbsArticle\";\nexport * as snapshots from \"./snapshots\";\nexport * as comments from \"./comments\";\n\n/**\n * Create a bulletin board article (bbs_articles + initial snapshot, with\n * attachments).\n *\n * This endpoint allows a user to create a new bulletin board article. Upon\n * invocation, a new record in bbs_articles is inserted, as well as a first\n * snapshot in bbs_article_snapshots, containing the initial version's body,\n * format, title, and IP address of the request. Attachments may also be\n * uploaded and associated via attachment_files and bbs_article_snapshot_files\n * junction.\n *\n * The author provides a writer name, password (which must be encrypted before\n * storage), and content (title, body, format). An array of file metadata may\n * also be included. This route enforces presence of all required fields and\n * validates file upload if present.\n *\n * Security: Password is stored only as a hash; plaintext password must not be\n * stored. All significant actions (including IP address capture) must be logged\n * and linked to the snapshot. Failure scenarios include missing/invalid\n * required fields, unsupported file types, or database errors. Related:\n * Modification is handled via PUT /bbs/articles/{id}; version retrieval by\n * PATCH /bbs/articles/snapshots.\n *\n * @param body New article creation info including writer, password, initial\n *   title and body, format, and optional file attachments.\n * @path /bbs/articles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  body: post.Input,\n): Promise<post.Output> {\n  return !!connection.simulate\n    ? post.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace post {\n  export type Input = IBbsArticle.ICreate;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles\";\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: post.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * List articles from bbs_articles with searching, pagination, and summary info.\n *\n * This API endpoint allows clients to retrieve a paginated, filtered, and/or\n * sorted list of bulletin board articles. It references the bbs_articles table\n * in Prisma, which holds basic post identity and author information, as well as\n * deletion markers. Results typically include only non-deleted articles for\n * general users (unless special admin permission is given).\n *\n * Each article summary should include the latest title (from the latest\n * snapshot), author, creation time, and comment count. Filters may include\n * search by title, author, date ranges, and possibly presence of comments. The\n * endpoint should work efficiently by leveraging indexes on created_at and\n * deleted_at for best performance. Soft-deleted posts are omitted except for\n * admin access.\n *\n * Request parameters support pagination with cursor/limit or offset/limit.\n * Security: Access to deleted articles may depend on user role; listing of all\n * (including deleted) may require admin level. Related API operation: GET\n * /bbs/articles/{id} for detailed information. Errors for invalid search\n * parameters, forbidden access, or server errors follow consistent patterns.\n *\n * @param body Request parameters for listing articles, including filters\n *   (title, author, date), pagination (cursor/limit or offset/limit), and\n *   sorting options.\n * @path /bbs/articles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IBbsArticle.IRequest;\n  export type Output = IPageIBbsArticle.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticle.ISummary => typia.random<IPageIBbsArticle.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get detail on a single article (bbs_articles & latest snapshot, attachments,\n * safe info).\n *\n * This endpoint retrieves all information required for a specific article,\n * given its unique id (UUID). It uses the bbs_articles table to obtain author,\n * creation time, and status (deleted or not). The latest version is provided by\n * linking to the most recent bbs_article_snapshots record, including title,\n * body, and format. Attachments related to the latest snapshot are also\n * returned.\n *\n * If the article is soft-deleted, its access may be restricted to admin-level\n * or special permission users. IP information may be redacted for standard\n * users to enhance privacy. The endpoint returns an error if the id is invalid\n * or the article does not exist. This operation does not modify the database\n * and is considered safe for client retrieval.\n *\n * Related API: PATCH /bbs/articles for the listing. Errors adhere to the API's\n * standard error response structure.\n *\n * @param id The article's unique identifier (UUID).\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Modify an article (bbs_articles): add snapshot and optionally modify\n * attachments.\n *\n * This endpoint enables the modification of a previously created article.\n * Modifications do not overwrite existing articles but result in a new record\n * in bbs_article_snapshots linked to the same article. It enforces password\n * verification against the article's hashed password before proceeding. Authors\n * can change the title, body, body format, and update attachments through this\n * operation.\n *\n * The endpoint requires the article id, the writer's password (to be verified),\n * and the new content. Attachments can be modified (added, removed, reordered)\n * by specifying their metadata. If the password is invalid or missing, the\n * operation fails with an appropriate error. Only non-deleted articles can be\n * modified unless special permissions are given.\n *\n * Security: Store IP address and record the modification time. Existing\n * snapshots remain immutable to preserve evidence/history. Updates to\n * associated attachments create new junction entries for the new snapshot.\n * Related API: GET /bbs/articles/{id} to fetch new version, PATCH\n * /bbs/articles/snapshots to list all versions. All error and success responses\n * follow universal API schema.\n *\n * @param id Article's unique identifier (UUID) to update.\n * @param body Update info for an article, including new title/body/format,\n *   re-attachment info, and password verification.\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IBbsArticle.IUpdate;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Soft-delete (logical delete) a bulletin board article. Only marks deleted_at,\n * no physical removal.\n *\n * This endpoint is for logically deleting an existing bulletin board article.\n * It only marks the deleted_at field with the current timestamp, preserving the\n * record for evidence and possible future administrative review. The request\n * must include password verification for standard users; admin users may delete\n * without password depending on config/policy. If the password is invalid or\n * missing, the deletion will fail.\n *\n * Logically deleted articles are not shown in public lists but are still\n * accessible for admin/forensic reasons. Physical deletion is never performed\n * to maintain history. Errors are returned if the article is not found, already\n * deleted, or password is incorrect. The operation records who (user, IP)\n * deleted the item.\n *\n * @param id Article's unique identifier (UUID) to soft-delete.\n * @param body Password for soft-deletion verification if not admin. Admins may\n *   bypass password check.\n * @path /bbs/articles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseById.Input,\n): Promise<eraseById.Output> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseById {\n  export type Input = IBbsArticle.IDelete;\n  export type Output = IBbsArticle;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (g?: Partial<typia.IRandomGenerator>): IBbsArticle =>\n    typia.random<IBbsArticle>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/index.ts": "export * as articles from \"./articles\";\n",
      "src/api/functional//index.ts": "export * as bbs from \"./bbs\";\nexport * as attachmentFiles from \"./attachmentFiles\";\n",
      "src/api/functional/bbs/articles/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleSnapshot } from \"../../../../structures/IBbsArticleSnapshot\";\nimport { IPageIBbsArticleSnapshot } from \"../../../../structures/IPageIBbsArticleSnapshot\";\n\n/**\n * List (paged) article snapshots from bbs_article_snapshots, filter by article\n * id, etc.\n *\n * This endpoint provides a paginated, filterable, and sortable list of all\n * article snapshots (historical versions), from the bbs_article_snapshots\n * Prisma table. Clients can use this to access the full modification history\n * for articles.\n *\n * Search/explore versions by article id, creation time, writer IP, format, or\n * keywords in title/body; efficient index access is required for performance.\n * Pagination parameters are mandatory for scalability with growing history.\n * Deleted articles' snapshots may be accessible to admins only. For standard\n * users, only versions for non-deleted articles are returned. Snapshots include\n * all version metadata (format, title, body, created_at, IP) and attachment\n * references.\n *\n * Related API: PATCH /bbs/articles for article overviews, GET\n * /bbs/articles/snapshots/{id} for version detail.\n *\n * @param body Snapshot search parameters: filters for article id, date ranges,\n *   IP, body/title keywords; plus pagination info.\n * @path /bbs/articles/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IBbsArticleSnapshot.IRequest;\n  export type Output = IPageIBbsArticleSnapshot.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles/snapshots\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleSnapshot.ISummary =>\n    typia.random<IPageIBbsArticleSnapshot.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get details of one article snapshot (version), including all metadata and its\n * attachments.\n *\n * This operation returns the full metadata for a specified article snapshot (by\n * UUID), including all version metadata (title, body, format, created_at, IP\n * address) and linked attachment file info. It is typically used to view\n * historical versions of an article for evidence or audit purposes.\n *\n * Appropriate authorization may be required if the snapshot is for an article\n * that has been deleted or is restricted. Errors are returned for non-existent\n * IDs or unauthorized access. IP addresses may only be visible to admins. No\n * modification of state occurs here.\n *\n * Security: Carefully audit access to preserve privacy. Related: POST/PATCH to\n * list versions, parent article access via GET /bbs/articles/{id}. Error\n * responses standardized.\n *\n * @param id Snapshot's unique identifier (UUID).\n * @path /bbs/articles/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Modify snapshot record's metadata (admin/forensic use only), not the actual\n * version content.\n *\n * This admin-facing endpoint (rarely exposed to end-users) allows for partial\n * updates (e.g., tagging or meta-corrections) to a specific snapshot record,\n * identified by its UUID. Typical users will not modify snapshots (snapshots\n * are append-only); this is for exceptional forensic or administrative cases.\n *\n * Permitted updates may include internal metadata such as status tagging or\n * moderation flags, but NOT revision of original title/body/IP, to preserve\n * evidence. Access strictly controlled; all actions audited. Operation rejected\n * if forbidden fields are attempted to be changed or user is unauthorized.\n * Related: GET /bbs/articles/snapshots/{id} for version details.\n *\n * @param id Snapshot's UUID.\n * @param body Patch request for allowed snapshot metadata fields (typ.\n *   tagging/status/mod notes).\n * @path /bbs/articles/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IBbsArticleSnapshot.IUpdate;\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Permanently delete an article snapshot (admin maintenance/correction use),\n * not for public users.\n *\n * This highly restricted endpoint allows physical deletion of a single article\n * snapshot by its UUID. Typically, this would only be permitted in cases of\n * evidence tampering, privacy requests, or system maintenance. Regular users\n * have no access.\n *\n * The operation removes the historical version and updates all connected\n * records accordingly. Audit logs should capture all deletions.\n * Invalid/dependent snapshot deletion attempts result in errors. Recognize that\n * removing a snapshot could compromise historical integrity, so authorization\n * and safety nets must be ensured. Related: GET for details, PATCH for list.\n *\n * @param id Snapshot's UUID.\n * @path /bbs/articles/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<eraseById.Output> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace eraseById {\n  export type Output = IBbsArticleSnapshot;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleSnapshot => typia.random<IBbsArticleSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/articles/comments/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport typia, { tags } from \"typia\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleComment } from \"../../../../structures/IBbsArticleComment\";\nimport { IPageIBbsArticleComment } from \"../../../../structures/IPageIBbsArticleComment\";\nexport * as snapshots from \"./snapshots\";\n\n/**\n * Create a new comment or reply to an article, supporting nesting and\n * attachments. Snapshots required for history.\n *\n * Enables the creation of a new comment (reply or root) on a specific article,\n * specified by articleId. A record is inserted into bbs_article_comments along\n * with a corresponding first snapshot in bbs_article_comment_snapshots (body,\n * format, IP). This supports direct comments or reply chains by specifying\n * parent_id in the body (for nested comments).\n *\n * Comment must include writer, password (stored securely via hash), body,\n * format, and can optionally reference files. Enforces required fields,\n * validates permissions, checks nesting rules. Upon creation, the first\n * snapshot is linked and metadata set. Logical deletion applies for future\n * removal, not on creation.\n *\n * Security: All actions (IP, times) are audited; sensitive data such as\n * passwords are hashed before storage. Failure triggers: missing/invalid\n * params, wrong parent/article ID, DB errors. Related: PATCH for comment list;\n * GET for comment details.\n *\n * @param articleId UUID of the article to comment on.\n * @param body New comment info: writer, password, body, format, parent_id (for\n *   reply), optional attachments.\n * @path /bbs/articles/:articleId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function postByArticleid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  body: postByArticleid.Input,\n): Promise<postByArticleid.Output> {\n  return !!connection.simulate\n    ? postByArticleid.simulate(connection, articleId, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...postByArticleid.METADATA,\n          path: postByArticleid.path(articleId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace postByArticleid {\n  export type Input = IBbsArticleComment.ICreate;\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/bbs/articles/:articleId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (articleId: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    body: postByArticleid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: postByArticleid.path(articleId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a paginated and hierarchical list of comments for an article, showing\n * current body.\n *\n * This endpoint provides retrieval of a hierarchical, paginated, and\n * searchable/commentable list of comments related to a particular article.\n * Queries bbs_article_comments table for all comments (excluding deleted unless\n * admin), joined with their latest snapshot record for current body/display\n * (from bbs_article_comment_snapshots). Supports threaded replies with\n * unlimited depth via parent_id.\n *\n * Filters include parent_id (for fetching root comments or replies), writer\n * name, creation time, and support for pagination for large inputs. By default,\n * only non-deleted comments are returned. Role-based logic may allow access to\n * deleted comments for admins. Sorting can include time or hierarchy order.\n *\n * Efficient tree retrieval is required for good performance with nesting.\n * Related endpoints: POST for new comment; GET\n * /bbs/articles/{articleId}/comments/{id} for comment detail.\n *\n * @param articleId Article UUID for which to fetch comments.\n * @param body Comment list request parameters: pagination, optional parent_id\n *   for segment, or search filters.\n * @path /bbs/articles/:articleId/comments\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patchByArticleid(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  body: patchByArticleid.Input,\n): Promise<patchByArticleid.Output> {\n  return !!connection.simulate\n    ? patchByArticleid.simulate(connection, articleId, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patchByArticleid.METADATA,\n          path: patchByArticleid.path(articleId),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patchByArticleid {\n  export type Input = IBbsArticleComment.IRequest;\n  export type Output = IPageIBbsArticleComment.ISummary;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/:articleId/comments\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (articleId: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleComment.ISummary =>\n    typia.random<IPageIBbsArticleComment.ISummary>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    body: patchByArticleid.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patchByArticleid.path(articleId),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get full details (including snapshot, attachments, and hierarchy) for one\n * comment on an article.\n *\n * This endpoint fetches the full details for a single comment on a given\n * article. Accepts the articleId for context and the comment's uuid as id.\n * Joins the bbs_article_comments table (for metadata, writer, deletion status)\n * with latest snapshot (from bbs_article_comment_snapshots) for body/format.\n * Also fetches attachment info for the snapshot.\n *\n * Details include: creation and (if) deletion timestamps, author, format, body,\n * all attachments for the most recent version, parent/child info for replies,\n * and optional list of immediate child comment IDs (to facilitate threaded\n * UIs). Deleted comments are shown only with special permission (admin). If not\n * found or not permitted, appropriate error returns.\n *\n * Related: PATCH for listing, POST for creation. Error codes are standardized\n * across comment operations.\n *\n * @param articleId The article UUID where the comment belongs.\n * @param id Comment's UUID to consult.\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? getByArticleidAndId.simulate(connection, articleId, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getByArticleidAndId.METADATA,\n          path: getByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n      );\n}\nexport namespace getByArticleidAndId {\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update existing comment information in 'bbs_article_comments' for a given\n * article and comment.\n *\n * This API endpoint allows a user to update a specific comment in the bulletin\n * board system while maintaining a snapshot of the modification for evidence.\n * The operation is secured by requiring the correct password for comment\n * modification, as dictated by the system's security policy. On execution, a\n * new snapshot will be generated, storing the old version and the modifying\n * client's IP address, as per the evidential design. Only non-deleted comments\n * are modifiable; comments previously soft-deleted (deleted_at set) will be\n * rejected.\n *\n * Validation rules enforce existence of the referenced article and comment,\n * correct hierarchical relationships for nested replies, required fields, and\n * adherence to data consistency regarding attachments and format. The operation\n * also ensures that password hashes are compared and never exposed in the API,\n * supporting encrypted password storage.\n *\n * This endpoint is related to: GET /bbs/articles/{articleId}/comments/{id}\n * (fetch detail), POST /bbs/articles/{articleId}/comments (creation), and\n * DELETE /bbs/articles/{articleId}/comments/{id} (logical deletion). Error\n * responses include unauthorized modification, resource not found, and input\n * validation failures.\n *\n * @param articleId Target article's ID\n * @param id Target comment's ID\n * @param body Updated data for the comment. Requires writer and password for\n *   authentication, and allows update of body/content fields.\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: putByArticleidAndId.Input,\n): Promise<putByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? putByArticleidAndId.simulate(connection, articleId, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putByArticleidAndId.METADATA,\n          path: putByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putByArticleidAndId {\n  export type Input = IBbsArticleComment.IUpdate;\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: putByArticleidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically delete a comment (set deleted_at) in 'bbs_article_comments' for a\n * given article and comment ID.\n *\n * This endpoint marks a specified comment under a particular article as deleted\n * (soft delete). In accordance with the requirements, the comment is not\n * physically removed, but its 'deleted_at' field is set to the current\n * timestamp. If the supplied password does not match or the comment is already\n * deleted, an error is returned. All historical snapshots for the comment are\n * preserved, ensuring the full audit log needed for dispute resolution.\n *\n * The endpoint performs validation for the existence of both the article and\n * comment, ensures correct authorization (password validation), and returns the\n * final comment record reflecting the logical deletion. This supports system\n * requirements for evidence retention and access control for administrators.\n *\n * @param articleId Target article's ID\n * @param id Target comment's ID\n * @param body Password required for logical deletion/authentication.\n * @path /bbs/articles/:articleId/comments/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseByArticleidAndId(\n  connection: IConnection,\n  articleId: string & tags.Format<\"uuid\">,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseByArticleidAndId.Input,\n): Promise<eraseByArticleidAndId.Output> {\n  return !!connection.simulate\n    ? eraseByArticleidAndId.simulate(connection, articleId, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseByArticleidAndId.METADATA,\n          path: eraseByArticleidAndId.path(articleId, id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseByArticleidAndId {\n  export type Input = IBbsArticleComment.IDelete;\n  export type Output = IBbsArticleComment;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/:articleId/comments/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n  ) =>\n    `/bbs/articles/${encodeURIComponent(articleId ?? \"null\")}/comments/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleComment => typia.random<IBbsArticleComment>(g);\n  export const simulate = (\n    connection: IConnection,\n    articleId: string & tags.Format<\"uuid\">,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseByArticleidAndId.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseByArticleidAndId.path(articleId, id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"articleId\")(() => typia.assert(articleId));\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/bbs/articles/comments/snapshots/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IBbsArticleCommentSnapshot } from \"../../../../../structures/IBbsArticleCommentSnapshot\";\nimport { IPageIBbsArticleCommentSnapshot } from \"../../../../../structures/IPageIBbsArticleCommentSnapshot\";\n\n/**\n * Retrieve a paginated list of comment snapshot records from\n * 'bbs_article_comment_snapshots'.\n *\n * This API operation retrieves a filtered and/or paginated list of comment\n * snapshot records, representing the edit histories for comments. It serves\n * both evidence management (viewing revision history) and administrative\n * oversight (monitoring modifications and IP addresses). Supports filters for\n * attributes such as comment ID(s), date range, format, or other metadata.\n *\n * The endpoint enables clients to efficiently perform evidence review, discover\n * all edits for a given comment or set of comments, and optionally aggregate\n * statistics or metadata as needed. Error handling includes invalid filter\n * criteria, pagination issues, or lack of results for the requested\n * conditions.\n *\n * @param body Filtering and pagination parameters for searching comment\n *   snapshots.\n * @path /bbs/articles/comments/snapshots\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IBbsArticleCommentSnapshot.IRequest;\n  export type Output = IPageIBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/bbs/articles/comments/snapshots\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/bbs/articles/comments/snapshots\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIBbsArticleCommentSnapshot =>\n    typia.random<IPageIBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Fetch detail information for a single comment snapshot by ID from\n * 'bbs_article_comment_snapshots'.\n *\n * This endpoint fetches detailed information about a single comment snapshot,\n * uniquely identified by its ID. It exposes all evidential attributes: body,\n * format, creation time, IP address of the modifier, and linkage to its comment\n * and parent article.\n *\n * Intended for history management screens or audit review, it supports full\n * details, including attached file metadata, and can be used to display\n * previous comment versions or investigate disputes. Related endpoints are\n * PATCH /bbs/articles/comments/snapshots (for list/search) and PUT\n * /bbs/articles/comments/snapshots/{id} (for administrative corrections, if\n * permitted). Error handling includes resource not found, or access denied if\n * applicable.\n *\n * @param id Target comment snapshot's ID.\n * @path /bbs/articles/comments/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/bbs/articles/comments/snapshots/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/comments/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update specific snapshot attributes in 'bbs_article_comment_snapshots',\n * primarily for admin use.\n *\n * This endpoint permits authorized administrative actors to update certain\n * attributes of a comment snapshot, such as correcting metadata errors or\n * annotating revisions, without breaking the snapshot audit chain. Input\n * validation ensures that evidence integrity is not violated (for example, core\n * content cannot be retroactively altered by general users). The endpoint is\n * intended for corrective or special administrative functions.\n *\n * Security is enforced by access control: only privileged accounts may utilize\n * this endpoint, and attempted use by general users will result in\n * authorization errors. Error handling includes not found, insufficient rights,\n * and input validation failures. Related operations include GET\n * /bbs/articles/comments/snapshots/{id} (for reading) and PATCH\n * /bbs/articles/comments/snapshots (for search/listing).\n *\n * @param id Target comment snapshot's ID.\n * @param body Fields for administrative update of the snapshot. Restricted to\n *   allowable attributes only.\n * @path /bbs/articles/comments/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IBbsArticleCommentSnapshot.IUpdate;\n  export type Output = IBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/bbs/articles/comments/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/comments/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically delete a comment snapshot in 'bbs_article_comment_snapshots' by ID,\n * for admin use only.\n *\n * This endpoint marks a comment snapshot as deleted (usually via a logical\n * delete flag or 'deleted_at' timestamp, in line with the overall evidence\n * preservation policy). Physical deletion from the database is forbidden; the\n * operation is reserved for administrators or regulatory compliance\n * requirements only. Related files and linkages remain for audit traceability.\n *\n * Attempts to use this endpoint without sufficient privilege are denied.\n * Related endpoints include GET /bbs/articles/comments/snapshots/{id} (for\n * reading), PUT /bbs/articles/comments/snapshots/{id} (for administrative\n * update), and DELETE /bbs/articles/comments/snapshots/{id} for logical\n * removal. Error responses occur for not found, insufficient rights, and policy\n * violations.\n *\n * @param id Target comment snapshot's ID.\n * @param body Administrative request to logically delete the given comment\n *   snapshot. Only privileged users allowed.\n * @path /bbs/articles/comments/snapshots/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseById.Input,\n): Promise<eraseById.Output> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseById {\n  export type Input = IBbsArticleCommentSnapshot.IDelete;\n  export type Output = IBbsArticleCommentSnapshot;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/bbs/articles/comments/snapshots/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/bbs/articles/comments/snapshots/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IBbsArticleCommentSnapshot => typia.random<IBbsArticleCommentSnapshot>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "src/api/functional/attachmentFiles/index.ts": "import { IConnection, HttpError } from \"@nestia/fetcher\";\nimport { PlainFetcher } from \"@nestia/fetcher/lib/PlainFetcher\";\nimport typia, { tags } from \"typia\";\nimport { NestiaSimulator } from \"@nestia/fetcher/lib/NestiaSimulator\";\n\nimport { IAttachmentFile } from \"../../structures/IAttachmentFile\";\nimport { IPageIAttachmentFile } from \"../../structures/IPageIAttachmentFile\";\n\n/**\n * Register a new attachment file in 'attachment_files' with all required\n * metadata.\n *\n * This endpoint registers a new file after upload by inserting its key metadata\n * into the 'attachment_files' schema table. It records the file name, extension\n * (if any), URL, and the creation date. Input validation ensures file name and\n * URL are present, extension is allowed or nullable, and that no collisions\n * occur for unique IDs. File upload should be processed prior to this call,\n * which is only for metadata registration and not for the binary upload process\n * itself.\n *\n * The endpoint is often called by UI file upload interfaces before associating\n * the file with posts/comments. Errors may include invalid input, file type\n * restrictions, or unique constraint violations on file ID.\n *\n * @param body Attachment file registration information (metadata only, upload\n *   handled separately).\n * @path /attachmentFiles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function post(\n  connection: IConnection,\n  body: post.Input,\n): Promise<post.Output> {\n  return !!connection.simulate\n    ? post.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...post.METADATA,\n          path: post.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace post {\n  export type Input = IAttachmentFile.ICreate;\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"POST\",\n    path: \"/attachmentFiles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/attachmentFiles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: post.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: post.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Get a paginated/searchable list of attachment files from 'attachment_files'.\n *\n * This API operation returns a list of all attachment files stored within the\n * system, with optional filters for name, extension, and creation date. Its\n * main use cases involve browsing available files, administratively locating\n * uploaded materials, and supplying metadata for attachment management\n * operations (e.g., linking files to post/comment snapshots).\n *\n * Results support pagination, sorting, and advanced search conditions. Error\n * handling ensures proper response to invalid search parameters and\n * out-of-bounds pagination values.\n *\n * @param body Filtering and pagination options for searching attachment files.\n * @path /attachmentFiles\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function patch(\n  connection: IConnection,\n  body: patch.Input,\n): Promise<patch.Output> {\n  return !!connection.simulate\n    ? patch.simulate(connection, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...patch.METADATA,\n          path: patch.path(),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace patch {\n  export type Input = IAttachmentFile.IRequest;\n  export type Output = IPageIAttachmentFile;\n\n  export const METADATA = {\n    method: \"PATCH\",\n    path: \"/attachmentFiles\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = () => \"/attachmentFiles\";\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IPageIAttachmentFile => typia.random<IPageIAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    body: patch.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: patch.path(),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Fetch information for a single attachment file by ID from 'attachment_files'.\n *\n * This API operation fetches the details of an individual attachment file by\n * its unique ID. It returns all metadata (name, extension, URL, creation time),\n * and can include cross-references to snapshots where used. Used in file\n * management screens, attachment UI, or for audit purposes.\n *\n * The endpoint validates the existence of the requested file and returns an\n * informative error if not found. Related endpoints include PATCH\n * /attachmentFiles (for listing) and DELETE /attachmentFiles/{id} (for\n * deletion).\n *\n * @param id Target attachment file's ID.\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function getById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n): Promise<getById.Output> {\n  return !!connection.simulate\n    ? getById.simulate(connection, id)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...getById.METADATA,\n          path: getById.path(id),\n          status: null,\n        },\n      );\n}\nexport namespace getById {\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"GET\",\n    path: \"/attachmentFiles/:id\",\n    request: null,\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: getById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Update metadata of an attachment file in 'attachment_files' (admin only).\n *\n * This endpoint updates fields such as the filename, extension, or other\n * attributes for an attachment file already present in the database.\n * Authorization is required (typically admin-level) to prevent accidental or\n * malicious alteration of shared files. Validation ensures referential\n * integrity with linked snapshots and prevents breaking links. Only fields\n * allowed for update by business logic can be altered; changes to URL or\n * creation dates may be restricted.\n *\n * Error handling addresses non-existent files, permission errors, and attempts\n * to update disallowed fields. Related endpoints: GET /attachmentFiles/{id}\n * (for reading), PATCH /attachmentFiles (for listing), and DELETE\n * /attachmentFiles/{id} (for deletion).\n *\n * @param id Target attachment file's ID.\n * @param body Fields for updating information about the attachment file.\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function putById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: putById.Input,\n): Promise<putById.Output> {\n  return !!connection.simulate\n    ? putById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...putById.METADATA,\n          path: putById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace putById {\n  export type Input = IAttachmentFile.IUpdate;\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"PUT\",\n    path: \"/attachmentFiles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: putById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: putById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n\n/**\n * Logically delete an attachment file by ID in 'attachment_files' (admin only,\n * prevents deletion if referenced).\n *\n * This endpoint marks an attachment file as logically deleted (typically by\n * setting a flag or deletion timestamp) to preserve auditability and avoid\n * removing files that may still be linked from evidence snapshots. Actual file\n * removal from storage, if any, is beyond the scope of this endpoint.\n * Authorization is enforced for only privileged users (like admins) to use this\n * endpoint.\n *\n * Before deletion, the system checks that the file is not referenced by any\n * snapshots to prevent orphaning or evidence loss. Any deletion attempt for\n * files still in use results in an error. Related endpoints: PUT\n * /attachmentFiles/{id} (for update) and GET /attachmentFiles/{id} (for\n * reading).\n *\n * @param id Target attachment file's ID.\n * @param body Logical deletion request for attachment file, with admin\n *   authorization.\n * @path /attachmentFiles/:id\n * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe\n */\nexport async function eraseById(\n  connection: IConnection,\n  id: string & tags.Format<\"uuid\">,\n  body: eraseById.Input,\n): Promise<eraseById.Output> {\n  return !!connection.simulate\n    ? eraseById.simulate(connection, id, body)\n    : PlainFetcher.fetch(\n        {\n          ...connection,\n          headers: {\n            ...connection.headers,\n            \"Content-Type\": \"application/json\",\n          },\n        },\n        {\n          ...eraseById.METADATA,\n          path: eraseById.path(id),\n          status: null,\n        },\n        body,\n      );\n}\nexport namespace eraseById {\n  export type Input = IAttachmentFile.IDelete;\n  export type Output = IAttachmentFile;\n\n  export const METADATA = {\n    method: \"DELETE\",\n    path: \"/attachmentFiles/:id\",\n    request: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n    response: {\n      type: \"application/json\",\n      encrypted: false,\n    },\n  } as const;\n\n  export const path = (id: string & tags.Format<\"uuid\">) =>\n    `/attachmentFiles/${encodeURIComponent(id ?? \"null\")}`;\n  export const random = (\n    g?: Partial<typia.IRandomGenerator>,\n  ): IAttachmentFile => typia.random<IAttachmentFile>(g);\n  export const simulate = (\n    connection: IConnection,\n    id: string & tags.Format<\"uuid\">,\n    body: eraseById.Input,\n  ): Output => {\n    const assert = NestiaSimulator.assert({\n      method: METADATA.method,\n      host: connection.host,\n      path: eraseById.path(id),\n      contentType: \"application/json\",\n    });\n    try {\n      assert.param(\"id\")(() => typia.assert(id));\n      assert.body(() => typia.assert(body));\n    } catch (exp) {\n      if (!typia.is<HttpError>(exp)) throw exp;\n      return {\n        success: false,\n        status: exp.status,\n        headers: exp.headers,\n        data: exp.toJSON().message,\n      } as any;\n    }\n    return random(\n      \"object\" === typeof connection.simulate && null !== connection.simulate\n        ? connection.simulate\n        : undefined,\n    );\n  };\n}\n",
      "test/features/api/test_api_bbs_articles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_post(connection: api.IConnection) {\n  const output: IBbsArticle = await api.functional.bbs.articles.post(\n    connection,\n    typia.random<IBbsArticle.ICreate>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticle\";\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_patch(connection: api.IConnection) {\n  const output: IPageIBbsArticle.ISummary =\n    await api.functional.bbs.articles.patch(\n      connection,\n      typia.random<IBbsArticle.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.getById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_putById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.putById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IBbsArticle.IUpdate>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticle } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticle\";\n\nexport async function test_api_bbs_articles_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticle = await api.functional.bbs.articles.eraseById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IBbsArticle.IDelete>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_snapshots_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleSnapshot\";\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleSnapshot.ISummary =\n    await api.functional.bbs.articles.snapshots.patch(\n      connection,\n      typia.random<IBbsArticleSnapshot.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_snapshots_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.getById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_snapshots_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_putById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.putById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleSnapshot.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_snapshots_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleSnapshot\";\n\nexport async function test_api_bbs_articles_snapshots_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleSnapshot =\n    await api.functional.bbs.articles.snapshots.eraseById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_postByArticleid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_postByArticleid(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.postByArticleid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.ICreate>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_patchByArticleid.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IPageIBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleComment\";\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_patchByArticleid(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleComment.ISummary =\n    await api.functional.bbs.articles.comments.patchByArticleid(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_getByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_getByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.getByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_putByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_putByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.putByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_eraseByArticleidAndId.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleComment } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleComment\";\n\nexport async function test_api_bbs_articles_comments_eraseByArticleidAndId(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleComment =\n    await api.functional.bbs.articles.comments.eraseByArticleidAndId(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleComment.IDelete>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_snapshots_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIBbsArticleCommentSnapshot\";\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.patch(\n      connection,\n      typia.random<IBbsArticleCommentSnapshot.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_snapshots_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_getById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.getById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_snapshots_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_putById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.putById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleCommentSnapshot.IUpdate>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_bbs_articles_comments_snapshots_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IBbsArticleCommentSnapshot } from \"@ORGANIZATION/PROJECT-api/lib/structures/IBbsArticleCommentSnapshot\";\n\nexport async function test_api_bbs_articles_comments_snapshots_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IBbsArticleCommentSnapshot =\n    await api.functional.bbs.articles.comments.snapshots.eraseById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IBbsArticleCommentSnapshot.IDelete>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_attachmentFiles_post.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_post(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.post(\n    connection,\n    typia.random<IAttachmentFile.ICreate>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_attachmentFiles_patch.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia from \"typia\";\n\nimport { IPageIAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IPageIAttachmentFile\";\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_patch(\n  connection: api.IConnection,\n) {\n  const output: IPageIAttachmentFile =\n    await api.functional.attachmentFiles.patch(\n      connection,\n      typia.random<IAttachmentFile.IRequest>(),\n    );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_attachmentFiles_getById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_getById(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.getById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_attachmentFiles_putById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_putById(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile = await api.functional.attachmentFiles.putById(\n    connection,\n    typia.random<string & tags.Format<\"uuid\">>(),\n    typia.random<IAttachmentFile.IUpdate>(),\n  );\n  typia.assert(output);\n}\n",
      "test/features/api/test_api_attachmentFiles_eraseById.ts": "import api from \"@ORGANIZATION/PROJECT-api\";\nimport typia, { tags } from \"typia\";\n\nimport { IAttachmentFile } from \"@ORGANIZATION/PROJECT-api/lib/structures/IAttachmentFile\";\n\nexport async function test_api_attachmentFiles_eraseById(\n  connection: api.IConnection,\n) {\n  const output: IAttachmentFile =\n    await api.functional.attachmentFiles.eraseById(\n      connection,\n      typia.random<string & tags.Format<\"uuid\">>(),\n      typia.random<IAttachmentFile.IDelete>(),\n    );\n  typia.assert(output);\n}\n",
      "packages/api/swagger.json": "{\n  \"openapi\": \"3.1.0\",\n  \"paths\": {\n    \"/bbs/articles\": {\n      \"patch\": {\n        \"summary\": \"List articles from bbs_articles with searching, pagination, and summary info.\",\n        \"description\": \"This API endpoint allows clients to retrieve a paginated, filtered, and/or sorted list of bulletin board articles. It references the bbs_articles table in Prisma, which holds basic post identity and author information, as well as deletion markers. Results typically include only non-deleted articles for general users (unless special admin permission is given). \\n\\nEach article summary should include the latest title (from the latest snapshot), author, creation time, and comment count. Filters may include search by title, author, date ranges, and possibly presence of comments. The endpoint should work efficiently by leveraging indexes on created_at and deleted_at for best performance. Soft-deleted posts are omitted except for admin access.\\n\\nRequest parameters support pagination with cursor/limit or offset/limit. Security: Access to deleted articles may depend on user role; listing of all (including deleted) may require admin level. Related API operation: GET /bbs/articles/{id} for detailed information. Errors for invalid search parameters, forbidden access, or server errors follow consistent patterns.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Request parameters for listing articles, including filters (title, author, date), pagination (cursor/limit or offset/limit), and sorting options.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticle.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paged result containing articles' summary information, latest snapshot info, and comment counts.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a bulletin board article (bbs_articles + initial snapshot, with attachments).\",\n        \"description\": \"This endpoint allows a user to create a new bulletin board article. Upon invocation, a new record in bbs_articles is inserted, as well as a first snapshot in bbs_article_snapshots, containing the initial version's body, format, title, and IP address of the request. Attachments may also be uploaded and associated via attachment_files and bbs_article_snapshot_files junction.\\n\\nThe author provides a writer name, password (which must be encrypted before storage), and content (title, body, format). An array of file metadata may also be included. This route enforces presence of all required fields and validates file upload if present.\\n\\nSecurity: Password is stored only as a hash; plaintext password must not be stored. All significant actions (including IP address capture) must be logged and linked to the snapshot. Failure scenarios include missing/invalid required fields, unsupported file types, or database errors. Related: Modification is handled via PUT /bbs/articles/{id}; version retrieval by PATCH /bbs/articles/snapshots.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New article creation info including writer, password, initial title and body, format, and optional file attachments.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Created article info, including references to its first snapshot and any attachments.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{id}\": {\n      \"get\": {\n        \"summary\": \"Get detail on a single article (bbs_articles & latest snapshot, attachments, safe info).\",\n        \"description\": \"This endpoint retrieves all information required for a specific article, given its unique id (UUID). It uses the bbs_articles table to obtain author, creation time, and status (deleted or not). The latest version is provided by linking to the most recent bbs_article_snapshots record, including title, body, and format. Attachments related to the latest snapshot are also returned.\\n\\nIf the article is soft-deleted, its access may be restricted to admin-level or special permission users. IP information may be redacted for standard users to enhance privacy. The endpoint returns an error if the id is invalid or the article does not exist. This operation does not modify the database and is considered safe for client retrieval.\\n\\nRelated API: PATCH /bbs/articles for the listing. Errors adhere to the API's standard error response structure.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The article's unique identifier (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"All detail about the article, including metadata, current snapshot, and attachment files.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Modify an article (bbs_articles): add snapshot and optionally modify attachments.\",\n        \"description\": \"This endpoint enables the modification of a previously created article. Modifications do not overwrite existing articles but result in a new record in bbs_article_snapshots linked to the same article. It enforces password verification against the article's hashed password before proceeding. Authors can change the title, body, body format, and update attachments through this operation.\\n\\nThe endpoint requires the article id, the writer's password (to be verified), and the new content. Attachments can be modified (added, removed, reordered) by specifying their metadata. If the password is invalid or missing, the operation fails with an appropriate error. Only non-deleted articles can be modified unless special permissions are given.\\n\\nSecurity: Store IP address and record the modification time. Existing snapshots remain immutable to preserve evidence/history. Updates to associated attachments create new junction entries for the new snapshot. Related API: GET /bbs/articles/{id} to fetch new version, PATCH /bbs/articles/snapshots to list all versions. All error and success responses follow universal API schema.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Article's unique identifier (UUID) to update.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Update info for an article, including new title/body/format, re-attachment info, and password verification.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Article info and the newly created snapshot (representing the update), with attachments.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Soft-delete (logical delete) a bulletin board article. Only marks deleted_at, no physical removal.\",\n        \"description\": \"This endpoint is for logically deleting an existing bulletin board article. It only marks the deleted_at field with the current timestamp, preserving the record for evidence and possible future administrative review. The request must include password verification for standard users; admin users may delete without password depending on config/policy. If the password is invalid or missing, the deletion will fail.\\n\\nLogically deleted articles are not shown in public lists but are still accessible for admin/forensic reasons. Physical deletion is never performed to maintain history. Errors are returned if the article is not found, already deleted, or password is incorrect. The operation records who (user, IP) deleted the item.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Article's unique identifier (UUID) to soft-delete.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticle.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Password for soft-deletion verification if not admin. Admins may bypass password check.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticle\"\n                }\n              }\n            },\n            \"description\": \"Confirmation, updated article info (with deleted_at time set).\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/snapshots\": {\n      \"patch\": {\n        \"summary\": \"List (paged) article snapshots from bbs_article_snapshots, filter by article id, etc.\",\n        \"description\": \"This endpoint provides a paginated, filterable, and sortable list of all article snapshots (historical versions), from the bbs_article_snapshots Prisma table. Clients can use this to access the full modification history for articles. \\n\\nSearch/explore versions by article id, creation time, writer IP, format, or keywords in title/body; efficient index access is required for performance. Pagination parameters are mandatory for scalability with growing history. Deleted articles' snapshots may be accessible to admins only. For standard users, only versions for non-deleted articles are returned. Snapshots include all version metadata (format, title, body, created_at, IP) and attachment references.\\n\\nRelated API: PATCH /bbs/articles for article overviews, GET /bbs/articles/snapshots/{id} for version detail.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Snapshot search parameters: filters for article id, date ranges, IP, body/title keywords; plus pagination info.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleSnapshot.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paged result of article snapshots with metadata and attachment summaries.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Get details of one article snapshot (version), including all metadata and its attachments.\",\n        \"description\": \"This operation returns the full metadata for a specified article snapshot (by UUID), including all version metadata (title, body, format, created_at, IP address) and linked attachment file info. It is typically used to view historical versions of an article for evidence or audit purposes.\\n\\nAppropriate authorization may be required if the snapshot is for an article that has been deleted or is restricted. Errors are returned for non-existent IDs or unauthorized access. IP addresses may only be visible to admins. No modification of state occurs here.\\n\\nSecurity: Carefully audit access to preserve privacy. Related: POST/PATCH to list versions, parent article access via GET /bbs/articles/{id}. Error responses standardized.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Snapshot's unique identifier (UUID).\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Snapshot detail including metadata and attachments.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Modify snapshot record's metadata (admin/forensic use only), not the actual version content.\",\n        \"description\": \"This admin-facing endpoint (rarely exposed to end-users) allows for partial updates (e.g., tagging or meta-corrections) to a specific snapshot record, identified by its UUID. Typical users will not modify snapshots (snapshots are append-only); this is for exceptional forensic or administrative cases.\\n\\nPermitted updates may include internal metadata such as status tagging or moderation flags, but NOT revision of original title/body/IP, to preserve evidence. Access strictly controlled; all actions audited. Operation rejected if forbidden fields are attempted to be changed or user is unauthorized. Related: GET /bbs/articles/snapshots/{id} for version details.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Snapshot's UUID.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Patch request for allowed snapshot metadata fields (typ. tagging/status/mod notes).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Snapshot record with updated metadata.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Permanently delete an article snapshot (admin maintenance/correction use), not for public users.\",\n        \"description\": \"This highly restricted endpoint allows physical deletion of a single article snapshot by its UUID. Typically, this would only be permitted in cases of evidence tampering, privacy requests, or system maintenance. Regular users have no access.\\n\\nThe operation removes the historical version and updates all connected records accordingly. Audit logs should capture all deletions. Invalid/dependent snapshot deletion attempts result in errors. Recognize that removing a snapshot could compromise historical integrity, so authorization and safety nets must be ensured. Related: GET for details, PATCH for list.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Snapshot's UUID.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Confirmation/metadata of deleted snapshot, or empty response.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments\": {\n      \"patch\": {\n        \"summary\": \"Get a paginated and hierarchical list of comments for an article, showing current body.\",\n        \"description\": \"This endpoint provides retrieval of a hierarchical, paginated, and searchable/commentable list of comments related to a particular article. Queries bbs_article_comments table for all comments (excluding deleted unless admin), joined with their latest snapshot record for current body/display (from bbs_article_comment_snapshots). Supports threaded replies with unlimited depth via parent_id.\\n\\nFilters include parent_id (for fetching root comments or replies), writer name, creation time, and support for pagination for large inputs. By default, only non-deleted comments are returned. Role-based logic may allow access to deleted comments for admins. Sorting can include time or hierarchy order.\\n\\nEfficient tree retrieval is required for good performance with nesting. Related endpoints: POST for new comment; GET /bbs/articles/{articleId}/comments/{id} for comment detail.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Article UUID for which to fetch comments.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Comment list request parameters: pagination, optional parent_id for segment, or search filters.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleComment.ISummary\"\n                }\n              }\n            },\n            \"description\": \"Paged list/hierarchy of comments with metadata and their latest version body, excludes deleted unless admin.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Create a new comment or reply to an article, supporting nesting and attachments. Snapshots required for history.\",\n        \"description\": \"Enables the creation of a new comment (reply or root) on a specific article, specified by articleId. A record is inserted into bbs_article_comments along with a corresponding first snapshot in bbs_article_comment_snapshots (body, format, IP). This supports direct comments or reply chains by specifying parent_id in the body (for nested comments).\\n\\nComment must include writer, password (stored securely via hash), body, format, and can optionally reference files. Enforces required fields, validates permissions, checks nesting rules. Upon creation, the first snapshot is linked and metadata set. Logical deletion applies for future removal, not on creation.\\n\\nSecurity: All actions (IP, times) are audited; sensitive data such as passwords are hashed before storage. Failure triggers: missing/invalid params, wrong parent/article ID, DB errors. Related: PATCH for comment list; GET for comment details.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"UUID of the article to comment on.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.ICreate\"\n              }\n            }\n          },\n          \"description\": \"New comment info: writer, password, body, format, parent_id (for reply), optional attachments.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"Newly created comment (and its first snapshot) with metadata, body, and attachments.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/{articleId}/comments/{id}\": {\n      \"get\": {\n        \"summary\": \"Get full details (including snapshot, attachments, and hierarchy) for one comment on an article.\",\n        \"description\": \"This endpoint fetches the full details for a single comment on a given article. Accepts the articleId for context and the comment's uuid as id. Joins the bbs_article_comments table (for metadata, writer, deletion status) with latest snapshot (from bbs_article_comment_snapshots) for body/format. Also fetches attachment info for the snapshot.\\n\\nDetails include: creation and (if) deletion timestamps, author, format, body, all attachments for the most recent version, parent/child info for replies, and optional list of immediate child comment IDs (to facilitate threaded UIs). Deleted comments are shown only with special permission (admin). If not found or not permitted, appropriate error returns.\\n\\nRelated: PATCH for listing, POST for creation. Error codes are standardized across comment operations.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"The article UUID where the comment belongs.\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Comment's UUID to consult.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"Comment detail with latest version body/format, metadata, and all attachments.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update existing comment information in 'bbs_article_comments' for a given article and comment.\",\n        \"description\": \"This API endpoint allows a user to update a specific comment in the bulletin board system while maintaining a snapshot of the modification for evidence. The operation is secured by requiring the correct password for comment modification, as dictated by the system's security policy. On execution, a new snapshot will be generated, storing the old version and the modifying client's IP address, as per the evidential design. Only non-deleted comments are modifiable; comments previously soft-deleted (deleted_at set) will be rejected.\\n\\nValidation rules enforce existence of the referenced article and comment, correct hierarchical relationships for nested replies, required fields, and adherence to data consistency regarding attachments and format. The operation also ensures that password hashes are compared and never exposed in the API, supporting encrypted password storage.\\n\\nThis endpoint is related to: GET /bbs/articles/{articleId}/comments/{id} (fetch detail), POST /bbs/articles/{articleId}/comments (creation), and DELETE /bbs/articles/{articleId}/comments/{id} (logical deletion). Error responses include unauthorized modification, resource not found, and input validation failures.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Updated data for the comment. Requires writer and password for authentication, and allows update of body/content fields.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"Updated comment info with latest snapshot reference.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically delete a comment (set deleted_at) in 'bbs_article_comments' for a given article and comment ID.\",\n        \"description\": \"This endpoint marks a specified comment under a particular article as deleted (soft delete). In accordance with the requirements, the comment is not physically removed, but its 'deleted_at' field is set to the current timestamp. If the supplied password does not match or the comment is already deleted, an error is returned. All historical snapshots for the comment are preserved, ensuring the full audit log needed for dispute resolution.\\n\\nThe endpoint performs validation for the existence of both the article and comment, ensures correct authorization (password validation), and returns the final comment record reflecting the logical deletion. This supports system requirements for evidence retention and access control for administrators.\",\n        \"parameters\": [\n          {\n            \"name\": \"articleId\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target article's ID\",\n            \"required\": true\n          },\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment's ID\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleComment.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Password required for logical deletion/authentication.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment\"\n                }\n              }\n            },\n            \"description\": \"Comment info after logical deletion (deleted_at set).\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/comments/snapshots\": {\n      \"patch\": {\n        \"summary\": \"Retrieve a paginated list of comment snapshot records from 'bbs_article_comment_snapshots'.\",\n        \"description\": \"This API operation retrieves a filtered and/or paginated list of comment snapshot records, representing the edit histories for comments. It serves both evidence management (viewing revision history) and administrative oversight (monitoring modifications and IP addresses). Supports filters for attributes such as comment ID(s), date range, format, or other metadata.\\n\\nThe endpoint enables clients to efficiently perform evidence review, discover all edits for a given comment or set of comments, and optionally aggregate statistics or metadata as needed. Error handling includes invalid filter criteria, pagination issues, or lack of results for the requested conditions.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering and pagination parameters for searching comment snapshots.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Paginated result of comment snapshot entities with filtering info.\"\n          }\n        }\n      }\n    },\n    \"/bbs/articles/comments/snapshots/{id}\": {\n      \"get\": {\n        \"summary\": \"Fetch detail information for a single comment snapshot by ID from 'bbs_article_comment_snapshots'.\",\n        \"description\": \"This endpoint fetches detailed information about a single comment snapshot, uniquely identified by its ID. It exposes all evidential attributes: body, format, creation time, IP address of the modifier, and linkage to its comment and parent article.\\n\\nIntended for history management screens or audit review, it supports full details, including attached file metadata, and can be used to display previous comment versions or investigate disputes. Related endpoints are PATCH /bbs/articles/comments/snapshots (for list/search) and PUT /bbs/articles/comments/snapshots/{id} (for administrative corrections, if permitted). Error handling includes resource not found, or access denied if applicable.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"The full information for a given comment snapshot, including content, meta, and file links.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update specific snapshot attributes in 'bbs_article_comment_snapshots', primarily for admin use.\",\n        \"description\": \"This endpoint permits authorized administrative actors to update certain attributes of a comment snapshot, such as correcting metadata errors or annotating revisions, without breaking the snapshot audit chain. Input validation ensures that evidence integrity is not violated (for example, core content cannot be retroactively altered by general users). The endpoint is intended for corrective or special administrative functions.\\n\\nSecurity is enforced by access control: only privileged accounts may utilize this endpoint, and attempted use by general users will result in authorization errors. Error handling includes not found, insufficient rights, and input validation failures. Related operations include GET /bbs/articles/comments/snapshots/{id} (for reading) and PATCH /bbs/articles/comments/snapshots (for search/listing).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields for administrative update of the snapshot. Restricted to allowable attributes only.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"Updated comment snapshot info with admin/meta corrections applied.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically delete a comment snapshot in 'bbs_article_comment_snapshots' by ID, for admin use only.\",\n        \"description\": \"This endpoint marks a comment snapshot as deleted (usually via a logical delete flag or 'deleted_at' timestamp, in line with the overall evidence preservation policy). Physical deletion from the database is forbidden; the operation is reserved for administrators or regulatory compliance requirements only. Related files and linkages remain for audit traceability.\\n\\nAttempts to use this endpoint without sufficient privilege are denied. Related endpoints include GET /bbs/articles/comments/snapshots/{id} (for reading), PUT /bbs/articles/comments/snapshots/{id} (for administrative update), and DELETE /bbs/articles/comments/snapshots/{id} for logical removal. Error responses occur for not found, insufficient rights, and policy violations.\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target comment snapshot's ID.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Administrative request to logically delete the given comment snapshot. Only privileged users allowed.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n                }\n              }\n            },\n            \"description\": \"The logically deleted comment snapshot info, with deletion meta/flag set.\"\n          }\n        }\n      }\n    },\n    \"/attachmentFiles\": {\n      \"patch\": {\n        \"summary\": \"Get a paginated/searchable list of attachment files from 'attachment_files'.\",\n        \"description\": \"This API operation returns a list of all attachment files stored within the system, with optional filters for name, extension, and creation date. Its main use cases involve browsing available files, administratively locating uploaded materials, and supplying metadata for attachment management operations (e.g., linking files to post/comment snapshots).\\n\\nResults support pagination, sorting, and advanced search conditions. Error handling ensures proper response to invalid search parameters and out-of-bounds pagination values.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.IRequest\"\n              }\n            }\n          },\n          \"description\": \"Filtering and pagination options for searching attachment files.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IPageIAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Paginated, filtered list of matching attachment file entities.\"\n          }\n        }\n      },\n      \"post\": {\n        \"summary\": \"Register a new attachment file in 'attachment_files' with all required metadata.\",\n        \"description\": \"This endpoint registers a new file after upload by inserting its key metadata into the 'attachment_files' schema table. It records the file name, extension (if any), URL, and the creation date. Input validation ensures file name and URL are present, extension is allowed or nullable, and that no collisions occur for unique IDs. File upload should be processed prior to this call, which is only for metadata registration and not for the binary upload process itself.\\n\\nThe endpoint is often called by UI file upload interfaces before associating the file with posts/comments. Errors may include invalid input, file type restrictions, or unique constraint violations on file ID.\",\n        \"parameters\": [],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.ICreate\"\n              }\n            }\n          },\n          \"description\": \"Attachment file registration information (metadata only, upload handled separately).\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"201\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Attachment file metadata referencing the stored/uploaded file.\"\n          }\n        }\n      }\n    },\n    \"/attachmentFiles/{id}\": {\n      \"get\": {\n        \"summary\": \"Fetch information for a single attachment file by ID from 'attachment_files'.\",\n        \"description\": \"This API operation fetches the details of an individual attachment file by its unique ID. It returns all metadata (name, extension, URL, creation time), and can include cross-references to snapshots where used. Used in file management screens, attachment UI, or for audit purposes.\\n\\nThe endpoint validates the existence of the requested file and returns an informative error if not found. Related endpoints include PATCH /attachmentFiles (for listing) and DELETE /attachmentFiles/{id} (for deletion).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment file's ID.\",\n            \"required\": true\n          }\n        ],\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Complete metadata for the requested attachment file.\"\n          }\n        }\n      },\n      \"put\": {\n        \"summary\": \"Update metadata of an attachment file in 'attachment_files' (admin only).\",\n        \"description\": \"This endpoint updates fields such as the filename, extension, or other attributes for an attachment file already present in the database. Authorization is required (typically admin-level) to prevent accidental or malicious alteration of shared files. Validation ensures referential integrity with linked snapshots and prevents breaking links. Only fields allowed for update by business logic can be altered; changes to URL or creation dates may be restricted.\\n\\nError handling addresses non-existent files, permission errors, and attempts to update disallowed fields. Related endpoints: GET /attachmentFiles/{id} (for reading), PATCH /attachmentFiles (for listing), and DELETE /attachmentFiles/{id} (for deletion).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment file's ID.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.IUpdate\"\n              }\n            }\n          },\n          \"description\": \"Fields for updating information about the attachment file.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Updated metadata of the attachment file entity.\"\n          }\n        }\n      },\n      \"delete\": {\n        \"summary\": \"Logically delete an attachment file by ID in 'attachment_files' (admin only, prevents deletion if referenced).\",\n        \"description\": \"This endpoint marks an attachment file as logically deleted (typically by setting a flag or deletion timestamp) to preserve auditability and avoid removing files that may still be linked from evidence snapshots. Actual file removal from storage, if any, is beyond the scope of this endpoint. Authorization is enforced for only privileged users (like admins) to use this endpoint.\\n\\nBefore deletion, the system checks that the file is not referenced by any snapshots to prevent orphaning or evidence loss. Any deletion attempt for files still in use results in an error. Related endpoints: PUT /attachmentFiles/{id} (for update) and GET /attachmentFiles/{id} (for reading).\",\n        \"parameters\": [\n          {\n            \"name\": \"id\",\n            \"in\": \"path\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"Target attachment file's ID.\",\n            \"required\": true\n          }\n        ],\n        \"requestBody\": {\n          \"content\": {\n            \"application/json\": {\n              \"schema\": {\n                \"$ref\": \"#/components/schemas/IAttachmentFile.IDelete\"\n              }\n            }\n          },\n          \"description\": \"Logical deletion request for attachment file, with admin authorization.\",\n          \"required\": true\n        },\n        \"responses\": {\n          \"200\": {\n            \"content\": {\n              \"application/json\": {\n                \"schema\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                }\n              }\n            },\n            \"description\": \"Attachment file entity after logical deletion (flag set or deleted).\"\n          }\n        }\n      }\n    }\n  },\n  \"components\": {\n    \"schemas\": {\n      \"IBbsArticle.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"The page number for pagination.\\n\\nPrisma schema correspondence: BBS article list query pagination. Optional value.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Number of articles per page. Defaults to 100.\\n\\nPrisma schema correspondence: Used in paginated queries.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's name filter.\\n\\nPrisma: bbs_articles.writer.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Article title filter. Search will apply to the latest snapshot's title.\\n\\nPrisma: bbs_article_snapshots.title.\"\n          },\n          \"date_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Start date/time for filtering articles by creation time.\\n\\nPrisma: bbs_articles.created_at.\"\n          },\n          \"date_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"End date/time for filtering articles by creation time.\\n\\nPrisma: bbs_articles.created_at.\"\n          },\n          \"has_comment\": {\n            \"type\": \"boolean\",\n            \"description\": \"Filter for articles with or without comments.\\n\\nPrisma: bbs_article_comments (count > 0).\"\n          }\n        },\n        \"description\": \"Request parameters for listing/filtering bulletin board articles.\\n\\nReferences bbs_articles for identity, and bbs_article_snapshots for title filters. Supports pagination, search, and filter criteria. Used for PATCH /bbs/articles list endpoint.\",\n        \"required\": []\n      },\n      \"IPageIBbsArticle.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticle.ISummary\"\n            },\n            \"description\": \"List of summary objects for articles.\\n\\nEach includes last snapshot's title and metadata.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated result containing summary information for multiple bulletin board articles.\\n\\nUsed as the return type for article list endpoints with filtering, sort and pagination.\"\n      },\n      \"IBbsArticle.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the article.\\n\\nPrisma: bbs_articles.id.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the article writer. \\n\\nPrisma: bbs_articles.writer.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Creation timestamp of the article.\\n\\nPrisma: bbs_articles.created_at.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Deletion timestamp, if the article has been deleted (logical delete).\\n\\nPrisma: bbs_articles.deleted_at.\\n\\nNull when not deleted.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Deletion timestamp, if the article has been deleted (logical delete).\\n\\nPrisma: bbs_articles.deleted_at.\\n\\nNull when not deleted.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"The title of the latest snapshot for the article.\\n\\nPrisma: bbs_article_snapshots.title (most recent).\"\n          },\n          \"comment_count\": {\n            \"type\": \"integer\",\n            \"description\": \"The number of non-deleted comments on the article.\\n\\nCalculated from bbs_article_comments where deleted_at is null.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"writer\",\n          \"created_at\",\n          \"title\",\n          \"comment_count\"\n        ],\n        \"description\": \"Summary output for a bulletin board article. Contains identifying and display information, including latest title and comment count.\\n\\nDraws on bbs_articles and latest record in bbs_article_snapshots.\"\n      },\n      \"IBbsArticle.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the article's writer. Required on creation.\\n\\nPrisma: bbs_articles.writer.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Write-access password for the article, supplied as plain text and stored hashed.\\n\\nPrisma: bbs_articles.password.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Article's initial title.\\n\\nStored within the first snapshot. Prisma: bbs_article_snapshots.title.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"The initial body/content of the article.\\n\\nPrisma: bbs_article_snapshots.body.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the article body (e.g., 'md', 'html', 'txt').\\n\\nPrisma: bbs_article_snapshots.format.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"List of attachment file UUIDs to be linked with initial snapshot (order preserved). Optional.\\n\\nPrisma: bbs_article_snapshot_files. Can be empty array.\"\n          }\n        },\n        \"required\": [\n          \"writer\",\n          \"password\",\n          \"title\",\n          \"body\",\n          \"format\"\n        ],\n        \"description\": \"Request body to create a new article. Includes metadata, content, attachments.\\n\\nMaps to bbs_articles for writer/password and to bbs_article_snapshots for content/history. Passwords are never stored in plain text after receipt.\"\n      },\n      \"IBbsArticle\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the article.\\n\\nPrisma: bbs_articles.id.\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"The article's writer name.\\n\\nPrisma: bbs_articles.writer.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Time article was created.\\n\\nPrisma: bbs_articles.created_at.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Logical deletion timestamp. Set on article deletion, or null if not deleted.\\n\\nPrisma: bbs_articles.deleted_at.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Logical deletion timestamp. Set on article deletion, or null if not deleted.\\n\\nPrisma: bbs_articles.deleted_at.\"\n          },\n          \"latest_snapshot\": {\n            \"$ref\": \"#/components/schemas/IBbsArticleSnapshot\",\n            \"description\": \"Current/latest snapshot information for the article (title/body/format).\\n\\nReferences most recent bbs_article_snapshots record.\"\n          },\n          \"comment_count\": {\n            \"type\": \"integer\",\n            \"description\": \"Number of non-deleted comments attached to this article.\\n\\nDerived from bbs_article_comments.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"description\": \"Files attached to the latest article snapshot, ordered.\\n\\nReferences attachment_files via bbs_article_snapshot_files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"writer\",\n          \"created_at\",\n          \"latest_snapshot\",\n          \"comment_count\"\n        ],\n        \"description\": \"Full representation of a bulletin board article, including metadata, current version info, comments count, and attachments.\\n\\nCombines bbs_articles with latest bbs_article_snapshots and relevant relationships.\"\n      },\n      \"IBbsArticle.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's password for authentication prior to modification.\\n\\nPrisma: bbs_articles.password (hashed, verify only).\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Updated article title (becomes latest snapshot when modified).\\n\\nPrisma: bbs_article_snapshots.title.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Updated article content/body.\\n\\nPrisma: bbs_article_snapshots.body.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Updated body format (e.g., 'md', 'html', 'txt').\\n\\nPrisma: bbs_article_snapshots.format.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"type\": \"string\",\n              \"format\": \"uuid\"\n            },\n            \"description\": \"New array of attachment file UUIDs to associate with new snapshot (order preserved). Optional.\\n\\nPrisma: bbs_article_snapshot_files.\"\n          }\n        },\n        \"required\": [\n          \"password\",\n          \"title\",\n          \"body\",\n          \"format\"\n        ],\n        \"description\": \"Body for updating an article. All modifications result in creation of a new snapshot with revised content/attachments.\\n\\nRequires password verification for security. Snapshots are appended, not overwritten.\"\n      },\n      \"IBbsArticle.IDelete\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Password for writer authentication prior to logical deletion.\\n\\nPrisma: bbs_articles.password. Admins may not require.\"\n          }\n        },\n        \"required\": [\n          \"password\"\n        ],\n        \"description\": \"Delete request body for soft-deletion of an article. Verifies password.\\n\\nMarks deleted_at, but keeps record for dispute evidence preservation. Only privileged roles may bypass password.\"\n      },\n      \"IBbsArticleSnapshot.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"page\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Pagination: page number.\\n\\nUsed for paginated history listing.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"format\": \"uint32\",\n            \"description\": \"Pagination: number of items per page.\\n\\nDefaults to 100.\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Filter snapshots to a single article.\\n\\nPrisma: bbs_article_snapshots.bbs_article_id.\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address filter for snapshot writer.\\n\\nPrisma: bbs_article_snapshots.ip.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Body format filter (e.g., 'md', 'html', 'txt').\\n\\nPrisma: bbs_article_snapshots.format.\"\n          },\n          \"date_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Filter: Only snapshots created after this ISO datetime.\"\n          },\n          \"date_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Filter: Only snapshots created before this ISO datetime.\"\n          }\n        },\n        \"description\": \"Request body for searching/listing article snapshots. Supports filter and pagination fields. Used for PATCH /bbs/articles/snapshots endpoint.\",\n        \"required\": []\n      },\n      \"IPageIBbsArticleSnapshot.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleSnapshot.ISummary\"\n            },\n            \"description\": \"List of article snapshot summaries (basic version info, omitting full body).\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated result type for listing snapshot summaries for articles.\\n\\nAggregates bbs_article_snapshots metadata for multiple snapshots.\"\n      },\n      \"IBbsArticleSnapshot.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the article snapshot.\\n\\nPrisma: bbs_article_snapshots.id.\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Article to which this snapshot belongs.\\n\\nPrisma: bbs_article_snapshots.bbs_article_id.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Title for this version of the article.\\n\\nPrisma: bbs_article_snapshots.title.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Body format for this version.\\n\\nPrisma: bbs_article_snapshots.format.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp (ISO) when this snapshot record was created.\\n\\nPrisma: bbs_article_snapshots.created_at.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_id\",\n          \"title\",\n          \"format\",\n          \"created_at\"\n        ],\n        \"description\": \"Summary object for an article snapshot, containing identifying info and display metadata.\\n\\nExcludes body/content and attachments.\"\n      },\n      \"IBbsArticleSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID for this article snapshot (version record).\\n\\nPrisma: bbs_article_snapshots.id.\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Article this version belongs to.\\n\\nPrisma: bbs_article_snapshots.bbs_article_id.\"\n          },\n          \"title\": {\n            \"type\": \"string\",\n            \"description\": \"Display title for this version state.\\n\\nPrisma: bbs_article_snapshots.title.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Content body of the article at this snapshot/version.\\n\\nPrisma: bbs_article_snapshots.body.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Body format (e.g., md, html, txt).\\n\\nPrisma: bbs_article_snapshots.format.\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address of the snapshot's author/editor.\\n\\nPrisma: bbs_article_snapshots.ip.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp when the snapshot was created.\\n\\nPrisma: bbs_article_snapshots.created_at.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"description\": \"Attachment files for this article snapshot, in order.\\n\\nReferences attachment_files via bbs_article_snapshot_files.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_id\",\n          \"title\",\n          \"body\",\n          \"format\",\n          \"ip\",\n          \"created_at\"\n        ],\n        \"description\": \"Full representation of a specific article snapshot/version. Contains title, content, author IP, creation time, and all associated attachments.\\n\\nMaps to bbs_article_snapshots, attachment_files, and related junction tables.\"\n      },\n      \"IAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the attachment file. Prisma column: id.\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Filename without extension (original name).\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension, e.g., 'png', 'pdf'. May be blank or null.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"URL (complete path) where this file can be downloaded or viewed. Prisma: url.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp when the file record was created (ISO 8601). Prisma: created_at.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"url\",\n          \"created_at\"\n        ],\n        \"description\": \"Attachment file overview record. Reflects the `attachment_files` Prisma schema for representing files uploaded, with storage info and provenance. Used anywhere file metadata and references are needed.\"\n      },\n      \"IPage.IPagination\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"current\": {\n            \"type\": \"integer\",\n            \"description\": \"Current page number of the result set.\",\n            \"format\": \"uint32\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"Maximum records returned per page. Default is 100.\",\n            \"format\": \"uint32\"\n          },\n          \"records\": {\n            \"type\": \"integer\",\n            \"description\": \"Total number of records found (for all pages).\",\n            \"format\": \"uint32\"\n          },\n          \"pages\": {\n            \"type\": \"integer\",\n            \"description\": \"Total number of pages calculated from records/limit (with ceiling).\",\n            \"format\": \"uint32\"\n          }\n        },\n        \"required\": [\n          \"current\",\n          \"limit\",\n          \"records\",\n          \"pages\"\n        ],\n        \"description\": \"Page information for paginated responses.\\n\\nIncludes current, limit, total records, and total pages for API responses adhering to the IPage<T> pattern.\"\n      },\n      \"IBbsArticleSnapshot.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"The unique identifier of the article snapshot to update. (Prisma: id)\\n\\nRequired for targeting the specific snapshot for partial update. Referenced as the 'id' column in bbs_article_snapshots.\"\n          },\n          \"tag\": {\n            \"type\": \"string\",\n            \"description\": \"Administrative tag or internal label for the snapshot. (example: evidence, correction). Not part of core article evidence body. Optional property for metadata management.\"\n          },\n          \"status\": {\n            \"type\": \"string\",\n            \"description\": \"Administrative status or moderation note (e.g. valid, under_review, censored, etc.). Optional. Used for possible status workflow by admins.\"\n          }\n        },\n        \"required\": [\n          \"id\"\n        ],\n        \"description\": \"Administrative update object for article snapshot entity. Used only by privileged actors for meta changes; does NOT allow editing of core version evidence content. Based on bbs_article_snapshots table, focusing on tag/status/meta-correction scenarios. Can be extended for further admin fields if required.\"\n      },\n      \"IBbsArticleComment.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for pagination. Optional. Defaults to 1 if absent.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Page number for pagination. Optional. Defaults to 1 if absent.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Number of comments per page. Optional. Defaults to 100.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Number of comments per page. Optional. Defaults to 100.\"\n          },\n          \"writer\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Filter for comments by specific writer's name. Used for searching. Optional.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Filter for comments by specific writer's name. Used for searching. Optional.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Parameters used for listing or searching comments linked to a specific article. Supports hierarchy, writer filter, and pagination. Corresponds to segment queries for comments shown in UI tree. Derived from comment request UI and bbs_article_comments schema.\"\n      },\n      \"IPageIBbsArticleComment.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleComment.ISummary\"\n            },\n            \"description\": \"Array of summarized comment objects for the current page.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated result of comment summaries for a given article. Includes a page info object and an array of summary comment objects (IBbsArticleComment.ISummary). Used for efficient comment list rendering with pagination in UI. Respects evidence and logical delete policy in returned records.\"\n      },\n      \"IBbsArticleComment.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Author name for the comment. (Prisma: writer, bbs_article_comments)\\n\\nRequired during creation, displayed publicly. Not a unique identifier but user-supplied.\"\n          },\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Plaintext password for comment creation. Stored in DB ONLY as a cryptographic hash. (Prisma: password, bbs_article_comments)\\n\\nMust not be returned in reads. Used for authentication in later mod/delete.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the comment body: e.g. 'html', 'markdown', 'txt'. (Prisma: format, bbs_article_comment_snapshots)\\n\\nEnables rendering multi-format body content in UI, evidence preservation.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Actual comment content.\\n\\nWhen created, stored in a snapshot record (bbs_article_comment_snapshots). Forms part of the evidential history.\"\n          },\n          \"attachments\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile.IReference\"\n                },\n                \"description\": \"Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address of commenter (from request context, not settable by user in API). Recorded for each evidence/snapshot. Used for dispute/evidence policy.\"\n          }\n        },\n        \"required\": [\n          \"writer\",\n          \"password\",\n          \"format\",\n          \"body\"\n        ],\n        \"description\": \"Request body for creating a new comment (root or reply). Carries author/writer, password, comment content (body), body format (html/md/txt), and (optionally) attachments. Parent_id links replies. On create, initializes a first snapshot for evidence. Based on bbs_article_comments and bbs_article_comment_snapshots schema columns.\"\n      },\n      \"IBbsArticleComment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment record. (Prisma: id, bbs_article_comments)\"\n          },\n          \"bbs_article_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"UUID of the parent article. (Prisma: bbs_article_id)\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's name (saved as plaintext, public).\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Comment creation timestamp (Prisma: created_at)\\n\\nIndicates original posting time and used in sorting/UI display.\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Logical deletion timestamp (Prisma: deleted_at; null if not deleted).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Logical deletion timestamp (Prisma: deleted_at; null if not deleted).\"\n          },\n          \"latest_snapshot\": {\n            \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\",\n            \"description\": \"The latest version/snapshot of the comment content.\\n\\nReferences evidence record for current visible body, format, and attachments. (bbs_article_comment_snapshots)\"\n          },\n          \"children\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"$ref\": \"#/components/schemas/IBbsArticleComment.ISummary\"\n                },\n                \"description\": \"Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI.\"\n          },\n          \"attachments\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile\"\n                },\n                \"description\": \"Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)\"\n          },\n          \"is_deleted\": {\n            \"type\": \"boolean\",\n            \"description\": \"Indicate whether comment is deleted (deleted_at != null). Not a DB field, for convenience only.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_id\",\n          \"writer\",\n          \"created_at\",\n          \"latest_snapshot\"\n        ],\n        \"description\": \"Full comment object with evidence/latest body, parent/child relations, deletion marker, and all metadata. Core entity is bbs_article_comments, with latest body joined from bbs_article_comment_snapshots. Attachments from attachment_files joined as needed. Used in detailed comment views, evidence review, or admin panels.\"\n      },\n      \"IBbsArticleComment.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Comment's unique ID\"\n          },\n          \"writer\": {\n            \"type\": \"string\",\n            \"description\": \"Writer's display name (public)\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Comment creation timestamp\"\n          },\n          \"deleted_at\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Comment logical deletion time (null if active)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Comment logical deletion time (null if active)\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"Most recent comment content (from latest snapshot for list view efficiency).\\n\\nNot always entire evidence record (see IBbsArticleComment for full version history).\"\n          },\n          \"attachments\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile.ISummary\"\n                },\n                \"description\": \"Brief info on attached files for the latest snapshot. Null or empty if none.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Brief info on attached files for the latest snapshot. Null or empty if none.\"\n          },\n          \"parent_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of parent comment if nested/reply, null if root-level.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"ID of parent comment if nested/reply, null if root-level.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"writer\",\n          \"created_at\",\n          \"body\"\n        ],\n        \"description\": \"Summary view for comment list (e.g., in IPageIBbsArticleComment.ISummary). Contains basic info for rendering top-level and nested comments efficiently. Attachments only as summary (IAttachmentFile.ISummary).\"\n      },\n      \"IBbsArticleComment.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Password supplied for verification (plaintext, compared securely to hash in DB).\\n\\nRequired for authentication before modifying the comment or any evidence content.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"New comment content/body to be recorded in a new snapshot version history (not in-place overwrite).\\n\\nPreserves evidence trail.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format indicator for new body (e.g. 'html', 'md', 'txt').\\n\\nAllows rich editing and multi-format content.\"\n          },\n          \"attachments\": {\n            \"oneOf\": [\n              {\n                \"type\": \"array\",\n                \"items\": {\n                  \"$ref\": \"#/components/schemas/IAttachmentFile.IReference\"\n                },\n                \"description\": \"Optional list of file attachment references for new revision (can add/remove/reorder).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Optional list of file attachment references for new revision (can add/remove/reorder).\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address of the modifier (system/infra-injected, not user-supplied).\"\n          }\n        },\n        \"required\": [\n          \"password\",\n          \"body\",\n          \"format\"\n        ],\n        \"description\": \"Request body for updating (editing) an existing comment. Password check required. New body content, format, and attachments create a new version snapshot for evidence. Based on schemas for bbs_article_comments and bbs_article_comment_snapshots.\"\n      },\n      \"IBbsArticleComment.IDelete\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"password\": {\n            \"type\": \"string\",\n            \"description\": \"Password supplied to verify correct authorization for logical deletion (soft delete). (Prisma: password, bbs_article_comments)\\n\\nSystem will check supplied plaintext against hash in DB.\"\n          }\n        },\n        \"required\": [\n          \"password\"\n        ],\n        \"description\": \"Request body for logical (soft) deletion of a comment. Only accepted from author with password verification. Triggers logical delete (sets deleted_at), but never physical removal.\"\n      },\n      \"IBbsArticleCommentSnapshot.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"bbs_article_comment_id\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"uuid\",\n                \"description\": \"ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments.\"\n          },\n          \"format\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Format filter (e.g.: html, md, txt)\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Format filter (e.g.: html, md, txt)\"\n          },\n          \"ip\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"IP address filter. Allows audit by IP evidence trail.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"IP address filter. Allows audit by IP evidence trail.\"\n          },\n          \"from_date\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"Start of creation date range filter (UTC).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Start of creation date range filter (UTC).\"\n          },\n          \"to_date\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"format\": \"date-time\",\n                \"description\": \"End of creation date range filter (UTC).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"End of creation date range filter (UTC).\"\n          },\n          \"page\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Page number for pagination.\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Page number for pagination.\"\n          },\n          \"limit\": {\n            \"oneOf\": [\n              {\n                \"type\": \"integer\",\n                \"format\": \"uint32\",\n                \"description\": \"Max records per page (default 100).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Max records per page (default 100).\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Parameters for searching/filtering comment snapshot records. Derived from bbs_article_comment_snapshots; used for evidence/audit UIs and administration. Includes support for paging, filtering by comment, format, IP address, date.\"\n      },\n      \"IPageIBbsArticleCommentSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot\"\n            },\n            \"description\": \"Snapshots for the selected page and criteria; array of full objects.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Page result type for listing comment snapshots. Returns IBbsArticleCommentSnapshot entities in paginated form with metadata for UI or admin consumption.\"\n      },\n      \"IBbsArticleCommentSnapshot\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the comment snapshot.\\n\\nCorresponds to Prisma: `id` column. Primary Key.\"\n          },\n          \"bbs_article_comment_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Reference to the parent comment this snapshot belongs to.\\n\\nPrisma: `bbs_article_comment_id`. Foreign Key referencing `bbs_article_comments.id`.\"\n          },\n          \"format\": {\n            \"type\": \"string\",\n            \"description\": \"Format of the comment body. For example, 'html', 'md', 'txt'.\\n\\nMaps to Prisma: `format` column.\"\n          },\n          \"body\": {\n            \"type\": \"string\",\n            \"description\": \"The actual content of the comment for this snapshot. Full bodies are preserved unmodified.\\n\\nPrisma: `body` column.\"\n          },\n          \"ip\": {\n            \"type\": \"string\",\n            \"description\": \"IP address of the author/modifier for this snapshot. Used for fraud prevention and evidence.\\n\\nPrisma: `ip` column.\"\n          },\n          \"created_at\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"Timestamp (ISO8601) indicating when this version (snapshot) was created.\\n\\nCorresponds to: `created_at` column in Prisma.\"\n          },\n          \"attachments\": {\n            \"type\": \"array\",\n            \"description\": \"List of attached files for this snapshot, with their sequence preserved.\\n\\nDerived from attachment M:N relations. Each item references `IAttachmentFile` with its own sequence.\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IBbsArticleCommentSnapshot.IAttachment\"\n            }\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"bbs_article_comment_id\",\n          \"format\",\n          \"body\",\n          \"ip\",\n          \"created_at\"\n        ],\n        \"description\": \"Snapshot entity containing revision information for a comment, preserving evidence for all edits or modifications.\\n\\nThis schema reflects the `bbs_article_comment_snapshots` table, storing all state for each modification, including content, format, timestamps, author IP, and attachments. Maintains historical records for compliance and dispute prevention.\"\n      },\n      \"IAttachmentFile.IReference\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Attachment File unique ID.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Order/position of file in attachments array (required for reordering files in snapshot, not in core 'attachment_files').\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"sequence\"\n        ],\n        \"description\": \"Reference to attachment file for linking to comments or comment snapshots. Used during comment create/update to form connection in evidence.\"\n      },\n      \"IAttachmentFile.ISummary\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Attachment File unique ID (summary view).\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"File name (without extension).\"\n          },\n          \"extension\": {\n            \"oneOf\": [\n              {\n                \"type\": \"string\",\n                \"description\": \"Extension (nullable, e.g. for README).\"\n              },\n              {\n                \"type\": \"null\"\n              }\n            ],\n            \"description\": \"Extension (nullable, e.g. for README).\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"Web-accessible URL for file download/preview.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"name\",\n          \"url\"\n        ],\n        \"description\": \"Summary view of attachment file, for efficient preview in lists or minimal context popups (less than IAttachmentFile).\"\n      },\n      \"IBbsArticleCommentSnapshot.IAttachment\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the attached file in this snapshot.\"\n          },\n          \"attachment_file_id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"ID reference of the attached file. Relates to `attachment_files.id`.\"\n          },\n          \"sequence\": {\n            \"type\": \"integer\",\n            \"description\": \"Order of the attachment in the snapshot's attachment list.\\n\\nPrisma: `sequence` column.\"\n          },\n          \"file\": {\n            \"$ref\": \"#/components/schemas/IAttachmentFile\",\n            \"description\": \"Metadata for the attachment file itself.\"\n          }\n        },\n        \"required\": [\n          \"id\",\n          \"attachment_file_id\",\n          \"sequence\",\n          \"file\"\n        ],\n        \"description\": \"Describes an attached file as linked through a comment snapshot, including metadata and sequence order.\\n\\nMaps to the join table in Prisma and composed for snapshot context.\"\n      },\n      \"IBbsArticleCommentSnapshot.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"meta_status\": {\n            \"type\": \"string\",\n            \"description\": \"Administrative or moderation status label for this snapshot, e.g., 'normal', 'flagged', 'corrected'. Not an original post field.\"\n          },\n          \"admin_note\": {\n            \"type\": \"string\",\n            \"description\": \"Free-form admin/moderator note for audit/tagging purposes.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Update parameters for allowed snapshot attributes (typically admin-only correction/annotation fields).\\n\\nContents subject to access restrictions and do not alter evidential snapshot content like body or IP.\"\n      },\n      \"IBbsArticleCommentSnapshot.IDelete\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"reason\": {\n            \"type\": \"string\",\n            \"description\": \"Optional reason or case label for logical deletion, used in admin audit context.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Administrative request to logically delete a comment snapshot. Used only by privileged users to maintain evidential integrity.\"\n      },\n      \"IAttachmentFile.IRequest\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Filter for the file name (not extension).\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"(Optional) Filter for file extension.\"\n          },\n          \"created_from\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"(Optional) Fetch attachment files created from this date/time (inclusive).\"\n          },\n          \"created_to\": {\n            \"type\": \"string\",\n            \"format\": \"date-time\",\n            \"description\": \"(Optional) Fetch attachment files created up to this date/time (inclusive).\"\n          },\n          \"page\": {\n            \"type\": \"integer\",\n            \"description\": \"The page number to retrieve for paginated results (optional).\\n\\nSee IPage.IRequest.\"\n          },\n          \"limit\": {\n            \"type\": \"integer\",\n            \"description\": \"Records per page to retrieve for paginated results (optional, default may be 100).\\n\\nSee IPage.IRequest.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Filtering and pagination query for searching attachment files.\\n\\nCombines optional name/extension filters and time-based constraints. Maps to Prisma query parameters and aligns with frontend search forms.\"\n      },\n      \"IPageIAttachmentFile\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"pagination\": {\n            \"$ref\": \"#/components/schemas/IPage.IPagination\",\n            \"description\": \"Pagination metadata, including page info and total records.\"\n          },\n          \"data\": {\n            \"type\": \"array\",\n            \"items\": {\n              \"$ref\": \"#/components/schemas/IAttachmentFile\"\n            },\n            \"description\": \"List of attachment file entities for this page of results.\"\n          }\n        },\n        \"required\": [\n          \"pagination\",\n          \"data\"\n        ],\n        \"description\": \"Paginated container of attachment file records, with page metadata and current result set. Adheres to IPage<T> standard pattern in all API paginated returns.\"\n      },\n      \"IAttachmentFile.ICreate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\",\n            \"format\": \"uuid\",\n            \"description\": \"Unique identifier for the attachment file (if pre-specified or generated before upload).\"\n          },\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Name of the file (not including extension). Prisma column: name.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension, e.g., 'jpg', 'pdf'. May be null or blank for extensionless files.\"\n          },\n          \"url\": {\n            \"type\": \"string\",\n            \"description\": \"URL or storage path where the file is accessible by clients. Prisma: url.\"\n          }\n        },\n        \"required\": [\n          \"name\",\n          \"url\"\n        ],\n        \"description\": \"Payload for registering a new file attachment entity.\\n\\nCovers all required fields for new file metadata except automatically-generated fields such as creation time.\"\n      },\n      \"IAttachmentFile.IUpdate\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": {\n            \"type\": \"string\",\n            \"description\": \"Updated file name without extension, if renaming is allowed.\"\n          },\n          \"extension\": {\n            \"type\": \"string\",\n            \"description\": \"File extension update, if required (null for none).\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Editable fields for an attachment file, for updating metadata such as name or extension. Typically admin-only. Prisma: `name`, `extension` columns.\"\n      },\n      \"IAttachmentFile.IDelete\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"confirm\": {\n            \"type\": \"boolean\",\n            \"description\": \"Whether to confirm deletion (required for APIs using staged delete patterns).\"\n          },\n          \"admin_reason\": {\n            \"type\": \"string\",\n            \"description\": \"Optional note by admin for the reason this file is being deleted.\"\n          }\n        },\n        \"required\": [],\n        \"description\": \"Payload to request logical deletion of an attachment file, with admin notes. For admin/audit use only.\"\n      }\n    }\n  },\n  \"x-samchon-emended-v4\": true\n}",
      "README.md": "# AutoBE Generated Backend Server\r\n\r\n![AutoBE Logo](https://github.com/user-attachments/assets/a90d14be-fd50-4dc7-ae9d-ca66c2124f31)\r\n\r\nA backend repository generated by [`@autobe`](https://github.com/wrtnlabs/autobe).\r\n\r\nThis backend program was automatically generated using [`@autobe`](https://github.com/wrtnlabs/autobe), the AI vibe coding agent for backend servers of below stack.\r\n\r\n- TypeScript\r\n- NestJS / Nestia\r\n- Prisma\r\n- Postgres\r\n\r\n## Project Structure\r\n\r\nThis template project has categorized directories like below.\r\n\r\nAs you can see from the below, all of the Backend source files are placed into the [src](src/) directory. When you build the TypeScript source files, compiled files would be placed into the `lib` directory following the [tsconfig.json](tsconfig.json) configuration. Otherwise you build client [SDK](#32-sdk) library for npm publishing and their compiled files would be placed into the [packages](packages) directory.\r\n\r\n  - [packages/api/](packages/api): SDK module built by `npm run build:api`\r\n  - [src/](src): Backend source directory\r\n    - [src/api/](src/api/): Client SDK that would be published to the `@ORGANIZATION/PROJECT-api`\r\n      - [**src/api/functional/**](src/api/functional/): API functions generated by the [`nestia`](https://github.com/samchon/nestia)\r\n      - [**src/api/structures/**](src/api/structures/): DTO structures\r\n    - [src/controllers/](src/controllers/): Controller classes of the Main Program\r\n  - [**test/**](test): Test Automation Program\r\n    - [test/features](test/features): List of test functions\r\n  - [nestia.config.ts](nestia.config.ts): Configuration file of [`nestia`](https://github.com/samchon/nestia)\r\n  - [package.json](package.json): NPM configuration\r\n  - [tsconfig.json](tsconfig.json): TypeScript configuration for the main program\r\n\r\n## NPM Run Commands\r\n\r\nList of the run commands defined in the [package.json](package.json) are like below:\r\n\r\n  - Test\r\n    - **`test`**: Run test automation program\r\n    - `benchmark`: Run performance benchmark program\r\n  - Build\r\n    - `build`: Build everything\r\n    - `build:main`: Build main program (`src` directory)\r\n    - `build:test` Build test automation program (`test` directory)\r\n    - `build:sdk`: Build SDK into main program only\r\n    - `build:swagger`: Build Swagger Documents\r\n    - **`dev`**: Incremental build for development (test program)\r\n  - Deploy\r\n    - `package:api`: Build and deploy the SDK library to the NPM\r\n    - `start`: Start the backend server\r\n    - `start:dev`: Start the backend server with incremental build and reload\r\n  - Webpack\r\n    - `webpack`: Run webpack bundler\r\n    - `webpack:start`: Start the backend server built by webpack\r\n    - `webpack:test`: Run test program to the webpack built\r\n\r\n## Specialization\r\n\r\nTransform this template project to be yours.\r\n\r\nWhen you've created a new backend project through this template project, you can specialize it to be suitable for you by changing some words. Replace below words through IDE specific function like `Edit > Replace in Files` (*Ctrl + Shift + H*), who've been supported by the VSCode.\r\n\r\n| Before       | After\r\n|--------------|----------------------------------------\r\n| ORGANIZATION | Your account or corporation name\r\n| PROJECT      | Your own project name\r\n| AUTHOR       | Author name\r\n| https://github.com/samchon/nestia-start | Your repository URL"
    },
    "document": {
      "operations": [
        {
          "specification": "List articles with filtering, searching, and pagination. Associated with the bbs_articles table. Should return summary information including linked last snapshot and basic info.",
          "description": "This API endpoint allows clients to retrieve a paginated, filtered, and/or sorted list of bulletin board articles. It references the bbs_articles table in Prisma, which holds basic post identity and author information, as well as deletion markers. Results typically include only non-deleted articles for general users (unless special admin permission is given). \n\nEach article summary should include the latest title (from the latest snapshot), author, creation time, and comment count. Filters may include search by title, author, date ranges, and possibly presence of comments. The endpoint should work efficiently by leveraging indexes on created_at and deleted_at for best performance. Soft-deleted posts are omitted except for admin access.\n\nRequest parameters support pagination with cursor/limit or offset/limit. Security: Access to deleted articles may depend on user role; listing of all (including deleted) may require admin level. Related API operation: GET /bbs/articles/{id} for detailed information. Errors for invalid search parameters, forbidden access, or server errors follow consistent patterns.",
          "summary": "List articles from bbs_articles with searching, pagination, and summary info.",
          "parameters": [],
          "requestBody": {
            "description": "Request parameters for listing articles, including filters (title, author, date), pagination (cursor/limit or offset/limit), and sorting options.",
            "typeName": "IBbsArticle.IRequest"
          },
          "responseBody": {
            "description": "Paged result containing articles' summary information, latest snapshot info, and comment counts.",
            "typeName": "IPageIBbsArticle.ISummary"
          },
          "path": "/bbs/articles",
          "method": "patch"
        },
        {
          "specification": "Create a new article. Associated with the bbs_articles and bbs_article_snapshots tables. Requires author, password, initial title/body, and can include files.",
          "description": "This endpoint allows a user to create a new bulletin board article. Upon invocation, a new record in bbs_articles is inserted, as well as a first snapshot in bbs_article_snapshots, containing the initial version's body, format, title, and IP address of the request. Attachments may also be uploaded and associated via attachment_files and bbs_article_snapshot_files junction.\n\nThe author provides a writer name, password (which must be encrypted before storage), and content (title, body, format). An array of file metadata may also be included. This route enforces presence of all required fields and validates file upload if present.\n\nSecurity: Password is stored only as a hash; plaintext password must not be stored. All significant actions (including IP address capture) must be logged and linked to the snapshot. Failure scenarios include missing/invalid required fields, unsupported file types, or database errors. Related: Modification is handled via PUT /bbs/articles/{id}; version retrieval by PATCH /bbs/articles/snapshots.",
          "summary": "Create a bulletin board article (bbs_articles + initial snapshot, with attachments).",
          "parameters": [],
          "requestBody": {
            "description": "New article creation info including writer, password, initial title and body, format, and optional file attachments.",
            "typeName": "IBbsArticle.ICreate"
          },
          "responseBody": {
            "description": "Created article info, including references to its first snapshot and any attachments.",
            "typeName": "IBbsArticle"
          },
          "path": "/bbs/articles",
          "method": "post"
        },
        {
          "specification": "Get a single article's full details, including latest snapshot and all metadata. Associated with bbs_articles and bbs_article_snapshots tables.",
          "description": "This endpoint retrieves all information required for a specific article, given its unique id (UUID). It uses the bbs_articles table to obtain author, creation time, and status (deleted or not). The latest version is provided by linking to the most recent bbs_article_snapshots record, including title, body, and format. Attachments related to the latest snapshot are also returned.\n\nIf the article is soft-deleted, its access may be restricted to admin-level or special permission users. IP information may be redacted for standard users to enhance privacy. The endpoint returns an error if the id is invalid or the article does not exist. This operation does not modify the database and is considered safe for client retrieval.\n\nRelated API: PATCH /bbs/articles for the listing. Errors adhere to the API's standard error response structure.",
          "summary": "Get detail on a single article (bbs_articles & latest snapshot, attachments, safe info).",
          "parameters": [
            {
              "name": "id",
              "description": "The article's unique identifier (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "All detail about the article, including metadata, current snapshot, and attachment files.",
            "typeName": "IBbsArticle"
          },
          "path": "/bbs/articles/{id}",
          "method": "get"
        },
        {
          "specification": "Update an article by creating a new snapshot/version. Associated with bbs_articles (for permission) and bbs_article_snapshots for versioning. Authors need to verify password.",
          "description": "This endpoint enables the modification of a previously created article. Modifications do not overwrite existing articles but result in a new record in bbs_article_snapshots linked to the same article. It enforces password verification against the article's hashed password before proceeding. Authors can change the title, body, body format, and update attachments through this operation.\n\nThe endpoint requires the article id, the writer's password (to be verified), and the new content. Attachments can be modified (added, removed, reordered) by specifying their metadata. If the password is invalid or missing, the operation fails with an appropriate error. Only non-deleted articles can be modified unless special permissions are given.\n\nSecurity: Store IP address and record the modification time. Existing snapshots remain immutable to preserve evidence/history. Updates to associated attachments create new junction entries for the new snapshot. Related API: GET /bbs/articles/{id} to fetch new version, PATCH /bbs/articles/snapshots to list all versions. All error and success responses follow universal API schema.",
          "summary": "Modify an article (bbs_articles): add snapshot and optionally modify attachments.",
          "parameters": [
            {
              "name": "id",
              "description": "Article's unique identifier (UUID) to update.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Update info for an article, including new title/body/format, re-attachment info, and password verification.",
            "typeName": "IBbsArticle.IUpdate"
          },
          "responseBody": {
            "description": "Article info and the newly created snapshot (representing the update), with attachments.",
            "typeName": "IBbsArticle"
          },
          "path": "/bbs/articles/{id}",
          "method": "put"
        },
        {
          "specification": "Soft-delete an article (logical deletion). Mark deleted_at and do not actually remove. Associated with bbs_articles.",
          "description": "This endpoint is for logically deleting an existing bulletin board article. It only marks the deleted_at field with the current timestamp, preserving the record for evidence and possible future administrative review. The request must include password verification for standard users; admin users may delete without password depending on config/policy. If the password is invalid or missing, the deletion will fail.\n\nLogically deleted articles are not shown in public lists but are still accessible for admin/forensic reasons. Physical deletion is never performed to maintain history. Errors are returned if the article is not found, already deleted, or password is incorrect. The operation records who (user, IP) deleted the item.",
          "summary": "Soft-delete (logical delete) a bulletin board article. Only marks deleted_at, no physical removal.",
          "parameters": [
            {
              "name": "id",
              "description": "Article's unique identifier (UUID) to soft-delete.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Password for soft-deletion verification if not admin. Admins may bypass password check.",
            "typeName": "IBbsArticle.IDelete"
          },
          "responseBody": {
            "description": "Confirmation, updated article info (with deleted_at time set).",
            "typeName": "IBbsArticle"
          },
          "path": "/bbs/articles/{id}",
          "method": "delete"
        },
        {
          "specification": "List all article snapshots (versions/history) with searching and pagination. Associated with bbs_article_snapshots table and referencing bbs_articles.",
          "description": "This endpoint provides a paginated, filterable, and sortable list of all article snapshots (historical versions), from the bbs_article_snapshots Prisma table. Clients can use this to access the full modification history for articles. \n\nSearch/explore versions by article id, creation time, writer IP, format, or keywords in title/body; efficient index access is required for performance. Pagination parameters are mandatory for scalability with growing history. Deleted articles' snapshots may be accessible to admins only. For standard users, only versions for non-deleted articles are returned. Snapshots include all version metadata (format, title, body, created_at, IP) and attachment references.\n\nRelated API: PATCH /bbs/articles for article overviews, GET /bbs/articles/snapshots/{id} for version detail.",
          "summary": "List (paged) article snapshots from bbs_article_snapshots, filter by article id, etc.",
          "parameters": [],
          "requestBody": {
            "description": "Snapshot search parameters: filters for article id, date ranges, IP, body/title keywords; plus pagination info.",
            "typeName": "IBbsArticleSnapshot.IRequest"
          },
          "responseBody": {
            "description": "Paged result of article snapshots with metadata and attachment summaries.",
            "typeName": "IPageIBbsArticleSnapshot.ISummary"
          },
          "path": "/bbs/articles/snapshots",
          "method": "patch"
        },
        {
          "specification": "Get snapshot details for a specific article version. Associated with bbs_article_snapshots table and references attachments/metadata.",
          "description": "This operation returns the full metadata for a specified article snapshot (by UUID), including all version metadata (title, body, format, created_at, IP address) and linked attachment file info. It is typically used to view historical versions of an article for evidence or audit purposes.\n\nAppropriate authorization may be required if the snapshot is for an article that has been deleted or is restricted. Errors are returned for non-existent IDs or unauthorized access. IP addresses may only be visible to admins. No modification of state occurs here.\n\nSecurity: Carefully audit access to preserve privacy. Related: POST/PATCH to list versions, parent article access via GET /bbs/articles/{id}. Error responses standardized.",
          "summary": "Get details of one article snapshot (version), including all metadata and its attachments.",
          "parameters": [
            {
              "name": "id",
              "description": "Snapshot's unique identifier (UUID).",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Snapshot detail including metadata and attachments.",
            "typeName": "IBbsArticleSnapshot"
          },
          "path": "/bbs/articles/snapshots/{id}",
          "method": "get"
        },
        {
          "specification": "Update an article snapshot (possibly only for admin, audit fix, or metadata tagging). bbs_article_snapshots table.",
          "description": "This admin-facing endpoint (rarely exposed to end-users) allows for partial updates (e.g., tagging or meta-corrections) to a specific snapshot record, identified by its UUID. Typical users will not modify snapshots (snapshots are append-only); this is for exceptional forensic or administrative cases.\n\nPermitted updates may include internal metadata such as status tagging or moderation flags, but NOT revision of original title/body/IP, to preserve evidence. Access strictly controlled; all actions audited. Operation rejected if forbidden fields are attempted to be changed or user is unauthorized. Related: GET /bbs/articles/snapshots/{id} for version details.",
          "summary": "Modify snapshot record's metadata (admin/forensic use only), not the actual version content.",
          "parameters": [
            {
              "name": "id",
              "description": "Snapshot's UUID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Patch request for allowed snapshot metadata fields (typ. tagging/status/mod notes).",
            "typeName": "IBbsArticleSnapshot.IUpdate"
          },
          "responseBody": {
            "description": "Snapshot record with updated metadata.",
            "typeName": "IBbsArticleSnapshot"
          },
          "path": "/bbs/articles/snapshots/{id}",
          "method": "put"
        },
        {
          "specification": "Delete an article snapshot (admin/forensic use only). Physically removes a version. bbs_article_snapshots table.",
          "description": "This highly restricted endpoint allows physical deletion of a single article snapshot by its UUID. Typically, this would only be permitted in cases of evidence tampering, privacy requests, or system maintenance. Regular users have no access.\n\nThe operation removes the historical version and updates all connected records accordingly. Audit logs should capture all deletions. Invalid/dependent snapshot deletion attempts result in errors. Recognize that removing a snapshot could compromise historical integrity, so authorization and safety nets must be ensured. Related: GET for details, PATCH for list.",
          "summary": "Permanently delete an article snapshot (admin maintenance/correction use), not for public users.",
          "parameters": [
            {
              "name": "id",
              "description": "Snapshot's UUID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Confirmation/metadata of deleted snapshot, or empty response.",
            "typeName": "IBbsArticleSnapshot"
          },
          "path": "/bbs/articles/snapshots/{id}",
          "method": "delete"
        },
        {
          "specification": "List comments for an article. Paginated, sorted, optionally filtered. bbs_article_comments, bbs_article_comment_snapshots, and tree structure.",
          "description": "This endpoint provides retrieval of a hierarchical, paginated, and searchable/commentable list of comments related to a particular article. Queries bbs_article_comments table for all comments (excluding deleted unless admin), joined with their latest snapshot record for current body/display (from bbs_article_comment_snapshots). Supports threaded replies with unlimited depth via parent_id.\n\nFilters include parent_id (for fetching root comments or replies), writer name, creation time, and support for pagination for large inputs. By default, only non-deleted comments are returned. Role-based logic may allow access to deleted comments for admins. Sorting can include time or hierarchy order.\n\nEfficient tree retrieval is required for good performance with nesting. Related endpoints: POST for new comment; GET /bbs/articles/{articleId}/comments/{id} for comment detail.",
          "summary": "Get a paginated and hierarchical list of comments for an article, showing current body.",
          "parameters": [
            {
              "name": "articleId",
              "description": "Article UUID for which to fetch comments.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Comment list request parameters: pagination, optional parent_id for segment, or search filters.",
            "typeName": "IBbsArticleComment.IRequest"
          },
          "responseBody": {
            "description": "Paged list/hierarchy of comments with metadata and their latest version body, excludes deleted unless admin.",
            "typeName": "IPageIBbsArticleComment.ISummary"
          },
          "path": "/bbs/articles/{articleId}/comments",
          "method": "patch"
        },
        {
          "specification": "Create a new comment for an article. bbs_article_comments, bbs_article_comment_snapshots. Associate with optional parent for replies and with attachments.",
          "description": "Enables the creation of a new comment (reply or root) on a specific article, specified by articleId. A record is inserted into bbs_article_comments along with a corresponding first snapshot in bbs_article_comment_snapshots (body, format, IP). This supports direct comments or reply chains by specifying parent_id in the body (for nested comments).\n\nComment must include writer, password (stored securely via hash), body, format, and can optionally reference files. Enforces required fields, validates permissions, checks nesting rules. Upon creation, the first snapshot is linked and metadata set. Logical deletion applies for future removal, not on creation.\n\nSecurity: All actions (IP, times) are audited; sensitive data such as passwords are hashed before storage. Failure triggers: missing/invalid params, wrong parent/article ID, DB errors. Related: PATCH for comment list; GET for comment details.",
          "summary": "Create a new comment or reply to an article, supporting nesting and attachments. Snapshots required for history.",
          "parameters": [
            {
              "name": "articleId",
              "description": "UUID of the article to comment on.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "New comment info: writer, password, body, format, parent_id (for reply), optional attachments.",
            "typeName": "IBbsArticleComment.ICreate"
          },
          "responseBody": {
            "description": "Newly created comment (and its first snapshot) with metadata, body, and attachments.",
            "typeName": "IBbsArticleComment"
          },
          "path": "/bbs/articles/{articleId}/comments",
          "method": "post"
        },
        {
          "specification": "Get the details (body, author, indexes, replies) of a specific comment, including its latest snapshot content and attachments. bbs_article_comments, bbs_article_comment_snapshots.",
          "description": "This endpoint fetches the full details for a single comment on a given article. Accepts the articleId for context and the comment's uuid as id. Joins the bbs_article_comments table (for metadata, writer, deletion status) with latest snapshot (from bbs_article_comment_snapshots) for body/format. Also fetches attachment info for the snapshot.\n\nDetails include: creation and (if) deletion timestamps, author, format, body, all attachments for the most recent version, parent/child info for replies, and optional list of immediate child comment IDs (to facilitate threaded UIs). Deleted comments are shown only with special permission (admin). If not found or not permitted, appropriate error returns.\n\nRelated: PATCH for listing, POST for creation. Error codes are standardized across comment operations.",
          "summary": "Get full details (including snapshot, attachments, and hierarchy) for one comment on an article.",
          "parameters": [
            {
              "name": "articleId",
              "description": "The article UUID where the comment belongs.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Comment's UUID to consult.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Comment detail with latest version body/format, metadata, and all attachments.",
            "typeName": "IBbsArticleComment"
          },
          "path": "/bbs/articles/{articleId}/comments/{id}",
          "method": "get"
        },
        {
          "specification": "Update an existing comment entity under a specific article. Associated with the 'bbs_article_comments' table in the Prisma schema. The update operation is performed after password verification and requires the articleId and commentId as path parameters. The request body contains the fields that can be updated such as writer, password, and possible references for comment structure. On successful update, all linked fields and snapshot references will reflect the new details, and a new snapshot should be created in accordance with the evidence-preserving policy. Logical constraints include password validation, upholding the logical deletion pattern (no physical removal), and reference integrity for hierarchical nesting.",
          "description": "This API endpoint allows a user to update a specific comment in the bulletin board system while maintaining a snapshot of the modification for evidence. The operation is secured by requiring the correct password for comment modification, as dictated by the system's security policy. On execution, a new snapshot will be generated, storing the old version and the modifying client's IP address, as per the evidential design. Only non-deleted comments are modifiable; comments previously soft-deleted (deleted_at set) will be rejected.\n\nValidation rules enforce existence of the referenced article and comment, correct hierarchical relationships for nested replies, required fields, and adherence to data consistency regarding attachments and format. The operation also ensures that password hashes are compared and never exposed in the API, supporting encrypted password storage.\n\nThis endpoint is related to: GET /bbs/articles/{articleId}/comments/{id} (fetch detail), POST /bbs/articles/{articleId}/comments (creation), and DELETE /bbs/articles/{articleId}/comments/{id} (logical deletion). Error responses include unauthorized modification, resource not found, and input validation failures.",
          "summary": "Update existing comment information in 'bbs_article_comments' for a given article and comment.",
          "parameters": [
            {
              "name": "articleId",
              "description": "Target article's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Target comment's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Updated data for the comment. Requires writer and password for authentication, and allows update of body/content fields.",
            "typeName": "IBbsArticleComment.IUpdate"
          },
          "responseBody": {
            "description": "Updated comment info with latest snapshot reference.",
            "typeName": "IBbsArticleComment"
          },
          "path": "/bbs/articles/{articleId}/comments/{id}",
          "method": "put"
        },
        {
          "specification": "Logically delete a specific comment from an article while preserving evidence, linked with the 'bbs_article_comments' entity in the database. The operation does not actually remove the comment but sets 'deleted_at' timestamp, excluding it from standard queries except for administrative viewing. A password check ensures only authorized users can logically delete. Related comment snapshots remain untouched to guarantee revision traceability for possible disputes.",
          "description": "This endpoint marks a specified comment under a particular article as deleted (soft delete). In accordance with the requirements, the comment is not physically removed, but its 'deleted_at' field is set to the current timestamp. If the supplied password does not match or the comment is already deleted, an error is returned. All historical snapshots for the comment are preserved, ensuring the full audit log needed for dispute resolution.\n\nThe endpoint performs validation for the existence of both the article and comment, ensures correct authorization (password validation), and returns the final comment record reflecting the logical deletion. This supports system requirements for evidence retention and access control for administrators.",
          "summary": "Logically delete a comment (set deleted_at) in 'bbs_article_comments' for a given article and comment ID.",
          "parameters": [
            {
              "name": "articleId",
              "description": "Target article's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            },
            {
              "name": "id",
              "description": "Target comment's ID",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Password required for logical deletion/authentication.",
            "typeName": "IBbsArticleComment.IDelete"
          },
          "responseBody": {
            "description": "Comment info after logical deletion (deleted_at set).",
            "typeName": "IBbsArticleComment"
          },
          "path": "/bbs/articles/{articleId}/comments/{id}",
          "method": "delete"
        },
        {
          "specification": "List snapshot records (historical versions) for all comments across articles. Associated with the 'bbs_article_comment_snapshots' table. This patch search endpoint supports filtering, pagination, and sorting criteria to efficiently retrieve multiple comment snapshot records based on attributes such as commentId, format, creation date, or IP address as required for audit, evidence, or administrative review.",
          "description": "This API operation retrieves a filtered and/or paginated list of comment snapshot records, representing the edit histories for comments. It serves both evidence management (viewing revision history) and administrative oversight (monitoring modifications and IP addresses). Supports filters for attributes such as comment ID(s), date range, format, or other metadata.\n\nThe endpoint enables clients to efficiently perform evidence review, discover all edits for a given comment or set of comments, and optionally aggregate statistics or metadata as needed. Error handling includes invalid filter criteria, pagination issues, or lack of results for the requested conditions.",
          "summary": "Retrieve a paginated list of comment snapshot records from 'bbs_article_comment_snapshots'.",
          "parameters": [],
          "requestBody": {
            "description": "Filtering and pagination parameters for searching comment snapshots.",
            "typeName": "IBbsArticleCommentSnapshot.IRequest"
          },
          "responseBody": {
            "description": "Paginated result of comment snapshot entities with filtering info.",
            "typeName": "IPageIBbsArticleCommentSnapshot"
          },
          "path": "/bbs/articles/comments/snapshots",
          "method": "patch"
        },
        {
          "specification": "Retrieve a specific comment snapshot entity by its unique identifier. Associated with the 'bbs_article_comment_snapshots' table, this GET operation obtains all evidential data about a particular version, for audit, user, or admin reference. Returns both the snapshot meta and, where applicable, related attachment metadata.",
          "description": "This endpoint fetches detailed information about a single comment snapshot, uniquely identified by its ID. It exposes all evidential attributes: body, format, creation time, IP address of the modifier, and linkage to its comment and parent article.\n\nIntended for history management screens or audit review, it supports full details, including attached file metadata, and can be used to display previous comment versions or investigate disputes. Related endpoints are PATCH /bbs/articles/comments/snapshots (for list/search) and PUT /bbs/articles/comments/snapshots/{id} (for administrative corrections, if permitted). Error handling includes resource not found, or access denied if applicable.",
          "summary": "Fetch detail information for a single comment snapshot by ID from 'bbs_article_comment_snapshots'.",
          "parameters": [
            {
              "name": "id",
              "description": "Target comment snapshot's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "The full information for a given comment snapshot, including content, meta, and file links.",
            "typeName": "IBbsArticleCommentSnapshot"
          },
          "path": "/bbs/articles/comments/snapshots/{id}",
          "method": "get"
        },
        {
          "specification": "Update administrative or evidential attributes of a specific comment snapshot. Associated with 'bbs_article_comment_snapshots', this endpoint allows precise modifications (e.g., corrections, administrative annotations) while preserving audit trails. Typically reserved for admin use as post-creation edits to snapshot content are generally prohibited by standard users in evidence-preserving systems.",
          "description": "This endpoint permits authorized administrative actors to update certain attributes of a comment snapshot, such as correcting metadata errors or annotating revisions, without breaking the snapshot audit chain. Input validation ensures that evidence integrity is not violated (for example, core content cannot be retroactively altered by general users). The endpoint is intended for corrective or special administrative functions.\n\nSecurity is enforced by access control: only privileged accounts may utilize this endpoint, and attempted use by general users will result in authorization errors. Error handling includes not found, insufficient rights, and input validation failures. Related operations include GET /bbs/articles/comments/snapshots/{id} (for reading) and PATCH /bbs/articles/comments/snapshots (for search/listing).",
          "summary": "Update specific snapshot attributes in 'bbs_article_comment_snapshots', primarily for admin use.",
          "parameters": [
            {
              "name": "id",
              "description": "Target comment snapshot's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields for administrative update of the snapshot. Restricted to allowable attributes only.",
            "typeName": "IBbsArticleCommentSnapshot.IUpdate"
          },
          "responseBody": {
            "description": "Updated comment snapshot info with admin/meta corrections applied.",
            "typeName": "IBbsArticleCommentSnapshot"
          },
          "path": "/bbs/articles/comments/snapshots/{id}",
          "method": "put"
        },
        {
          "specification": "Logically delete a specific comment snapshot for evidence maintenance or administrative purposes. Linked with the 'bbs_article_comment_snapshots' table. The operation will typically soft-delete (set a deleted indicator or flag) and does not physically remove the record; this maintains auditability and regulatory compliance. Security policy prevents general users from using this endpoint; for admin-only deletion operations.",
          "description": "This endpoint marks a comment snapshot as deleted (usually via a logical delete flag or 'deleted_at' timestamp, in line with the overall evidence preservation policy). Physical deletion from the database is forbidden; the operation is reserved for administrators or regulatory compliance requirements only. Related files and linkages remain for audit traceability.\n\nAttempts to use this endpoint without sufficient privilege are denied. Related endpoints include GET /bbs/articles/comments/snapshots/{id} (for reading), PUT /bbs/articles/comments/snapshots/{id} (for administrative update), and DELETE /bbs/articles/comments/snapshots/{id} for logical removal. Error responses occur for not found, insufficient rights, and policy violations.",
          "summary": "Logically delete a comment snapshot in 'bbs_article_comment_snapshots' by ID, for admin use only.",
          "parameters": [
            {
              "name": "id",
              "description": "Target comment snapshot's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Administrative request to logically delete the given comment snapshot. Only privileged users allowed.",
            "typeName": "IBbsArticleCommentSnapshot.IDelete"
          },
          "responseBody": {
            "description": "The logically deleted comment snapshot info, with deletion meta/flag set.",
            "typeName": "IBbsArticleCommentSnapshot"
          },
          "path": "/bbs/articles/comments/snapshots/{id}",
          "method": "delete"
        },
        {
          "specification": "Retrieve a paginated, filterable list of attachment file entities as stored in the 'attachment_files' table. The endpoint should support common query parameters such as file name, extension, or creation date, and return both file metadata and usage context as needed.",
          "description": "This API operation returns a list of all attachment files stored within the system, with optional filters for name, extension, and creation date. Its main use cases involve browsing available files, administratively locating uploaded materials, and supplying metadata for attachment management operations (e.g., linking files to post/comment snapshots).\n\nResults support pagination, sorting, and advanced search conditions. Error handling ensures proper response to invalid search parameters and out-of-bounds pagination values.",
          "summary": "Get a paginated/searchable list of attachment files from 'attachment_files'.",
          "parameters": [],
          "requestBody": {
            "description": "Filtering and pagination options for searching attachment files.",
            "typeName": "IAttachmentFile.IRequest"
          },
          "responseBody": {
            "description": "Paginated, filtered list of matching attachment file entities.",
            "typeName": "IPageIAttachmentFile"
          },
          "path": "/attachmentFiles",
          "method": "patch"
        },
        {
          "specification": "Create a new attachment file entity within the 'attachment_files' table. The file is first uploaded (to storage or CDN), then its metadata and reference (URL, filename, extension, etc.) are recorded in the database. On success, the file becomes available for linking to article or comment snapshots. Requires all core fields, including storage location (url).",
          "description": "This endpoint registers a new file after upload by inserting its key metadata into the 'attachment_files' schema table. It records the file name, extension (if any), URL, and the creation date. Input validation ensures file name and URL are present, extension is allowed or nullable, and that no collisions occur for unique IDs. File upload should be processed prior to this call, which is only for metadata registration and not for the binary upload process itself.\n\nThe endpoint is often called by UI file upload interfaces before associating the file with posts/comments. Errors may include invalid input, file type restrictions, or unique constraint violations on file ID.",
          "summary": "Register a new attachment file in 'attachment_files' with all required metadata.",
          "parameters": [],
          "requestBody": {
            "description": "Attachment file registration information (metadata only, upload handled separately).",
            "typeName": "IAttachmentFile.ICreate"
          },
          "responseBody": {
            "description": "Attachment file metadata referencing the stored/uploaded file.",
            "typeName": "IAttachmentFile"
          },
          "path": "/attachmentFiles",
          "method": "post"
        },
        {
          "specification": "Retrieve information for a specific attachment file from the 'attachment_files' table. This endpoint returns all file metadata including usage context if available. Used for management, UI preview, and integrity checking. Supports administrative and user contexts.",
          "description": "This API operation fetches the details of an individual attachment file by its unique ID. It returns all metadata (name, extension, URL, creation time), and can include cross-references to snapshots where used. Used in file management screens, attachment UI, or for audit purposes.\n\nThe endpoint validates the existence of the requested file and returns an informative error if not found. Related endpoints include PATCH /attachmentFiles (for listing) and DELETE /attachmentFiles/{id} (for deletion).",
          "summary": "Fetch information for a single attachment file by ID from 'attachment_files'.",
          "parameters": [
            {
              "name": "id",
              "description": "Target attachment file's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": null,
          "responseBody": {
            "description": "Complete metadata for the requested attachment file.",
            "typeName": "IAttachmentFile"
          },
          "path": "/attachmentFiles/{id}",
          "method": "get"
        },
        {
          "specification": "Update metadata for an existing attachment file in 'attachment_files'. Use to rename, correct extensions, or alter usage notes. Modifications are restricted to admin users, ensuring integrity of references and system consistency. Prevents orphaning files still in use or breaking links from snapshots.",
          "description": "This endpoint updates fields such as the filename, extension, or other attributes for an attachment file already present in the database. Authorization is required (typically admin-level) to prevent accidental or malicious alteration of shared files. Validation ensures referential integrity with linked snapshots and prevents breaking links. Only fields allowed for update by business logic can be altered; changes to URL or creation dates may be restricted.\n\nError handling addresses non-existent files, permission errors, and attempts to update disallowed fields. Related endpoints: GET /attachmentFiles/{id} (for reading), PATCH /attachmentFiles (for listing), and DELETE /attachmentFiles/{id} (for deletion).",
          "summary": "Update metadata of an attachment file in 'attachment_files' (admin only).",
          "parameters": [
            {
              "name": "id",
              "description": "Target attachment file's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Fields for updating information about the attachment file.",
            "typeName": "IAttachmentFile.IUpdate"
          },
          "responseBody": {
            "description": "Updated metadata of the attachment file entity.",
            "typeName": "IAttachmentFile"
          },
          "path": "/attachmentFiles/{id}",
          "method": "put"
        },
        {
          "specification": "Logically delete an attachment file in 'attachment_files' by ID. The file metadata and record are preserved for audit, and actual deletion from storage is handled separately if allowed. Prevents removing files in use by posts or comments.",
          "description": "This endpoint marks an attachment file as logically deleted (typically by setting a flag or deletion timestamp) to preserve auditability and avoid removing files that may still be linked from evidence snapshots. Actual file removal from storage, if any, is beyond the scope of this endpoint. Authorization is enforced for only privileged users (like admins) to use this endpoint.\n\nBefore deletion, the system checks that the file is not referenced by any snapshots to prevent orphaning or evidence loss. Any deletion attempt for files still in use results in an error. Related endpoints: PUT /attachmentFiles/{id} (for update) and GET /attachmentFiles/{id} (for reading).",
          "summary": "Logically delete an attachment file by ID in 'attachment_files' (admin only, prevents deletion if referenced).",
          "parameters": [
            {
              "name": "id",
              "description": "Target attachment file's ID.",
              "schema": {
                "type": "string",
                "format": "uuid"
              }
            }
          ],
          "requestBody": {
            "description": "Logical deletion request for attachment file, with admin authorization.",
            "typeName": "IAttachmentFile.IDelete"
          },
          "responseBody": {
            "description": "Attachment file entity after logical deletion (flag set or deleted).",
            "typeName": "IAttachmentFile"
          },
          "path": "/attachmentFiles/{id}",
          "method": "delete"
        }
      ],
      "components": {
        "schemas": {
          "IBbsArticle.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "format": "uint32",
                "description": "The page number for pagination.\n\nPrisma schema correspondence: BBS article list query pagination. Optional value."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Number of articles per page. Defaults to 100.\n\nPrisma schema correspondence: Used in paginated queries."
              },
              "writer": {
                "type": "string",
                "description": "Writer's name filter.\n\nPrisma: bbs_articles.writer."
              },
              "title": {
                "type": "string",
                "description": "Article title filter. Search will apply to the latest snapshot's title.\n\nPrisma: bbs_article_snapshots.title."
              },
              "date_from": {
                "type": "string",
                "format": "date-time",
                "description": "Start date/time for filtering articles by creation time.\n\nPrisma: bbs_articles.created_at."
              },
              "date_to": {
                "type": "string",
                "format": "date-time",
                "description": "End date/time for filtering articles by creation time.\n\nPrisma: bbs_articles.created_at."
              },
              "has_comment": {
                "type": "boolean",
                "description": "Filter for articles with or without comments.\n\nPrisma: bbs_article_comments (count > 0)."
              }
            },
            "description": "Request parameters for listing/filtering bulletin board articles.\n\nReferences bbs_articles for identity, and bbs_article_snapshots for title filters. Supports pagination, search, and filter criteria. Used for PATCH /bbs/articles list endpoint.",
            "required": []
          },
          "IPageIBbsArticle.ISummary": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsArticle.ISummary"
                },
                "description": "List of summary objects for articles.\n\nEach includes last snapshot's title and metadata."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated result containing summary information for multiple bulletin board articles.\n\nUsed as the return type for article list endpoints with filtering, sort and pagination."
          },
          "IBbsArticle.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the article.\n\nPrisma: bbs_articles.id."
              },
              "writer": {
                "type": "string",
                "description": "Name of the article writer. \n\nPrisma: bbs_articles.writer."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Creation timestamp of the article.\n\nPrisma: bbs_articles.created_at."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Deletion timestamp, if the article has been deleted (logical delete).\n\nPrisma: bbs_articles.deleted_at.\n\nNull when not deleted."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Deletion timestamp, if the article has been deleted (logical delete).\n\nPrisma: bbs_articles.deleted_at.\n\nNull when not deleted."
              },
              "title": {
                "type": "string",
                "description": "The title of the latest snapshot for the article.\n\nPrisma: bbs_article_snapshots.title (most recent)."
              },
              "comment_count": {
                "type": "integer",
                "description": "The number of non-deleted comments on the article.\n\nCalculated from bbs_article_comments where deleted_at is null."
              }
            },
            "required": [
              "id",
              "writer",
              "created_at",
              "title",
              "comment_count"
            ],
            "description": "Summary output for a bulletin board article. Contains identifying and display information, including latest title and comment count.\n\nDraws on bbs_articles and latest record in bbs_article_snapshots."
          },
          "IBbsArticle.ICreate": {
            "type": "object",
            "properties": {
              "writer": {
                "type": "string",
                "description": "Name of the article's writer. Required on creation.\n\nPrisma: bbs_articles.writer."
              },
              "password": {
                "type": "string",
                "description": "Write-access password for the article, supplied as plain text and stored hashed.\n\nPrisma: bbs_articles.password."
              },
              "title": {
                "type": "string",
                "description": "Article's initial title.\n\nStored within the first snapshot. Prisma: bbs_article_snapshots.title."
              },
              "body": {
                "type": "string",
                "description": "The initial body/content of the article.\n\nPrisma: bbs_article_snapshots.body."
              },
              "format": {
                "type": "string",
                "description": "Format of the article body (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
              },
              "attachments": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "List of attachment file UUIDs to be linked with initial snapshot (order preserved). Optional.\n\nPrisma: bbs_article_snapshot_files. Can be empty array."
              }
            },
            "required": [
              "writer",
              "password",
              "title",
              "body",
              "format"
            ],
            "description": "Request body to create a new article. Includes metadata, content, attachments.\n\nMaps to bbs_articles for writer/password and to bbs_article_snapshots for content/history. Passwords are never stored in plain text after receipt."
          },
          "IBbsArticle": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the article.\n\nPrisma: bbs_articles.id."
              },
              "writer": {
                "type": "string",
                "description": "The article's writer name.\n\nPrisma: bbs_articles.writer."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Time article was created.\n\nPrisma: bbs_articles.created_at."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Logical deletion timestamp. Set on article deletion, or null if not deleted.\n\nPrisma: bbs_articles.deleted_at."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Logical deletion timestamp. Set on article deletion, or null if not deleted.\n\nPrisma: bbs_articles.deleted_at."
              },
              "latest_snapshot": {
                "$ref": "#/components/schemas/IBbsArticleSnapshot",
                "description": "Current/latest snapshot information for the article (title/body/format).\n\nReferences most recent bbs_article_snapshots record."
              },
              "comment_count": {
                "type": "integer",
                "description": "Number of non-deleted comments attached to this article.\n\nDerived from bbs_article_comments."
              },
              "attachments": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IAttachmentFile"
                },
                "description": "Files attached to the latest article snapshot, ordered.\n\nReferences attachment_files via bbs_article_snapshot_files."
              }
            },
            "required": [
              "id",
              "writer",
              "created_at",
              "latest_snapshot",
              "comment_count"
            ],
            "description": "Full representation of a bulletin board article, including metadata, current version info, comments count, and attachments.\n\nCombines bbs_articles with latest bbs_article_snapshots and relevant relationships."
          },
          "IBbsArticle.IUpdate": {
            "type": "object",
            "properties": {
              "password": {
                "type": "string",
                "description": "Writer's password for authentication prior to modification.\n\nPrisma: bbs_articles.password (hashed, verify only)."
              },
              "title": {
                "type": "string",
                "description": "Updated article title (becomes latest snapshot when modified).\n\nPrisma: bbs_article_snapshots.title."
              },
              "body": {
                "type": "string",
                "description": "Updated article content/body.\n\nPrisma: bbs_article_snapshots.body."
              },
              "format": {
                "type": "string",
                "description": "Updated body format (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
              },
              "attachments": {
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uuid"
                },
                "description": "New array of attachment file UUIDs to associate with new snapshot (order preserved). Optional.\n\nPrisma: bbs_article_snapshot_files."
              }
            },
            "required": [
              "password",
              "title",
              "body",
              "format"
            ],
            "description": "Body for updating an article. All modifications result in creation of a new snapshot with revised content/attachments.\n\nRequires password verification for security. Snapshots are appended, not overwritten."
          },
          "IBbsArticle.IDelete": {
            "type": "object",
            "properties": {
              "password": {
                "type": "string",
                "description": "Password for writer authentication prior to logical deletion.\n\nPrisma: bbs_articles.password. Admins may not require."
              }
            },
            "required": [
              "password"
            ],
            "description": "Delete request body for soft-deletion of an article. Verifies password.\n\nMarks deleted_at, but keeps record for dispute evidence preservation. Only privileged roles may bypass password."
          },
          "IBbsArticleSnapshot.IRequest": {
            "type": "object",
            "properties": {
              "page": {
                "type": "integer",
                "format": "uint32",
                "description": "Pagination: page number.\n\nUsed for paginated history listing."
              },
              "limit": {
                "type": "integer",
                "format": "uint32",
                "description": "Pagination: number of items per page.\n\nDefaults to 100."
              },
              "bbs_article_id": {
                "type": "string",
                "format": "uuid",
                "description": "Filter snapshots to a single article.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
              },
              "ip": {
                "type": "string",
                "description": "IP address filter for snapshot writer.\n\nPrisma: bbs_article_snapshots.ip."
              },
              "format": {
                "type": "string",
                "description": "Body format filter (e.g., 'md', 'html', 'txt').\n\nPrisma: bbs_article_snapshots.format."
              },
              "date_from": {
                "type": "string",
                "format": "date-time",
                "description": "Filter: Only snapshots created after this ISO datetime."
              },
              "date_to": {
                "type": "string",
                "format": "date-time",
                "description": "Filter: Only snapshots created before this ISO datetime."
              }
            },
            "description": "Request body for searching/listing article snapshots. Supports filter and pagination fields. Used for PATCH /bbs/articles/snapshots endpoint.",
            "required": []
          },
          "IPageIBbsArticleSnapshot.ISummary": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsArticleSnapshot.ISummary"
                },
                "description": "List of article snapshot summaries (basic version info, omitting full body)."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated result type for listing snapshot summaries for articles.\n\nAggregates bbs_article_snapshots metadata for multiple snapshots."
          },
          "IBbsArticleSnapshot.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the article snapshot.\n\nPrisma: bbs_article_snapshots.id."
              },
              "bbs_article_id": {
                "type": "string",
                "format": "uuid",
                "description": "Article to which this snapshot belongs.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
              },
              "title": {
                "type": "string",
                "description": "Title for this version of the article.\n\nPrisma: bbs_article_snapshots.title."
              },
              "format": {
                "type": "string",
                "description": "Body format for this version.\n\nPrisma: bbs_article_snapshots.format."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp (ISO) when this snapshot record was created.\n\nPrisma: bbs_article_snapshots.created_at."
              }
            },
            "required": [
              "id",
              "bbs_article_id",
              "title",
              "format",
              "created_at"
            ],
            "description": "Summary object for an article snapshot, containing identifying info and display metadata.\n\nExcludes body/content and attachments."
          },
          "IBbsArticleSnapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID for this article snapshot (version record).\n\nPrisma: bbs_article_snapshots.id."
              },
              "bbs_article_id": {
                "type": "string",
                "format": "uuid",
                "description": "Article this version belongs to.\n\nPrisma: bbs_article_snapshots.bbs_article_id."
              },
              "title": {
                "type": "string",
                "description": "Display title for this version state.\n\nPrisma: bbs_article_snapshots.title."
              },
              "body": {
                "type": "string",
                "description": "Content body of the article at this snapshot/version.\n\nPrisma: bbs_article_snapshots.body."
              },
              "format": {
                "type": "string",
                "description": "Body format (e.g., md, html, txt).\n\nPrisma: bbs_article_snapshots.format."
              },
              "ip": {
                "type": "string",
                "description": "IP address of the snapshot's author/editor.\n\nPrisma: bbs_article_snapshots.ip."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp when the snapshot was created.\n\nPrisma: bbs_article_snapshots.created_at."
              },
              "attachments": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IAttachmentFile"
                },
                "description": "Attachment files for this article snapshot, in order.\n\nReferences attachment_files via bbs_article_snapshot_files."
              }
            },
            "required": [
              "id",
              "bbs_article_id",
              "title",
              "body",
              "format",
              "ip",
              "created_at"
            ],
            "description": "Full representation of a specific article snapshot/version. Contains title, content, author IP, creation time, and all associated attachments.\n\nMaps to bbs_article_snapshots, attachment_files, and related junction tables."
          },
          "IAttachmentFile": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the attachment file. Prisma column: id."
              },
              "name": {
                "type": "string",
                "description": "Filename without extension (original name)."
              },
              "extension": {
                "type": "string",
                "description": "File extension, e.g., 'png', 'pdf'. May be blank or null."
              },
              "url": {
                "type": "string",
                "description": "URL (complete path) where this file can be downloaded or viewed. Prisma: url."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp when the file record was created (ISO 8601). Prisma: created_at."
              }
            },
            "required": [
              "id",
              "name",
              "url",
              "created_at"
            ],
            "description": "Attachment file overview record. Reflects the `attachment_files` Prisma schema for representing files uploaded, with storage info and provenance. Used anywhere file metadata and references are needed."
          },
          "IPage.IPagination": {
            "type": "object",
            "properties": {
              "current": {
                "type": "integer",
                "description": "Current page number of the result set.",
                "format": "uint32"
              },
              "limit": {
                "type": "integer",
                "description": "Maximum records returned per page. Default is 100.",
                "format": "uint32"
              },
              "records": {
                "type": "integer",
                "description": "Total number of records found (for all pages).",
                "format": "uint32"
              },
              "pages": {
                "type": "integer",
                "description": "Total number of pages calculated from records/limit (with ceiling).",
                "format": "uint32"
              }
            },
            "required": [
              "current",
              "limit",
              "records",
              "pages"
            ],
            "description": "Page information for paginated responses.\n\nIncludes current, limit, total records, and total pages for API responses adhering to the IPage<T> pattern."
          },
          "IBbsArticleSnapshot.IUpdate": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "The unique identifier of the article snapshot to update. (Prisma: id)\n\nRequired for targeting the specific snapshot for partial update. Referenced as the 'id' column in bbs_article_snapshots."
              },
              "tag": {
                "type": "string",
                "description": "Administrative tag or internal label for the snapshot. (example: evidence, correction). Not part of core article evidence body. Optional property for metadata management."
              },
              "status": {
                "type": "string",
                "description": "Administrative status or moderation note (e.g. valid, under_review, censored, etc.). Optional. Used for possible status workflow by admins."
              }
            },
            "required": [
              "id"
            ],
            "description": "Administrative update object for article snapshot entity. Used only by privileged actors for meta changes; does NOT allow editing of core version evidence content. Based on bbs_article_snapshots table, focusing on tag/status/meta-correction scenarios. Can be extended for further admin fields if required."
          },
          "IBbsArticleComment.IRequest": {
            "type": "object",
            "properties": {
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "ID of parent comment, if retrieving replies or subtree. If null, fetch root comments. (Prisma: parent_id, bbs_article_comments)"
              },
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Page number for pagination. Optional. Defaults to 1 if absent."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Page number for pagination. Optional. Defaults to 1 if absent."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Number of comments per page. Optional. Defaults to 100."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Number of comments per page. Optional. Defaults to 100."
              },
              "writer": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Filter for comments by specific writer's name. Used for searching. Optional."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Filter for comments by specific writer's name. Used for searching. Optional."
              }
            },
            "required": [],
            "description": "Parameters used for listing or searching comments linked to a specific article. Supports hierarchy, writer filter, and pagination. Corresponds to segment queries for comments shown in UI tree. Derived from comment request UI and bbs_article_comments schema."
          },
          "IPageIBbsArticleComment.ISummary": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsArticleComment.ISummary"
                },
                "description": "Array of summarized comment objects for the current page."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated result of comment summaries for a given article. Includes a page info object and an array of summary comment objects (IBbsArticleComment.ISummary). Used for efficient comment list rendering with pagination in UI. Respects evidence and logical delete policy in returned records."
          },
          "IBbsArticleComment.ICreate": {
            "type": "object",
            "properties": {
              "writer": {
                "type": "string",
                "description": "Author name for the comment. (Prisma: writer, bbs_article_comments)\n\nRequired during creation, displayed publicly. Not a unique identifier but user-supplied."
              },
              "password": {
                "type": "string",
                "description": "Plaintext password for comment creation. Stored in DB ONLY as a cryptographic hash. (Prisma: password, bbs_article_comments)\n\nMust not be returned in reads. Used for authentication in later mod/delete."
              },
              "format": {
                "type": "string",
                "description": "Format of the comment body: e.g. 'html', 'markdown', 'txt'. (Prisma: format, bbs_article_comment_snapshots)\n\nEnables rendering multi-format body content in UI, evidence preservation."
              },
              "body": {
                "type": "string",
                "description": "Actual comment content.\n\nWhen created, stored in a snapshot record (bbs_article_comment_snapshots). Forms part of the evidential history."
              },
              "attachments": {
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/IAttachmentFile.IReference"
                    },
                    "description": "Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Array of file metadata for attachments (if any) included with comment creation. Each entry references file uploaded by user. (Relationship to attachment_files via bbs_article_comment_snapshot_files)"
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Optional; ID of parent comment for replies. If present, links this comment as a reply in nesting tree. Enables hierarchy. (Prisma: parent_id)"
              },
              "ip": {
                "type": "string",
                "description": "IP address of commenter (from request context, not settable by user in API). Recorded for each evidence/snapshot. Used for dispute/evidence policy."
              }
            },
            "required": [
              "writer",
              "password",
              "format",
              "body"
            ],
            "description": "Request body for creating a new comment (root or reply). Carries author/writer, password, comment content (body), body format (html/md/txt), and (optionally) attachments. Parent_id links replies. On create, initializes a first snapshot for evidence. Based on bbs_article_comments and bbs_article_comment_snapshots schema columns."
          },
          "IBbsArticleComment": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the comment record. (Prisma: id, bbs_article_comments)"
              },
              "bbs_article_id": {
                "type": "string",
                "format": "uuid",
                "description": "UUID of the parent article. (Prisma: bbs_article_id)"
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Parent comment id for reply/nesting structure. (Prisma: parent_id; nullable for top-level comments)"
              },
              "writer": {
                "type": "string",
                "description": "Writer's name (saved as plaintext, public)."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Comment creation timestamp (Prisma: created_at)\n\nIndicates original posting time and used in sorting/UI display."
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Logical deletion timestamp (Prisma: deleted_at; null if not deleted)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Logical deletion timestamp (Prisma: deleted_at; null if not deleted)."
              },
              "latest_snapshot": {
                "$ref": "#/components/schemas/IBbsArticleCommentSnapshot",
                "description": "The latest version/snapshot of the comment content.\n\nReferences evidence record for current visible body, format, and attachments. (bbs_article_comment_snapshots)"
              },
              "children": {
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/IBbsArticleComment.ISummary"
                    },
                    "description": "Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Immediate children comments (replies) for threading/hierarchy. Populated depending on endpoint and UI."
              },
              "attachments": {
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/IAttachmentFile"
                    },
                    "description": "Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Array of files attached to the latest version/snapshot. (via bbs_article_comment_snapshot_files, joined from attachment_files)"
              },
              "is_deleted": {
                "type": "boolean",
                "description": "Indicate whether comment is deleted (deleted_at != null). Not a DB field, for convenience only."
              }
            },
            "required": [
              "id",
              "bbs_article_id",
              "writer",
              "created_at",
              "latest_snapshot"
            ],
            "description": "Full comment object with evidence/latest body, parent/child relations, deletion marker, and all metadata. Core entity is bbs_article_comments, with latest body joined from bbs_article_comment_snapshots. Attachments from attachment_files joined as needed. Used in detailed comment views, evidence review, or admin panels."
          },
          "IBbsArticleComment.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Comment's unique ID"
              },
              "writer": {
                "type": "string",
                "description": "Writer's display name (public)"
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Comment creation timestamp"
              },
              "deleted_at": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Comment logical deletion time (null if active)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Comment logical deletion time (null if active)"
              },
              "body": {
                "type": "string",
                "description": "Most recent comment content (from latest snapshot for list view efficiency).\n\nNot always entire evidence record (see IBbsArticleComment for full version history)."
              },
              "attachments": {
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/IAttachmentFile.ISummary"
                    },
                    "description": "Brief info on attached files for the latest snapshot. Null or empty if none."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Brief info on attached files for the latest snapshot. Null or empty if none."
              },
              "parent_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of parent comment if nested/reply, null if root-level."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "ID of parent comment if nested/reply, null if root-level."
              }
            },
            "required": [
              "id",
              "writer",
              "created_at",
              "body"
            ],
            "description": "Summary view for comment list (e.g., in IPageIBbsArticleComment.ISummary). Contains basic info for rendering top-level and nested comments efficiently. Attachments only as summary (IAttachmentFile.ISummary)."
          },
          "IBbsArticleComment.IUpdate": {
            "type": "object",
            "properties": {
              "password": {
                "type": "string",
                "description": "Password supplied for verification (plaintext, compared securely to hash in DB).\n\nRequired for authentication before modifying the comment or any evidence content."
              },
              "body": {
                "type": "string",
                "description": "New comment content/body to be recorded in a new snapshot version history (not in-place overwrite).\n\nPreserves evidence trail."
              },
              "format": {
                "type": "string",
                "description": "Format indicator for new body (e.g. 'html', 'md', 'txt').\n\nAllows rich editing and multi-format content."
              },
              "attachments": {
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/IAttachmentFile.IReference"
                    },
                    "description": "Optional list of file attachment references for new revision (can add/remove/reorder)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Optional list of file attachment references for new revision (can add/remove/reorder)."
              },
              "ip": {
                "type": "string",
                "description": "IP address of the modifier (system/infra-injected, not user-supplied)."
              }
            },
            "required": [
              "password",
              "body",
              "format"
            ],
            "description": "Request body for updating (editing) an existing comment. Password check required. New body content, format, and attachments create a new version snapshot for evidence. Based on schemas for bbs_article_comments and bbs_article_comment_snapshots."
          },
          "IBbsArticleComment.IDelete": {
            "type": "object",
            "properties": {
              "password": {
                "type": "string",
                "description": "Password supplied to verify correct authorization for logical deletion (soft delete). (Prisma: password, bbs_article_comments)\n\nSystem will check supplied plaintext against hash in DB."
              }
            },
            "required": [
              "password"
            ],
            "description": "Request body for logical (soft) deletion of a comment. Only accepted from author with password verification. Triggers logical delete (sets deleted_at), but never physical removal."
          },
          "IBbsArticleCommentSnapshot.IRequest": {
            "type": "object",
            "properties": {
              "bbs_article_comment_id": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "ID of the comment whose snapshots are being fetched. Optional filter, can be null for global search in all comments."
              },
              "format": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Format filter (e.g.: html, md, txt)"
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Format filter (e.g.: html, md, txt)"
              },
              "ip": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "IP address filter. Allows audit by IP evidence trail."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "IP address filter. Allows audit by IP evidence trail."
              },
              "from_date": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "Start of creation date range filter (UTC)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Start of creation date range filter (UTC)."
              },
              "to_date": {
                "oneOf": [
                  {
                    "type": "string",
                    "format": "date-time",
                    "description": "End of creation date range filter (UTC)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "End of creation date range filter (UTC)."
              },
              "page": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Page number for pagination."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Page number for pagination."
              },
              "limit": {
                "oneOf": [
                  {
                    "type": "integer",
                    "format": "uint32",
                    "description": "Max records per page (default 100)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Max records per page (default 100)."
              }
            },
            "required": [],
            "description": "Parameters for searching/filtering comment snapshot records. Derived from bbs_article_comment_snapshots; used for evidence/audit UIs and administration. Includes support for paging, filtering by comment, format, IP address, date."
          },
          "IPageIBbsArticleCommentSnapshot": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination"
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IBbsArticleCommentSnapshot"
                },
                "description": "Snapshots for the selected page and criteria; array of full objects."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Page result type for listing comment snapshots. Returns IBbsArticleCommentSnapshot entities in paginated form with metadata for UI or admin consumption."
          },
          "IBbsArticleCommentSnapshot": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the comment snapshot.\n\nCorresponds to Prisma: `id` column. Primary Key."
              },
              "bbs_article_comment_id": {
                "type": "string",
                "format": "uuid",
                "description": "Reference to the parent comment this snapshot belongs to.\n\nPrisma: `bbs_article_comment_id`. Foreign Key referencing `bbs_article_comments.id`."
              },
              "format": {
                "type": "string",
                "description": "Format of the comment body. For example, 'html', 'md', 'txt'.\n\nMaps to Prisma: `format` column."
              },
              "body": {
                "type": "string",
                "description": "The actual content of the comment for this snapshot. Full bodies are preserved unmodified.\n\nPrisma: `body` column."
              },
              "ip": {
                "type": "string",
                "description": "IP address of the author/modifier for this snapshot. Used for fraud prevention and evidence.\n\nPrisma: `ip` column."
              },
              "created_at": {
                "type": "string",
                "format": "date-time",
                "description": "Timestamp (ISO8601) indicating when this version (snapshot) was created.\n\nCorresponds to: `created_at` column in Prisma."
              },
              "attachments": {
                "type": "array",
                "description": "List of attached files for this snapshot, with their sequence preserved.\n\nDerived from attachment M:N relations. Each item references `IAttachmentFile` with its own sequence.",
                "items": {
                  "$ref": "#/components/schemas/IBbsArticleCommentSnapshot.IAttachment"
                }
              }
            },
            "required": [
              "id",
              "bbs_article_comment_id",
              "format",
              "body",
              "ip",
              "created_at"
            ],
            "description": "Snapshot entity containing revision information for a comment, preserving evidence for all edits or modifications.\n\nThis schema reflects the `bbs_article_comment_snapshots` table, storing all state for each modification, including content, format, timestamps, author IP, and attachments. Maintains historical records for compliance and dispute prevention."
          },
          "IAttachmentFile.IReference": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Attachment File unique ID."
              },
              "sequence": {
                "type": "integer",
                "description": "Order/position of file in attachments array (required for reordering files in snapshot, not in core 'attachment_files')."
              }
            },
            "required": [
              "id",
              "sequence"
            ],
            "description": "Reference to attachment file for linking to comments or comment snapshots. Used during comment create/update to form connection in evidence."
          },
          "IAttachmentFile.ISummary": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Attachment File unique ID (summary view)."
              },
              "name": {
                "type": "string",
                "description": "File name (without extension)."
              },
              "extension": {
                "oneOf": [
                  {
                    "type": "string",
                    "description": "Extension (nullable, e.g. for README)."
                  },
                  {
                    "type": "null"
                  }
                ],
                "description": "Extension (nullable, e.g. for README)."
              },
              "url": {
                "type": "string",
                "description": "Web-accessible URL for file download/preview."
              }
            },
            "required": [
              "id",
              "name",
              "url"
            ],
            "description": "Summary view of attachment file, for efficient preview in lists or minimal context popups (less than IAttachmentFile)."
          },
          "IBbsArticleCommentSnapshot.IAttachment": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the attached file in this snapshot."
              },
              "attachment_file_id": {
                "type": "string",
                "format": "uuid",
                "description": "ID reference of the attached file. Relates to `attachment_files.id`."
              },
              "sequence": {
                "type": "integer",
                "description": "Order of the attachment in the snapshot's attachment list.\n\nPrisma: `sequence` column."
              },
              "file": {
                "$ref": "#/components/schemas/IAttachmentFile",
                "description": "Metadata for the attachment file itself."
              }
            },
            "required": [
              "id",
              "attachment_file_id",
              "sequence",
              "file"
            ],
            "description": "Describes an attached file as linked through a comment snapshot, including metadata and sequence order.\n\nMaps to the join table in Prisma and composed for snapshot context."
          },
          "IBbsArticleCommentSnapshot.IUpdate": {
            "type": "object",
            "properties": {
              "meta_status": {
                "type": "string",
                "description": "Administrative or moderation status label for this snapshot, e.g., 'normal', 'flagged', 'corrected'. Not an original post field."
              },
              "admin_note": {
                "type": "string",
                "description": "Free-form admin/moderator note for audit/tagging purposes."
              }
            },
            "required": [],
            "description": "Update parameters for allowed snapshot attributes (typically admin-only correction/annotation fields).\n\nContents subject to access restrictions and do not alter evidential snapshot content like body or IP."
          },
          "IBbsArticleCommentSnapshot.IDelete": {
            "type": "object",
            "properties": {
              "reason": {
                "type": "string",
                "description": "Optional reason or case label for logical deletion, used in admin audit context."
              }
            },
            "required": [],
            "description": "Administrative request to logically delete a comment snapshot. Used only by privileged users to maintain evidential integrity."
          },
          "IAttachmentFile.IRequest": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "(Optional) Filter for the file name (not extension)."
              },
              "extension": {
                "type": "string",
                "description": "(Optional) Filter for file extension."
              },
              "created_from": {
                "type": "string",
                "format": "date-time",
                "description": "(Optional) Fetch attachment files created from this date/time (inclusive)."
              },
              "created_to": {
                "type": "string",
                "format": "date-time",
                "description": "(Optional) Fetch attachment files created up to this date/time (inclusive)."
              },
              "page": {
                "type": "integer",
                "description": "The page number to retrieve for paginated results (optional).\n\nSee IPage.IRequest."
              },
              "limit": {
                "type": "integer",
                "description": "Records per page to retrieve for paginated results (optional, default may be 100).\n\nSee IPage.IRequest."
              }
            },
            "required": [],
            "description": "Filtering and pagination query for searching attachment files.\n\nCombines optional name/extension filters and time-based constraints. Maps to Prisma query parameters and aligns with frontend search forms."
          },
          "IPageIAttachmentFile": {
            "type": "object",
            "properties": {
              "pagination": {
                "$ref": "#/components/schemas/IPage.IPagination",
                "description": "Pagination metadata, including page info and total records."
              },
              "data": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/IAttachmentFile"
                },
                "description": "List of attachment file entities for this page of results."
              }
            },
            "required": [
              "pagination",
              "data"
            ],
            "description": "Paginated container of attachment file records, with page metadata and current result set. Adheres to IPage<T> standard pattern in all API paginated returns."
          },
          "IAttachmentFile.ICreate": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "format": "uuid",
                "description": "Unique identifier for the attachment file (if pre-specified or generated before upload)."
              },
              "name": {
                "type": "string",
                "description": "Name of the file (not including extension). Prisma column: name."
              },
              "extension": {
                "type": "string",
                "description": "File extension, e.g., 'jpg', 'pdf'. May be null or blank for extensionless files."
              },
              "url": {
                "type": "string",
                "description": "URL or storage path where the file is accessible by clients. Prisma: url."
              }
            },
            "required": [
              "name",
              "url"
            ],
            "description": "Payload for registering a new file attachment entity.\n\nCovers all required fields for new file metadata except automatically-generated fields such as creation time."
          },
          "IAttachmentFile.IUpdate": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string",
                "description": "Updated file name without extension, if renaming is allowed."
              },
              "extension": {
                "type": "string",
                "description": "File extension update, if required (null for none)."
              }
            },
            "required": [],
            "description": "Editable fields for an attachment file, for updating metadata such as name or extension. Typically admin-only. Prisma: `name`, `extension` columns."
          },
          "IAttachmentFile.IDelete": {
            "type": "object",
            "properties": {
              "confirm": {
                "type": "boolean",
                "description": "Whether to confirm deletion (required for APIs using staged delete patterns)."
              },
              "admin_reason": {
                "type": "string",
                "description": "Optional note by admin for the reason this file is being deleted."
              }
            },
            "required": [],
            "description": "Payload to request logical deletion of an attachment file, with admin notes. For admin/audit use only."
          }
        }
      }
    },
    "created_at": "2025-05-23T12:19:06.900Z",
    "reason": "Step to the interface designing after DB schema generation",
    "step": 1
  }
]